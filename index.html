<html lang="zh-TW">

<head>
    <script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
            return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
            if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
                try {
                    var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                    var firstSheetName = workbook.SheetNames[0];
                    var worksheet = workbook.Sheets[firstSheetName];

                    // Convert sheet to JSON to filter blank rows
                    var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                    // Filter out blank rows (rows where all cells are empty, null, or undefined)
                    var filteredData = jsonData.filter(row => row.some(filledCell));

                    // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                    var headerRowIndex = filteredData.findIndex((row, index) =>
                        row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                    );
                    // Fallback
                    if (headerRowIndex === -1 || headerRowIndex > 25) {
                        headerRowIndex = 0;
                    }

                    // Convert filtered JSON back to CSV
                    var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                    csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                    return csv;
                } catch (e) {
                    console.error(e);
                    return "";
                }
            }
            return gk_fileData[filename] || "";
        }
    </script>




    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>遊戲計算器</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/core-js/3.38.1/minified.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-latest/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/recharts@2.12.7/umd/Recharts.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        cherry: {
                            50: '#fff0f6',
                            100: '#ffd6e7',
                            200: '#ffadd2',
                            300: '#ff85b8',
                            400: '#f75998',
                            500: '#eb2f7a',
                            600: '#c41d5d',
                            700: '#9e1045',
                            800: '#78062f',
                            900: '#52001d',
                        },
                        chart: {
                            blue: '#3b82f6',
                            green: '#10b981',
                            purple: '#8b5cf6',
                            teal: '#14b8a6',
                            orange: '#f97316',
                        }
                    }
                }
            }
        }
    </script>
    <script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
            return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
            if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
                try {
                    var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                    var firstSheetName = workbook.SheetNames[0];
                    var worksheet = workbook.Sheets[firstSheetName];
                    var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                    var filteredData = jsonData.filter(row => row.some(filledCell));
                    var headerRowIndex = filteredData.findIndex((row, index) =>
                        row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                    );
                    if (headerRowIndex === -1 || headerRowIndex > 25) {
                        headerRowIndex = 0;
                    }
                    var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                    csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                    return csv;
                } catch (e) {
                    console.error(e);
                    return "";
                }
            }
            return gk_fileData[filename] || "";
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');

        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #fff0f6;
            margin: 0;
            padding: 0;
        }

        .input-focus:focus {
            border-color: #eb2f7a;
            box-shadow: 0 0 0 3px rgba(235, 47, 122, 0.2);
            outline: none;
        }

        .cherry-gradient {
            background: linear-gradient(135deg, #ffd6e7 0%, #eb2f7a 100%);
        }

        .result-card {
            transition: all 0.3s ease;
        }

        .result-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(235, 47, 122, 0.1);
        }

        .scrollbar-cherry::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .scrollbar-cherry::-webkit-scrollbar-track {
            background: #ffd6e7;
        }

        .scrollbar-cherry::-webkit-scrollbar-thumb {
            background-color: #eb2f7a;
            border-radius: 20px;
        }

        .tooltip-hidden {
            display: none;
        }

        .group:hover .tooltip-hidden,
        .group:active .tooltip-hidden {
            display: block;
        }

        @media (max-width: 640px) {
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.125rem;
            }

            input,
            button,
            select {
                font-size: 0.875rem;
                padding: 0.5rem;
            }
        }
    </style>
</head>

<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect } = React;

        const {
            LineChart,
            Line,
            XAxis,
            YAxis,
            CartesianGrid,
            Tooltip,
            Legend,
            ResponsiveContainer,
        } = Recharts;

        // Sidebar Component
        const Sidebar = ({ setActiveCalculator }) => {
            const [isOpen, setIsOpen] = useState(false);

            return (
                <>
                    <button
                        className="md:hidden fixed top-4 left-4 z-50 text-cherry-800 p-2 rounded-full bg-cherry-100 hover:bg-cherry-200"
                        onClick={() => setIsOpen(!isOpen)}
                        aria-label="展開側邊欄"
                    >
                        <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16m-7 6h7" />
                        </svg>
                    </button>
                    <div
                        className={`fixed top-0 left-0 h-full bg-cherry-50 w-64 transform ${isOpen ? 'translate-x-0' : '-translate-x-full'
                            } md:translate-x-0 transition-transform duration-300 ease-in-out z-40 shadow-lg`}
                    >
                        <div className="p-4">
                            <h2 className="text-lg font-bold text-cherry-800">計算器</h2>
                            <nav className="mt-4 space-y-2">
                                <button
                                    onClick={() => { setActiveCalculator('damage'); setIsOpen(false); }}
                                    className="block w-full text-left py-2 px-4 text-cherry-700 hover:bg-cherry-100 rounded-lg transition-colors"
                                >
                                    防守計算器
                                </button>
                                <button
                                    onClick={() => { setActiveCalculator('healing'); setIsOpen(false); }}
                                    className="block w-full text-left py-2 px-4 text-cherry-700 hover:bg-cherry-100 rounded-lg transition-colors"
                                >
                                    治療強度計算
                                </button>
                                <button
                                    onClick={() => { setActiveCalculator('damage_2'); setIsOpen(false); }}
                                    className="block w-full text-left py-2 px-4 text-cherry-700 hover:bg-cherry-100 rounded-lg transition-colors"
                                >
                                    攻擊計算器
                                </button>
                            </nav>
                        </div>
                    </div>
                    {isOpen && (
                        <div
                            className="fixed inset-0 bg-black bg-opacity-50 md:hidden z-30"
                            onClick={() => setIsOpen(false)}
                        ></div>
                    )}
                </>
            );
        };

        const HomeMenu = () => {
            const [activeCalculator, setActiveCalculator] = useState(null);

            useEffect(() => {
                // 初次載入跳出提醒
                alert(
                    '⚠️ 1 計算器非最終傷害，僅作面板屬性收益計算之用\n' +
                    '⚠️ 2 僅 PVP 適用，PVE 請自己打木樁測試\n' +
                    '⚠️ 3 圖片識別使用免費資源，準確度堪憂，建議手動輸入\n' +
                    '⚠️ 4 有問題可聯絡 ID 櫻桃百蘭地，會擺爛式修正'
                );
            }, []);

            // 首頁選單
            if (!activeCalculator) {
                return (
                    <div className="min-h-screen flex flex-col items-center justify-center px-4">
                        <h1 className="text-3xl font-bold text-cherry-800 mb-8">屬性收益分析計算器</h1>
                        <div className="grid grid-cols-1 sm:grid-cols-3 gap-6 w-full max-w-4xl">
                            <button
                                onClick={() => setActiveCalculator('damage')}
                                className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition result-card"
                            >
                                防守計算器
                            </button>
                            <button
                                onClick={() => setActiveCalculator('healing')}
                                className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition result-card"
                            >
                                治療強度計算
                            </button>
                            <button
                                onClick={() => setActiveCalculator('damage_2')}
                                className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition result-card"
                            >
                                攻擊計算器
                            </button>
                        </div>
                    </div>
                );
            }

            // 根據選擇渲染對應的計算器
            return (
                <>
                    <Sidebar setActiveCalculator={setActiveCalculator} />
                    {activeCalculator === 'damage' && <div><DamageCalculator /></div>}
                    {activeCalculator === 'healing' && <div><HealingCalculator /></div>}
                    {activeCalculator === 'damage_2' && <div><DamageCalculator2 /></div>}
                </>
            );
        };


        // ImageUploader Component
        const ImageUploader = ({ setInputs, type }) => {
            const [uploadedImages, setUploadedImages] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [progress, setProgress] = useState(0);
            const [error, setError] = useState(null);

            const handleImageUpload = (event) => {
                const files = Array.from(event.target.files).slice(0, 5); // 限制最多5張圖片
                if (files.length > 0) {
                    setUploadedImages(files);
                    setError(null);
                }
            };

            const preprocessImage = (file) => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.src = URL.createObjectURL(file);
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const MAX_SIZE = 1280;
                        let { width, height } = img;
                        if (width > MAX_SIZE || height > MAX_SIZE) {
                            const ratio = Math.min(MAX_SIZE / width, MAX_SIZE / height);
                            width *= ratio;
                            height *= ratio;
                        }
                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);

                        // Grayscale and binarization
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        for (let i = 0; i < data.length; i += 4) {
                            const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                            const binary = avg > 128 ? 255 : 0;
                            data[i] = data[i + 1] = data[i + 2] = binary;
                        }
                        ctx.putImageData(imageData, 0, 0);

                        canvas.toBlob((blob) => {
                            resolve(blob);
                        }, 'image/png');
                    };
                    img.onerror = () => {
                        setError('圖像加載失敗，請檢查文件格式');
                        resolve(file);
                    };
                });
            };

            const startRecognition = async () => {
                if (uploadedImages.length === 0) return;

                setIsProcessing(true);
                setProgress(0);
                setError(null);

                let combinedValues = {};

                for (let i = 0; i < uploadedImages.length; i++) {
                    const file = uploadedImages[i];
                    try {
                        const processedImage = await preprocessImage(file);

                        const { data: { text } } = await Tesseract.recognize(
                            processedImage,
                            'chi_tra+eng',
                            {
                                logger: m => {
                                    if (m.status === 'recognizing text') {
                                        setProgress(Math.round((i / uploadedImages.length + m.progress / uploadedImages.length) * 100));
                                    }
                                }
                            }
                        );

                        const values = parseText(text, type);
                        if (Object.keys(values).length === 0) {
                            setError(`圖片 ${file.name} 未能識別到有效數據，請確保圖片清晰且包含屬性文字`);
                        }
                        combinedValues = { ...combinedValues, ...values };

                    } catch (error) {
                        console.error(`處理圖片 ${file.name} 時出錯：`, error);
                        setError(`處理圖片 ${file.name} 時出錯：${error.message}`);
                    }
                }

                if (Object.keys(combinedValues).length > 0) {
                    setInputs(prev => ({ ...prev, ...combinedValues }));
                }
                setIsProcessing(false);
                setProgress(0);
            };

            const parseText = (text, type) => {
                const values = {};
                const regex = /([\u4e00-\u9fa5]+[\u4e00-\u9fa5\s：:]*)\s*[：:]*\s*([\d.,\/%-]+(?:\s*-\s*\d+)?)/g;
                let match;

                while ((match = regex.exec(text)) !== null) {
                    const label = match[1].trim().replace(/\s+/g, '');
                    let value = match[2].replace(/[,]/g, '').replace('%', '');

                    if (type === 'attacker') {
                        if (label.includes('技能倍率')) values.skill_multiplier = value;
                        if (label.includes('攻擊') && !label.includes('元素攻擊') && !label.includes('攻擊%')) {
                            const [low] = value.split('-').map(Number);
                            values.D = low.toString();
                        }
                        if (label.includes('元素攻擊')) values.E = value;
                        if (label.includes('會心數值') || (label.includes('會心') && !label.includes('會心傷害') && !label.includes('會心防禦'))) {
                            values.b_c = value;
                        }
                        if (label.includes('會心傷害')) {
                            values.d_c = (parseFloat(value) / 100).toString();
                        }
                        if (label.includes('流派克制') && !label.includes('流派克制%')) {
                            const [baseValue] = value.split('/').map(v => v.trim());
                            values.R = baseValue;
                        }
                        if (label.includes('流派克制%')) {
                            const [, percentValue] = value.split('/').map(v => parseFloat(v));
                            values.flow_percent = (percentValue / 100).toString();
                        }
                        if (label.includes('命中')) values.h = value;
                        if (label.includes('破防')) values.b_d = value;
                        if (label.includes('破盾')) values.b_s = value;
                        if (label.includes('忽視元素抗性')) values.b_e = value;
                        if (label.includes('增傷')) {
                            values.damage_increase = (parseFloat(value) / 100).toString();
                        }
                        if (label.includes('技能增傷')) {
                            values.skill_damage_increase = (parseFloat(value) / 100).toString();
                        }
                        if (label.includes('金周天')) {
                            if (value.includes('1級') || value.includes('1')) values.gold_i = '0.03';
                            else if (value.includes('2級') || value.includes('2')) values.gold_i = '0.04';
                            else if (value.includes('3級') || value.includes('3')) values.gold_i = '0.05';
                            else values.gold_i = '0';
                        }
                    } else if (type === 'defender') {
                        if (label.includes('氣血')) values.hp = value.split('/')[0];
                        if (label.includes('防禦')) values.d_d = value;
                        if (label.includes('抗會心數值') || (label.includes('會心') && !label.includes('會心傷害') && !label.includes('會心防禦'))) {
                            values.b_c_defense = value;
                        }
                        if (label.includes('會心防禦')) {
                            values.d_c_defense = (parseFloat(value) / 100).toString();
                        }
                        if (label.includes('格擋')) values.b_b = value;
                        if (label.includes('元素抗性')) values.d_e = value;
                        if (label.includes('傷害減免')) {
                            values.damage_reduction = (parseFloat(value) / 100).toString();
                        }
                        if (label.includes('流派抵禦') && !label.includes('流派抵禦%')) {
                            const [baseValue] = value.split('/').map(v => v.trim());
                            values.d_f = baseValue;
                        }
                        if (label.includes('流派抵禦%')) {
                            const [, percentValue] = value.split('/').map(v => parseFloat(v));
                            values.flow_resist_percent = (percentValue / 100).toString();
                        }
                        if (label.includes('怪物克制')) {
                            const [, second] = value.split('/').map(v => parseFloat(v));
                            values.flow_resist_percent = (second / 100).toString();
                        }
                        if (label.includes('氣盾')) values.d_s = value;
                        if (label.includes('技能減免')) values.skill_damage_reduction = (parseFloat(value) / 100).toString();
                    }

                    if (label.includes('破防')) values.armor_break = value;
                    if (label.includes('命中')) values.hit = value;
                    if (label.includes('元素攻擊')) values.elemental_attack = value;
                    if (label.includes('首領克制')) {
                        const [first] = value.split('/').map(v => parseFloat(v));
                        values.boss_restraint = first.toString();
                    }
                    if (label.includes('流派克制')) {
                        const [first, second] = value.split('/').map(v => parseFloat(v));
                        values.faction_restraint = Math.max(first, second).toString();
                    }
                    if (label.includes('抗性忽視')) values.resistance_ignore = value;
                    if (label.includes('治療強度')) values.healing_power_equip = value;
                }
                return values;
            };

            return (
                <div className="mb-4">
                    <label className="block mb-2 text-sm font-medium text-gray-700">
                        {type === 'attacker' ? '上傳攻擊方截圖' : type === 'defender' ? '上傳防守方截圖' : '上傳截圖'}
                    </label>
                    <input
                        type="file"
                        accept="image/*"
                        onChange={handleImageUpload}
                        multiple
                        className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-cherry-500 file:text-white hover:file:bg-cherry-600"
                    />
                    {error && (
                        <p className="mt-2 text-sm text-red-600">{error}</p>
                    )}
                    {uploadedImages.length > 0 && (
                        <div className="mt-2 flex items-center space-x-2">
                            <p className="text-xs text-gray-500">已選 {uploadedImages.length} 張圖片</p>
                            <button
                                onClick={startRecognition}
                                disabled={isProcessing}
                                className="bg-cherry-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-cherry-700 disabled:bg-cherry-300 transition-colors"
                            >
                                {isProcessing ? `識別中... ${progress}%` : '開始識別'}
                            </button>
                        </div>
                    )}
                    {isProcessing && (
                        <div className="mt-2 w-full bg-gray-200 rounded-full h-2.5">
                            <div
                                className="bg-cherry-600 h-2.5 rounded-full transition-all duration-300"
                                style={{ width: `${progress}%` }}
                            ></div>
                        </div>
                    )}
                </div>
            );
        };

        // HealingCalculator Component
        const HealingCalculator = () => {
            const [inputs, setInputs] = useState({
                armor_break: "0",
                hit: "0",
                elemental_attack: "0",
                boss_restraint: "0",
                faction_restraint: "0",
                resistance_ignore: "0",
                healing_power_equip: "0"
            });
            const [inputErrors, setInputErrors] = useState({});

            const handleChange = (e) => {
                const { name, value } = e.target;
                if (value < 0) {
                    setInputErrors((prev) => ({ ...prev, [name]: '輸入值不能為負數' }));
                    return;
                }
                if (value > 1000000) {
                    setInputErrors((prev) => ({ ...prev, [name]: '輸入值過大，最大為100000' }));
                    return;
                }
                setInputs((prev) => ({ ...prev, [name]: value }));
                setInputErrors((prev) => ({ ...prev, [name]: '' }));
            };

            const calculateHealing = () => {
                const {
                    armor_break, hit, elemental_attack, boss_restraint, faction_restraint, resistance_ignore, healing_power_equip
                } = inputs;

                const toNum = (val) => parseFloat(val) || 0;

                const attributeConversion = (
                    (toNum(armor_break) * 3 / 1000) +
                    (toNum(hit) * 9 / 1000) +
                    (toNum(elemental_attack) * 7 / 1000) +
                    (toNum(boss_restraint) * 3 / 1000) +
                    (toNum(faction_restraint) * 3 / 1000) +
                    (toNum(resistance_ignore) * 9 / 1000)
                );

                const healingPower = Math.floor(attributeConversion) * 100 + toNum(healing_power_equip) + 503;

                return {
                    attributeConversion: attributeConversion.toFixed(2),
                    healingPower: healingPower.toFixed(0)
                };
            };

            const result = calculateHealing();

            return (
                <div className="p-4 container mx-auto min-h-screen">
                    <div className="cherry-gradient rounded-xl p-6 mb-6 shadow-lg">
                        <h1 className="text-xl md:text-2xl font-bold text-center text-white">治療強度計算器</h1>
                        <p className="text-center text-white text-opacity-90 text-sm mt-1">如有問題請聯繫櫻桃白蘭地@緣定今生</p>
                    </div>

                    <ImageUploader setInputs={setInputs} type="healing" />

                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div className="flex items-center mb-4">
                            <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                            <h2 className="font-bold text-base md:text-lg text-gray-800">治療參數</h2>
                        </div>
                        <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                            {[
                                { key: "armor_break", label: "破防", icon: "🛡️" },
                                { key: "hit", label: "命中", icon: "🎯" },
                                { key: "elemental_attack", label: "元素攻擊", icon: "✨" },
                                { key: "boss_restraint", label: "首領克制", icon: "👑" },
                                { key: "faction_restraint", label: "流派克制", icon: "🔄" },
                                { key: "resistance_ignore", label: "抗性忽視", icon: "🌀" },
                                { key: "healing_power_equip", label: "治療強度（裝備）", icon: "💉" }
                            ].map(({ key, label, icon }) => (
                                <div key={key} className="flex flex-col">
                                    <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                        <span className="mr-1 md:mr-2">{icon}</span>{label}
                                    </label>
                                    <input
                                        type="number"
                                        name={key}
                                        value={inputs[key]}
                                        onChange={handleChange}
                                        min="0"
                                        max="1000000"
                                        className={`input-focus border ${inputErrors[key] ? 'border-red-500' : 'border-gray-200'} rounded-lg p-2 text-sm w-full`}
                                        aria-label={label}
                                    />
                                    {inputErrors[key] && (
                                        <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="result-card bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100">
                        <div className="flex items-center mb-4">
                            <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                            <h2 className="font-bold text-base md:text-lg text-gray-800">計算結果</h2>
                        </div>
                        <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                            <div className="bg-cherry-50 p-3 rounded-lg">
                                <p className="text-xs text-cherry-700">屬性轉換值</p>
                                <p className="text-lg md:text-xl font-bold text-cherry-800">{result.attributeConversion}</p>
                            </div>
                            <div className="bg-cherry-500 p-3 rounded-lg">
                                <p className="text-xs text-white">總治療強度</p>
                                <p className="text-lg md:text-xl font-bold text-white">{result.healingPower}</p>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const DamageCalculator = () => {
            // 初始輸入狀態
            const [inputs, setInputs] = useState({
                skill_multiplier: "1518",
                D: "5000",
                E: "800",
                b_c: "900",
                d_c: "1.8",
                R: "500",
                h: "700",
                b_d: "2000",
                b_s: "700",
                b_e: "0",
                flow_percent: "0",
                damage_increase: "0",
                skill_damage_increase: "0",
                d_s: "2000",
                d_f: "2000",
                d_d: "5000",
                d_e: "0",
                b_b: "600",
                hp: "80000",
                b_c_defense: "550",
                d_c_defense: "0",
                flow_resist_percent: "0",
                damage_reduction: "0",
                skill_damage_reduction: "0",
                lambda_1: "358",
                lambda_2: "0.359",
                lambda_3: "2860",
                lambda_4: "531",
                W: "1",
                gold_i: "0",
            });

            const [inputErrors, setInputErrors] = useState({});
            const [visibility, setVisibility] = useState({
                d_s: true,
                d_f: true,
                d_d: true,
                d_e: true,
                b_b: true,
                b_c_defense: true,
            });
            const [showAttacker, setShowAttacker] = useState(true);
            const [showDefender, setShowDefender] = useState(true);
            const [showOriginal, setShowOriginal] = useState(true);
            const [showReduced, setShowReduced] = useState(true);
            const [showDamageResult, setShowDamageResult] = useState(true);
            const [showInvestmentAnalysis, setShowInvestmentAnalysis] = useState(true);
            const [showIncrementalAnalysis, setShowIncrementalAnalysis] = useState(true);
            const [isTableExpanded, setIsTableExpanded] = useState(true);
            const [analysisData, setAnalysisData] = useState([]);
            const [recommendationData, setRecommendationData] = useState([]);
            const [selectedCurves, setSelectedCurves] = useState({});
            const [analysisMode, setAnalysisMode] = useState("incremental");
            const [investmentPoints, setInvestmentPoints] = useState({
                d_s: 200,
                d_f: 200,
                d_d: 200,
                d_e: 200,
                b_b: 200,
                b_c_defense: 200,
                d_c_defense: 200,
            });

            // 使用 useState 替代 localStorage
            const [presets, setPresets] = useState(() => {
                const savedPresets = localStorage.getItem("damageCalculatorPresets");
                return savedPresets ? JSON.parse(savedPresets) : [];
            });
            // 當 presets 變化時，同步保存到 localStorage
            useEffect(() => {
                localStorage.setItem("damageCalculatorPresets", JSON.stringify(presets));
            }, [presets]);

            const [compareIndexes, setCompareIndexes] = useState({ a: null, b: null });
            const [compareResult, setCompareResult] = useState(null);

            const goldOptions = [
                { value: "0", label: "無金周天" },
                { value: "0.03", label: "金周天1級" },
                { value: "0.04", label: "金周天2級" },
                { value: "0.05", label: "金周天3級" },
            ];

            const elementWeaknessOptions = [
                { value: "1", label: "無元素弱點" },
                { value: "1.1", label: "碎夢大特" },
            ];

            // 全零防禦基準
            const zeroDefense = {
                d_s: 0,
                d_f: 0,
                d_d: 0,
                d_e: 0,
                b_b: 0,
                hp: 0,
                b_c_defense: 0,
                d_c_defense: 0,
                flow_resist_percent: 0,
                damage_reduction: 0,
                skill_damage_reduction: 0,
            };

            // 工具函數：將值轉為數字，若無效則返回 0
            const safeNum = (val) => {
                const num = parseFloat(val);
                return isNaN(num) || !isFinite(num) ? 0 : num;
            };

            // 計算傷害函數
            const calculateDamage = (
                D,
                R,
                b_s,
                d_s,
                d_f,
                b_d,
                d_d,
                E,
                b_e,
                d_e,
                b_c,
                d_c,
                h,
                b_b,
                b_c_defense,
                d_c_defense,
                flow_percent,
                damage_increase,
                flow_resist_percent,
                damage_reduction,
                skill_damage_increase,
                skill_damage_reduction,
                lambda_1,
                lambda_2,
                lambda_3,
                lambda_4,
                W,
                gold_i,
                skill_multiplier
            ) => {
                const c = safeNum(b_c) - safeNum(b_c_defense);
                const p_c = Math.min(1, Math.max(0, (115 * c + 90) / (c + 940) / 100 + safeNum(gold_i)));
                const r_h = (143 * safeNum(h)) / (safeNum(h) + 714);
                const r_b = (143 * safeNum(b_b)) / (safeNum(b_b) + 714);
                const p_h_percent = 95 + (r_h - r_b);
                const p_h = Math.min(1, Math.max(0.25, p_h_percent / 100));
                const m_c = 1 + p_c * (safeNum(d_c) - 1 - safeNum(d_c_defense));
                const d_mul = m_c * p_h + 0.5 * (1 - p_h);
                const G = safeNum(b_s) >= safeNum(d_s)
                    ? 0
                    : safeNum(d_s) / 3 <= safeNum(b_s)
                        ? 0.5 * (safeNum(d_s) - safeNum(b_s))
                        : safeNum(d_s) - 2 * safeNum(b_s);
                const A = safeNum(D) + (safeNum(R) - safeNum(d_f)) - G;
                const gamma = safeNum(d_d) - safeNum(b_d) > 0
                    ? (safeNum(d_d) - safeNum(b_d)) / (safeNum(d_d) - safeNum(b_d) + safeNum(lambda_3))
                    : 0;
                const e = safeNum(d_e) - safeNum(b_e);
                const beta = e > 0 ? e / (e + safeNum(lambda_4)) : 0;

                const skillDamageIncrease = safeNum(skill_damage_increase) / 100;
                const skillDamageReduction = safeNum(skill_damage_reduction) / 100;

                const damage =
                    (safeNum(skill_multiplier) / 100) *
                    ((safeNum(lambda_1) + safeNum(lambda_2) * A) * (1 - gamma) +
                        safeNum(W) * safeNum(lambda_2) * safeNum(E) * (1 - beta)) *
                    d_mul *
                    (1 + safeNum(flow_percent) - safeNum(flow_resist_percent)) *
                    (1 + safeNum(damage_increase) - safeNum(damage_reduction)) *
                    (1 + skillDamageIncrease - skillDamageReduction);

                return isNaN(damage) || !isFinite(damage) ? 0 : Math.max(0, damage);
            };

            // 傷害計算函數
            const calculate = (inputs) => {
                const {
                    skill_multiplier,
                    D,
                    E,
                    b_c,
                    d_c,
                    R,
                    h,
                    b_d,
                    b_s,
                    b_e,
                    flow_percent,
                    damage_increase,
                    skill_damage_increase,
                    d_s,
                    d_f,
                    d_d,
                    d_e,
                    b_b,
                    hp,
                    b_c_defense,
                    d_c_defense,
                    flow_resist_percent,
                    damage_reduction,
                    skill_damage_reduction,
                    lambda_1,
                    lambda_2,
                    lambda_3,
                    lambda_4,
                    W,
                    gold_i,
                } = inputs;

                const c = safeNum(b_c) - safeNum(b_c_defense);
                const p_c = Math.min(
                    1,
                    Math.max(0, (115 * c + 90) / (c + 940) / 100 + safeNum(gold_i))
                );
                const r_h = (143 * safeNum(h)) / (safeNum(h) + 714);
                const r_b = (143 * safeNum(b_b)) / (safeNum(b_b) + 714);
                const p_h_percent = 95 + (r_h - r_b);
                const p_h = Math.min(1, Math.max(0.25, p_h_percent / 100));
                const p_h_1 = 1 - p_h;
                const m_c = 1 + p_c * (safeNum(d_c) - 1 - safeNum(d_c_defense));
                const d_mul = m_c * p_h + 0.5 * (1 - p_h);
                const G = safeNum(b_s) >= safeNum(d_s)
                    ? 0
                    : safeNum(d_s) / 3 <= safeNum(b_s)
                        ? 0.5 * (safeNum(d_s) - safeNum(b_s))
                        : safeNum(d_s) - 2 * safeNum(b_s);
                const A = safeNum(D) + (safeNum(R) - safeNum(d_f)) - G;
                const gamma =
                    safeNum(d_d) - safeNum(b_d) > 0
                        ? (safeNum(d_d) - safeNum(b_d)) /
                        (safeNum(d_d) - safeNum(b_d) + safeNum(lambda_3))
                        : 0;
                const e = safeNum(d_e) - safeNum(b_e);
                const beta = e > 0 ? e / (e + safeNum(lambda_4)) : 0;
                const c_original = safeNum(b_c);
                const p_c_original = Math.min(
                    1,
                    Math.max(0, (115 * c_original + 90) / (c_original + 940) / 100 + safeNum(gold_i))
                );
                const r_h_original = (143 * safeNum(h)) / (safeNum(h) + 714);
                const r_b_original = 0;
                const p_h_original_percent = 95 + (r_h_original - r_b_original);
                const p_h_original = Math.min(1, Math.max(0.25, p_h_original_percent / 100));
                const m_c_original = 1 + p_c_original * (safeNum(d_c) - 1);
                const d_mul_original = m_c_original * p_h_original + 0.5 * (1 - p_h_original);
                const G_original = safeNum(b_s) >= safeNum(d_s)
                    ? 0
                    : safeNum(d_s) / 3 <= safeNum(b_s)
                        ? 0.5 * (safeNum(d_s) - safeNum(b_s))
                        : safeNum(d_s) - 2 * safeNum(b_s);
                const A_original = Math.max(0, safeNum(D) + safeNum(R) - G_original);
                const gamma_original = 0;
                const beta_original = 0;

                const baseDamage =
                    (safeNum(skill_multiplier) / 100) *
                    ((safeNum(lambda_1) + safeNum(lambda_2) * A_original) * (1 - gamma_original) +
                        safeNum(W) * safeNum(lambda_2) * safeNum(E) * (1 - beta_original)) *
                    d_mul_original *
                    (1 + safeNum(flow_percent)) *
                    (1 + safeNum(damage_increase)) *
                    (1 + safeNum(skill_damage_increase) / 100);

                const finalDamage =
                    (safeNum(skill_multiplier) / 100) *
                    ((safeNum(lambda_1) + safeNum(lambda_2) * A) * (1 - gamma) +
                        safeNum(W) * safeNum(lambda_2) * safeNum(E) * (1 - beta)) *
                    d_mul *
                    (1 + safeNum(flow_percent) - safeNum(flow_resist_percent)) *
                    (1 + safeNum(damage_increase) - safeNum(damage_reduction)) *
                    (1 + safeNum(skill_damage_increase) / 100 - safeNum(skill_damage_reduction) / 100);

                const totalReduction = baseDamage && isFinite(baseDamage) && baseDamage > 0
                    ? Math.max(0, 1 - finalDamage / baseDamage)
                    : 0;
                const ehp = safeNum(hp) / (1 - totalReduction) || safeNum(hp);

                return {
                    c: c.toFixed(2),
                    p_c: (p_c * 100).toFixed(2) + "%",
                    r_h: (r_h * 100).toFixed(2) + "%",
                    r_b: (r_b * 100).toFixed(2) + "%",
                    p_h: p_h.toFixed(4),
                    m_c: m_c.toFixed(4),
                    d_mul: d_mul.toFixed(4),
                    G: G.toFixed(2),
                    A: A.toFixed(2),
                    gamma: (gamma * 100).toFixed(2) + "%",
                    beta: (beta * 100).toFixed(2) + "%",
                    c_original: c_original.toFixed(2),
                    p_c_original: (p_c_original * 100).toFixed(2) + "%",
                    r_h_original: (r_h_original * 100).toFixed(2) + "%",
                    r_b_original: (r_b_original * 100).toFixed(2) + "%",
                    p_h_original: p_h_original.toFixed(4),
                    m_c_original: m_c_original.toFixed(4),
                    d_mul_original: d_mul_original.toFixed(4),
                    G_original: G_original.toFixed(2),
                    A_original: A_original.toFixed(2),
                    gamma_original: (gamma_original * 100).toFixed(2) + "%",
                    beta_original: (beta_original * 100).toFixed(2) + "%",
                    baseDamage: isNaN(baseDamage) || !isFinite(baseDamage) ? "0.00" : baseDamage.toFixed(2),
                    finalDamage: isNaN(finalDamage) || !isFinite(finalDamage) ? "0.00" : finalDamage.toFixed(2),
                    totalReduction: (totalReduction * 100).toFixed(2) + "%",
                    ehp: isNaN(ehp) || !isFinite(ehp) ? "0.00" : ehp.toFixed(2),
                    p_h_1: (p_h_1 * 100).toFixed(2) + "%",
                };
            };

            // 計算單個屬性投資的減傷效果
            const calculateInvestmentReduction = (attr, points) => {
                const params = {
                    d_s: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_s),
                    d_d: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_d),
                    d_f: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_f),
                    d_e: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_e),
                    b_b: analysisMode === "from_zero" ? 0 : safeNum(inputs.b_b),
                    b_c_defense: analysisMode === "from_zero" ? 0 : safeNum(inputs.b_c_defense),
                    d_c_defense: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_c_defense),
                };
                const increment = attr === "d_c_defense" ? Math.min(2.0, Math.max(0.01, points / 200 * 0.01)) : points;
                params[attr] = (analysisMode === "from_zero" ? 0 : safeNum(inputs[attr])) + increment;
                const d_reduced = calculateDamage(
                    safeNum(inputs.D),
                    safeNum(inputs.R),
                    safeNum(inputs.b_s),
                    params.d_s,
                    params.d_f,
                    safeNum(inputs.b_d),
                    params.d_d,
                    safeNum(inputs.E),
                    safeNum(inputs.b_e),
                    params.d_e,
                    safeNum(inputs.b_c),
                    safeNum(inputs.d_c),
                    safeNum(inputs.h),
                    params.b_b,
                    params.b_c_defense,
                    params.d_c_defense,
                    safeNum(inputs.flow_percent),
                    safeNum(inputs.damage_increase),
                    safeNum(inputs.flow_resist_percent),
                    safeNum(inputs.damage_reduction),
                    safeNum(inputs.skill_damage_increase),
                    safeNum(inputs.skill_damage_reduction),
                    safeNum(inputs.lambda_1),
                    safeNum(inputs.lambda_2),
                    safeNum(inputs.lambda_3),
                    safeNum(inputs.lambda_4),
                    safeNum(inputs.W),
                    safeNum(inputs.gold_i),
                    safeNum(inputs.skill_multiplier)
                );
                const baseDamage = parseFloat(calculate(inputs).finalDamage) || 0;
                const reduction = baseDamage && isFinite(baseDamage) && baseDamage > 0 && d_reduced >= 0
                    ? Math.max(0, (baseDamage - d_reduced) / baseDamage * 100)
                    : 0;
                return isNaN(reduction) || !isFinite(reduction) ? 0 : reduction;
            };

            // 生成每200點屬性減傷收益數據
            const generateChartData = (inputs) => {
                const attribute_points = Array.from({ length: 51 }, (_, i) => i * 200);
                const reductions = {
                    d_s: [], d_d: [], d_f: [], d_e: [], b_b: [], b_c_defense: [],
                };
                const delta_reductions = {
                    d_s: [], d_d: [], d_f: [], d_e: [], b_b: [], b_c_defense: [],
                };

                const baseParams = {
                    d_s: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_s),
                    d_d: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_d),
                    d_f: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_f),
                    d_e: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_e),
                    b_b: analysisMode === "from_zero" ? 0 : safeNum(inputs.b_b),
                    b_c_defense: analysisMode === "from_zero" ? 0 : safeNum(inputs.b_c_defense),
                    d_c_defense: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_c_defense),
                };

                const d_original = calculateDamage(
                    safeNum(inputs.D),
                    safeNum(inputs.R),
                    safeNum(inputs.b_s),
                    baseParams.d_s,
                    baseParams.d_f,
                    safeNum(inputs.b_d),
                    baseParams.d_d,
                    safeNum(inputs.E),
                    safeNum(inputs.b_e),
                    baseParams.d_e,
                    safeNum(inputs.b_c),
                    safeNum(inputs.d_c),
                    safeNum(inputs.h),
                    baseParams.b_b,
                    baseParams.b_c_defense,
                    baseParams.d_c_defense,
                    safeNum(inputs.flow_percent),
                    safeNum(inputs.damage_increase),
                    safeNum(inputs.flow_resist_percent),
                    safeNum(inputs.damage_reduction),
                    safeNum(inputs.skill_damage_increase),
                    safeNum(inputs.skill_damage_reduction),
                    safeNum(inputs.lambda_1),
                    safeNum(inputs.lambda_2),
                    safeNum(inputs.lambda_3),
                    safeNum(inputs.lambda_4),
                    safeNum(inputs.W),
                    safeNum(inputs.gold_i),
                    safeNum(inputs.skill_multiplier)
                );

                const calculateReduction = (attr, value) => {
                    const params = { ...baseParams };
                    const increment = attr === "d_c_defense" ? Math.min(2.0, Math.max(0.01, value / 200 * 0.01)) : value;
                    params[attr] = (analysisMode === "from_zero" ? 0 : safeNum(inputs[attr])) + increment;
                    const d_reduced = calculateDamage(
                        safeNum(inputs.D),
                        safeNum(inputs.R),
                        safeNum(inputs.b_s),
                        params.d_s,
                        params.d_f,
                        safeNum(inputs.b_d),
                        params.d_d,
                        safeNum(inputs.E),
                        safeNum(inputs.b_e),
                        params.d_e,
                        safeNum(inputs.b_c),
                        safeNum(inputs.d_c),
                        safeNum(inputs.h),
                        params.b_b,
                        params.b_c_defense,
                        params.d_c_defense,
                        safeNum(inputs.flow_percent),
                        safeNum(inputs.damage_increase),
                        safeNum(inputs.flow_resist_percent),
                        safeNum(inputs.damage_reduction),
                        safeNum(inputs.skill_damage_increase),
                        safeNum(inputs.skill_damage_reduction),
                        safeNum(inputs.lambda_1),
                        safeNum(inputs.lambda_2),
                        safeNum(inputs.lambda_3),
                        safeNum(inputs.lambda_4),
                        safeNum(inputs.W),
                        safeNum(inputs.gold_i),
                        safeNum(inputs.skill_multiplier)
                    );
                    const reduction = d_original && isFinite(d_original) && d_original > 0 && d_reduced >= 0
                        ? Math.max(0, (1 - d_reduced / d_original) * 100)
                        : 0;
                    return isNaN(reduction) || !isFinite(reduction) ? 0 : reduction;
                };

                attribute_points.forEach((point) => {
                    reductions.d_s.push(calculateReduction("d_s", point));
                    reductions.d_d.push(calculateReduction("d_d", point));
                    reductions.d_f.push(calculateReduction("d_f", point));
                    reductions.d_e.push(calculateReduction("d_e", point));
                    reductions.b_b.push(calculateReduction("b_b", point));
                    reductions.b_c_defense.push(calculateReduction("b_c_defense", point));
                });

                for (let i = 1; i < reductions.d_s.length; i++) {
                    delta_reductions.d_s.push(Math.max(0, reductions.d_s[i] - reductions.d_s[i - 1]));
                    delta_reductions.d_d.push(Math.max(0, reductions.d_d[i] - reductions.d_d[i - 1]));
                    delta_reductions.d_f.push(Math.max(0, reductions.d_f[i] - reductions.d_f[i - 1]));
                    delta_reductions.d_e.push(Math.max(0, reductions.d_e[i] - reductions.d_e[i - 1]));
                    delta_reductions.b_b.push(Math.max(0, reductions.b_b[i] - reductions.b_b[i - 1]));
                    delta_reductions.b_c_defense.push(Math.max(0, reductions.b_c_defense[i] - reductions.b_c_defense[i - 1]));
                }

                const deltaData = attribute_points.slice(1).map((point, i) => ({
                    point,
                    d_s: delta_reductions.d_s[i],
                    d_d: delta_reductions.d_d[i],
                    d_f: delta_reductions.d_f[i],
                    d_e: delta_reductions.d_e[i],
                    b_b: delta_reductions.b_b[i],
                    b_c_defense: delta_reductions.b_c_defense[i],
                }));

                const reductionData = attribute_points.map((point, i) => ({
                    point,
                    d_s: reductions.d_s[i],
                    d_d: reductions.d_d[i],
                    d_f: reductions.d_f[i],
                    d_e: reductions.d_e[i],
                    b_b: reductions.b_b[i],
                    b_c_defense: reductions.b_c_defense[i],
                }));

                return { deltaData, reductionData };
            };

            // 輸入處理
            const handleChange = (e) => {
                const { name, value } = e.target;
                if (name === "gold_i" || name === "W") {
                    setInputs((prev) => ({ ...prev, [name]: value }));
                    setInputErrors((prev) => ({ ...prev, [name]: "" }));
                } else {
                    if (value > 1000000) {
                        setInputErrors((prev) => ({
                            ...prev,
                            [name]: "輸入值過大，最大為1000000",
                        }));
                        return;
                    }
                    setInputs((prev) => ({ ...prev, [name]: value }));
                    setInputErrors((prev) => ({ ...prev, [name]: "" }));
                }
            };

            // 處理滑塊或文本框變化
            const handleInvestmentChange = (attr, value) => {
                setInvestmentPoints((prev) => ({
                    ...prev,
                    [attr]: Math.min(1000, Math.max(1, parseInt(value) || 1)),
                }));
                analyzeDefenseOptions();
            };

            // 切換曲線可見性
            const toggleVisibility = (key) => {
                setVisibility((prev) => ({ ...prev, [key]: !prev[key] }));
            };

            // 全選曲線
            const handleSelectAll = () => {
                const allSelected = {};
                recommendationData.forEach((attr) => {
                    if (attr.attribute !== "d_c_defense") {
                        allSelected[attr.attribute] = true;
                    }
                });
                setSelectedCurves(allSelected);
                setVisibility(allSelected);
            };

            // 全不選曲線
            const handleDeselectAll = () => {
                setSelectedCurves({});
                setVisibility({});
            };

            // 切換單條曲線
            const handleCurveToggle = (attribute) => {
                setSelectedCurves((prev) => ({
                    ...prev,
                    [attribute]: !prev[attribute],
                }));
                setVisibility((prev) => ({
                    ...prev,
                    [attribute]: !prev[attribute],
                }));
            };

            // 防禦選項分析
            const analyzeDefenseOptions = () => {
                const attackInputs = {
                    skill_multiplier: inputs.skill_multiplier,
                    D: inputs.D,
                    E: inputs.E,
                    b_c: inputs.b_c,
                    d_c: inputs.d_c,
                    R: inputs.R,
                    h: inputs.h,
                    b_d: inputs.b_d,
                    b_s: inputs.b_s,
                    b_e: inputs.b_e,
                    flow_percent: inputs.flow_percent,
                    damage_increase: inputs.damage_increase,
                    skill_damage_increase: inputs.skill_damage_increase,
                    W: inputs.W,
                    gold_i: inputs.gold_i,
                };
                const defenseInputs = {
                    d_s: inputs.d_s,
                    d_f: inputs.d_f,
                    d_d: inputs.d_d,
                    d_e: inputs.d_e,
                    b_b: inputs.b_b,
                    hp: inputs.hp,
                    b_c_defense: inputs.b_c_defense,
                    d_c_defense: inputs.d_c_defense,
                    flow_resist_percent: inputs.flow_resist_percent,
                    damage_reduction: inputs.damage_reduction,
                    skill_damage_reduction: inputs.skill_damage_reduction,
                };
                const constants = {
                    lambda_1: inputs.lambda_1,
                    lambda_2: inputs.lambda_2,
                    lambda_3: inputs.lambda_3,
                    lambda_4: inputs.lambda_4,
                };

                const baseDamage = parseFloat(calculate({ ...attackInputs, ...defenseInputs, ...constants }).finalDamage) || 0;
                if (!baseDamage || isNaN(baseDamage) || !isFinite(baseDamage) || baseDamage <= 0) {
                    console.error("Base damage is invalid:", baseDamage);
                    setRecommendationData([]);
                    setAnalysisData([]);
                    return;
                }

                const defenseAttributes = [
                    { key: "d_s", label: "氣盾", increment: 200, type: "shield" },
                    { key: "d_f", label: "流派抵禦", increment: 200, type: "flow" },
                    { key: "d_d", label: "防禦", increment: 200, type: "defense" },
                    { key: "d_e", label: "元素抗性", increment: 200, type: "element" },
                    { key: "b_b", label: "格擋", increment: 200, type: "block" },
                    { key: "b_c_defense", label: "抗會心數值", increment: 200, type: "crit_resist" },
                    { key: "d_c_defense", label: "會心防禦%", increment: 0.01, type: "crit_defense" },
                ];

                const benefits = [];
                const points = 200;

                defenseAttributes.forEach((attr) => {
                    const modifiedDefense = { ...defenseInputs };
                    const increment = attr.key === "d_c_defense" ? Math.min(2.0, Math.max(0.01, points / 200 * 0.01)) : points;
                    modifiedDefense[attr.key] = safeNum(defenseInputs[attr.key]) + increment;
                    const newDamage = parseFloat(calculate({ ...attackInputs, ...modifiedDefense, ...constants }).finalDamage) || 0;
                    const damageReduction = baseDamage && isFinite(baseDamage) && baseDamage > 0
                        ? Math.max(0, ((baseDamage - newDamage) / baseDamage) * 100)
                        : 0;
                    benefits.push({
                        attribute: attr.key,
                        label: attr.label,
                        type: attr.type,
                        damageReduction,
                        currentValue: defenseInputs[attr.key],
                        increment: increment,
                        efficiency: damageReduction / (points / 200) || 0,
                    });
                });

                const sortedBenefits = benefits.sort(
                    (a, b) => b.damageReduction - a.damageReduction
                );
                setRecommendationData(sortedBenefits);

                const initialSelected = {};
                sortedBenefits.forEach((attr, index) => {
                    if (attr.attribute !== "d_c_defense") {
                        initialSelected[attr.attribute] = index < 5;
                    }
                });
                if (Object.keys(selectedCurves).length === 0) {
                    setSelectedCurves(initialSelected);
                    setVisibility(initialSelected);
                }

                const chartData = [];
                const pointsRange = Array.from({ length: 26 }, (_, i) => i * 400);

                pointsRange.forEach((totalPoints) => {
                    const point = { points: totalPoints };
                    sortedBenefits.forEach((attr) => {
                        if (attr.attribute === "d_c_defense") return; // 跳過 d_c_defense
                        const modifiedDefense =
                            analysisMode === "from_zero" ? { ...zeroDefense } : { ...defenseInputs };
                        const increment =
                            attr.attribute === "d_c_defense"
                                ? Math.min(2.0, Math.max(0.01, totalPoints / 200 * 0.01))
                                : totalPoints;
                        const baseValue =
                            analysisMode === "from_zero"
                                ? 0
                                : safeNum(defenseInputs[attr.attribute]);
                        modifiedDefense[attr.attribute] = baseValue + increment;
                        const referenceDamage =
                            analysisMode === "from_zero"
                                ? parseFloat(calculate({ ...attackInputs, ...zeroDefense, ...constants }).finalDamage) || 0
                                : baseDamage;
                        const newDamage = parseFloat(calculate({ ...attackInputs, ...modifiedDefense, ...constants }).finalDamage) || 0;
                        const reduction = referenceDamage && isFinite(referenceDamage) && referenceDamage > 0
                            ? Math.max(0, ((referenceDamage - newDamage) / referenceDamage) * 100)
                            : 0;
                        point[attr.attribute] = reduction;
                    });
                    chartData.push(point);
                });

                setAnalysisData(chartData);
                console.log("Analysis Data:", chartData);
                console.log("Recommendation Data:", sortedBenefits);
            };

            // 當輸入或分析模式變化時更新分析
            useEffect(() => {
                analyzeDefenseOptions();
            }, [inputs, analysisMode]);

            const CustomTooltip = ({ active, payload, label, isDelta }) => {
                if (active && payload && payload.length) {
                    return (
                        <div className="bg-white p-3 border border-gray-200 rounded-lg shadow-sm">
                            <p className="text-sm text-gray-700 font-medium">屬性點: {label}</p>
                            {payload.map((entry, index) => (
                                <p key={index} className="text-sm text-gray-600">
                                    <span style={{ color: entry.stroke }}>{entry.name}</span>:{" "}
                                    {(entry.value * (isDelta ? 1 : 1)).toFixed(isDelta ? 4 : 2)}%
                                </p>
                            ))}
                        </div>
                    );
                }
                return null;
            };

            const result = calculate(inputs);
            const { deltaData, reductionData } = generateChartData(inputs);

            // 保存方案
            const saveCurrentPreset = () => {
                if (presets.length >= 4) return alert("最多只能保存 4 組方案！");
                const name = prompt("請輸入方案名稱：");
                if (!name) return;
                const newPresets = [...presets, { name, data: inputs }];
                setPresets(newPresets);
            };

            // 載入方案
            const loadPreset = (i) => {
                setInputs(presets[i].data);
                analyzeDefenseOptions();
            };

            // 刪除方案
            const deletePreset = (i) => {
                const updated = presets.filter((_, idx) => idx !== i);
                setPresets(updated);
            };

            // 對比方案
            const comparePresets = () => {
                const a = presets[compareIndexes.a]?.data;
                const b = presets[compareIndexes.b]?.data;
                if (!a || !b) return;

                const diff = {};
                Object.keys(a).forEach((key) => {
                    diff[key] = safeNum(b[key]) - safeNum(a[key]);
                });

                const resultA = calculate(a);
                const resultB = calculate(b);

                setCompareResult({
                    diff,
                    resultDiff: {
                        baseDamage: safeNum(resultB.baseDamage) - safeNum(resultA.baseDamage),
                        finalDamage: safeNum(resultB.finalDamage) - safeNum(resultA.finalDamage),
                        totalReduction: safeNum(resultB.totalReduction) - safeNum(resultA.totalReduction),
                    },
                });
            };

            const colors = [
                "#3b82f6",
                "#10b981",
                "#8b5cf6",
                "#14b8a6",
                "#f97316",
                "#d084d0",
            ];

            return (
                <div className="p-4 container mx-auto min-h-screen bg-gray-50">
                    {/* 標題 */}
                    <div className="bg-gradient-to-r from-pink-500 to-red-500 rounded-xl p-6 mb-6 shadow-lg">
                        <h1 className="text-xl md:text-2xl font-bold text-center text-white">
                            防守屬性收益計算器
                        </h1>
                        <p className="text-center text-white text-opacity-90 text-sm mt-1">
                            如有問題請聯繫櫻桃白蘭地@緣定今生
                        </p>
                    </div>

                    {/* 攻擊方參數 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-4">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowAttacker(!showAttacker)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    攻擊方參數
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showAttacker ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showAttacker ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                {[
                                    {
                                        key: "skill_multiplier",
                                        label: "技能倍率",
                                        icon: "🔥",
                                        tooltip: "如技能倍率為300%，輸入300",
                                    },
                                    { key: "D", label: "攻擊", icon: "⚔️" },
                                    { key: "E", label: "元素攻擊（平均）", icon: "✨" },
                                    { key: "b_c", label: "會心數值", icon: "🎯" },
                                    {
                                        key: "d_c",
                                        label: "會心傷害",
                                        icon: "💥",
                                        tooltip: "除以100，例如180%，輸入1.8",
                                    },
                                    { key: "R", label: "流派克制", icon: "🔄" },
                                    { key: "h", label: "命中", icon: "🎯" },
                                    { key: "b_d", label: "破防", icon: "🛡️" },
                                    { key: "b_s", label: "破盾", icon: "🔨" },
                                    { key: "b_e", label: "忽視元素抗性", icon: "🌀" },
                                    {
                                        key: "flow_percent",
                                        label: "流派克制%",
                                        icon: "📊",
                                        tooltip:
                                            "例如9.5%，輸入0.095。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "damage_increase",
                                        label: "增傷%",
                                        icon: "📈",
                                        tooltip:
                                            "除以100，例如5%，輸入0.05。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "skill_damage_increase",
                                        label: "技能增傷%",
                                        icon: "📈",
                                        tooltip:
                                            "除以100，例如5%，輸入0.05。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "gold_i",
                                        label: "金周天",
                                        icon: "🌟",
                                        type: "select",
                                        options: goldOptions,
                                    },
                                    {
                                        key: "W",
                                        label: "元素弱點",
                                        icon: "💢",
                                        type: "select",
                                        options: elementWeaknessOptions,
                                    },
                                ].map(({ key, label, icon, type, options, tooltip }) => (
                                    <div key={key} className="flex flex-col group relative">
                                        <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                            <span className="mr-1 md:mr-2">{icon}</span>
                                            {label}
                                            {tooltip && (
                                                <>
                                                    <span className="ml-1 flex items-center justify-center w-4 h-4 rounded-full bg-gray-400 text-white text-xs cursor-help">
                                                        ?
                                                    </span>
                                                    <div className="absolute left-0 top-8 bg-gray-800 text-white text-xs p-2 rounded-lg shadow-md z-10 max-w-xs opacity-0 group-hover:opacity-100 transition-opacity">
                                                        {tooltip}
                                                    </div>
                                                </>
                                            )}
                                        </label>
                                        {type === "select" ? (
                                            <select
                                                name={key}
                                                value={inputs[key]}
                                                onChange={handleChange}
                                                className="border border-gray-200 rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors"
                                                aria-label={label}
                                            >
                                                {options.map((opt) => (
                                                    <option key={opt.value} value={opt.value}>
                                                        {opt.label}
                                                    </option>
                                                ))}
                                            </select>
                                        ) : (
                                            <input
                                                type="number"
                                                name={key}
                                                value={inputs[key]}
                                                onChange={handleChange}
                                                className={`border ${inputErrors[key] ? "border-red-500" : "border-gray-200"} rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors`}
                                                aria-label={label}
                                            />
                                        )}
                                        {inputErrors[key] && (
                                            <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                                        )}
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* 防守方參數 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-4">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowDefender(!showDefender)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    防守方參數
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showDefender ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showDefender ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                {[
                                    { key: "d_s", label: "氣盾", icon: "🛡️" },
                                    { key: "d_f", label: "流派抵禦", icon: "🔄" },
                                    { key: "d_d", label: "防禦", icon: "🏰" },
                                    { key: "d_e", label: "元素抗性", icon: "🌀" },
                                    { key: "b_b", label: "格擋", icon: "✋" },
                                    { key: "hp", label: "氣血", icon: "❤️" },
                                    { key: "b_c_defense", label: "抗會心數值", icon: "🎯" },
                                    {
                                        key: "d_c_defense",
                                        label: "會心防禦%",
                                        icon: "📊",
                                        tooltip:
                                            "除以100，例如25%，輸入0.25。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "flow_resist_percent",
                                        label: "流派抵禦%",
                                        icon: "📊",
                                        tooltip:
                                            "除以100，例如5%，輸入0.05。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "damage_reduction",
                                        label: "傷害減免%",
                                        icon: "📉",
                                        tooltip:
                                            "除以100，例如15%，輸入0.15。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "skill_damage_reduction",
                                        label: "技能減免%",
                                        icon: "📉",
                                        tooltip:
                                            "除以100，例如5%，輸入0.05。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                ].map(({ key, label, icon, tooltip }) => (
                                    <div key={key} className="flex flex-col group relative">
                                        <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                            <span className="mr-1 md:mr-2">{icon}</span>
                                            {label}
                                            {tooltip && (
                                                <>
                                                    <span className="ml-1 flex items-center justify-center w-4 h-4 rounded-full bg-gray-400 text-white text-xs cursor-help">
                                                        ?
                                                    </span>
                                                    <div className="absolute left-0 top-8 bg-gray-800 text-white text-xs p-2 rounded-lg shadow-md z-10 max-w-xs opacity-0 group-hover:opacity-100 transition-opacity">
                                                        {tooltip}
                                                    </div>
                                                </>
                                            )}
                                        </label>
                                        <input
                                            type="number"
                                            name={key}
                                            value={inputs[key]}
                                            onChange={handleChange}
                                            className={`border ${inputErrors[key] ? "border-red-500" : "border-gray-200"} rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors`}
                                            aria-label={label}
                                        />
                                        {inputErrors[key] && (
                                            <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                                        )}
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* 原數值屬性和減傷後屬性 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowOriginal(!showOriginal)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    原數值屬性
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showOriginal ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showOriginal ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="grid grid-cols-2 gap-3 mb-4">
                                {[
                                    { label: "真實會心", value: result.c_original },
                                    { label: "會心率", value: result.p_c_original },
                                    { label: "格擋率", value: result.r_b_original },
                                    { label: "會心傷害倍率", value: result.m_c_original },
                                    { label: "傷害倍率", value: result.d_mul_original },
                                    { label: "剩餘氣盾", value: result.G_original },
                                    { label: "防禦傷害減免", value: result.gamma_original },
                                    { label: "元素傷害減免", value: result.beta_original },
                                ].map(({ label, value }) => (
                                    <div key={label} className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                        <p className="text-xs text-gray-600">{label}</p>
                                        <p className="text-sm font-bold text-gray-800">{value}</p>
                                    </div>
                                ))}
                            </div>
                        </div>

                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowReduced(!showReduced)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    減傷後屬性
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showReduced ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showReduced ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="grid grid-cols-2 gap-3">
                                {[
                                    { label: "修正會心", value: result.c },
                                    { label: "會心率", value: result.p_c },
                                    { label: "格擋率", value: result.p_h_1 },
                                    { label: "會心傷害倍率", value: result.m_c },
                                    { label: "傷害倍率", value: result.d_mul },
                                    { label: "剩餘氣盾", value: result.G },
                                    { label: "防禦傷害減免", value: result.gamma },
                                    { label: "元素傷害減免", value: result.beta },
                                ].map(({ label, value }) => (
                                    <div key={label} className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                        <p className="text-xs text-pink-600">{label}</p>
                                        <p className="text-sm font-bold text-pink-800">{value}</p>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* 傷害計算結果 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowDamageResult(!showDamageResult)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    傷害計算結果
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showDamageResult ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showDamageResult ? "max-h-[3000px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="flex justify-end items-center mb-4">
                                <button
                                    className="bg-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-pink-700 transition-colors"
                                    onClick={saveCurrentPreset}
                                >
                                    保存當前方案
                                </button>
                            </div>
                            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-3 mt-6">
                                {[
                                    { label: "原傷害", value: result.baseDamage, color: "pink-100" },
                                    {
                                        label: "減傷後傷害",
                                        value: result.finalDamage,
                                        color: "pink-100",
                                    },
                                    { label: "有效氣血 (EHP)", value: result.ehp, color: "pink-100" },
                                    {
                                        label: "總減傷率",
                                        value: result.totalReduction,
                                        color: "pink-500",
                                        text: "white",
                                    },
                                ].map(({ label, value, color, text }) => (
                                    <div key={label} className={`bg-${color} p-3 rounded-lg`}>
                                        <p
                                            className={`text-xs ${text ? `text-${text}` : "text-pink-700"}`}
                                        >
                                            {label}
                                        </p>
                                        <p
                                            className={`text-lg font-bold ${text ? `text-${text}` : "text-pink-800"}`}
                                        >
                                            {value}
                                        </p>
                                    </div>
                                ))}
                            </div>
                            <div className="mt-6">
                                <div className="flex justify-between items-center mb-2">
                                    <div className="flex items-center">
                                        <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                        <h4 className="font-bold text-base text-gray-800">
                                            防禦投資優先級 （！下方先選增量模式！）
                                        </h4>
                                    </div>
                                </div>
                                <div>
                                    <p className="text-sm text-gray-600 mb-4">
                                        針對當前攻擊配置，通過拖動拉桿或輸入數值調整投資點數（1-1000），實時查看從現有面板基礎上的減傷效果
                                    </p>
                                    {recommendationData.length > 0 ? (
                                        <div className="space-y-4">
                                            {[
                                                { key: "d_s", label: "氣盾" },
                                                { key: "d_f", label: "流派抵禦" },
                                                { key: "d_d", label: "防禦" },
                                                { key: "d_e", label: "元素抗性" },
                                                { key: "b_b", label: "格擋" },
                                                { key: "b_c_defense", label: "抗會心數值" },
                                                { key: "d_c_defense", label: "會心防禦%" },
                                            ].map(({ key, label }) => {
                                                const reduction = calculateInvestmentReduction(key, investmentPoints[key]);
                                                const maxReduction = Math.max(
                                                    ...Object.keys(investmentPoints).map((attr) =>
                                                        calculateInvestmentReduction(attr, investmentPoints[attr])
                                                    ),
                                                    0.0001
                                                );
                                                const barWidth = `${(reduction / maxReduction) * 100}%`;
                                                return (
                                                    <div key={key} className="flex items-center gap-4">
                                                        <span className="w-24 text-sm font-semibold text-gray-700">{label}</span>
                                                        <input
                                                            type="range"
                                                            min="1"
                                                            max="1000"
                                                            value={investmentPoints[key]}
                                                            onChange={(e) => handleInvestmentChange(key, e.target.value)}
                                                            className="w-1/3 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                        />
                                                        <input
                                                            type="number"
                                                            min="1"
                                                            max="1000"
                                                            value={investmentPoints[key]}
                                                            onChange={(e) => {
                                                                const value = Math.min(1000, Math.max(1, parseInt(e.target.value) || 1));
                                                                handleInvestmentChange(key, value);
                                                            }}
                                                            className="w-20 p-2 border border-gray-200 rounded-lg text-sm focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors"
                                                        />
                                                        <div className="w-1/3 bg-gray-200 rounded-full h-2.5">
                                                            <div
                                                                className="bg-pink-500 h-2.5 rounded-full"
                                                                style={{ width: barWidth }}
                                                            ></div>
                                                        </div>
                                                        <span className="text-sm text-gray-700">
                                                            {reduction.toFixed(2)}% 減傷
                                                        </span>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    ) : (
                                        <p className="text-sm text-red-600">
                                            無法生成投資優先級數據，請檢查輸入值。
                                        </p>
                                    )}
                                </div>
                            </div>

                            {/* 針對性配裝建議 */}
                            <div className="mt-6 bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4 text-gray-700 flex items-center">
                                    <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                    針對性配裝建議
                                </h2>
                                <div className="space-y-3">
                                    {recommendationData.length > 0 ? (
                                        <>
                                            <div className="flex items-center justify-between p-4 bg-green-50 rounded-lg border-l-4 border-green-500">
                                                <div>
                                                    <span className="font-semibold text-green-800">
                                                        最優投資: {recommendationData[0]?.label}
                                                    </span>
                                                    <p className="text-sm text-green-600 mt-1">
                                                        投資200點數可減傷{" "}
                                                        {recommendationData[0]?.damageReduction.toFixed(3)}%
                                                    </p>
                                                </div>
                                            </div>
                                            {recommendationData.length > 1 && (
                                                <div className="flex items-center justify-between p-4 bg-yellow-50 rounded-lg border-l-4 border-yellow-500">
                                                    <div>
                                                        <span className="font-semibold text-yellow-800">
                                                            次優選擇: {recommendationData[1]?.label}
                                                        </span>
                                                        <p className="text-sm text-yellow-600 mt-1">
                                                            投資200點數可減傷{" "}
                                                            {recommendationData[1]?.damageReduction.toFixed(3)}%
                                                        </p>
                                                    </div>
                                                </div>
                                            )}
                                            <div className="p-4 bg-blue-50 rounded-lg border-l-4 border-blue-500">
                                                <span className="font-semibold text-blue-800">
                                                    配裝策略建議:
                                                </span>
                                                <p className="text-sm text-blue-600 mt-1">
                                                    面對「敵方當前攻擊配置」時，優先堆疊 {recommendationData[0]?.label}{" "}
                                                    {recommendationData[1] ? `和 ${recommendationData[1]?.label}` : ""}，
                                                    可以獲得最佳的防禦效果。

                                                    <>
                                                        <br />
                                                        請注意，各裝備投放屬性數值不一致，推薦只限200點内收益，使用「從零分析」模式可以看到新角色從頭開始配裝的最優方向。
                                                    </>

                                                </p>
                                            </div>
                                        </>
                                    ) : (
                                        <p className="text-sm text-gray-500">正在生成建議，請稍候...</p>
                                    )}
                                </div>
                            </div>

                            {/* 方案列表 */}
                            <div className="mt-6">
                                <h4 className="font-semibold text-base text-gray-800 mb-3 flex items-center">
                                    <span className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></span>
                                    保存的方案
                                </h4>
                                {presets.length === 0 ? (
                                    <p className="text-sm text-gray-500">尚未保存任何方案</p>
                                ) : (
                                    <div className="grid gap-2">
                                        {presets.map((preset, index) => (
                                            <div
                                                key={index}
                                                className="flex items-center justify-between p-3 bg-pink-50 rounded-lg hover:bg-pink-100 transition-colors duration-200"
                                            >
                                                <span className="font-medium text-gray-700">{preset.name}</span>
                                                <div className="flex gap-2">
                                                    <button
                                                        className="text-sm text-green-600 hover:text-green-800 font-medium transition-colors duration-200 flex items-center gap-1"
                                                        onClick={() => loadPreset(index)}
                                                    >
                                                        載入
                                                    </button>
                                                    <button
                                                        className="text-sm text-red-600 hover:text-red-800 font-medium transition-colors duration-200 flex items-center gap-1"
                                                        onClick={() => deletePreset(index)}
                                                    >
                                                        刪除
                                                    </button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>

                            {/* 方案對比 */}
                            {presets.length >= 2 && (
                                <div className="mt-6">
                                    <h4 className="font-semibold text-base text-gray-800 mb-3 flex items-center">
                                        <span className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></span>
                                        對比兩個方案
                                    </h4>
                                    <div className="flex flex-col sm:flex-row gap-3 items-start sm:items-center">
                                        <select
                                            className="w-full sm:w-40 border border-gray-300 rounded-lg p-2 text-sm text-gray-700 focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors duration-200"
                                            onChange={(e) =>
                                                setCompareIndexes((prev) => ({ ...prev, a: e.target.value }))
                                            }
                                        >
                                            <option value="">選擇方案</option>
                                            {presets.map((p, i) => (
                                                <option value={i} key={"a" + i}>
                                                    {p.name}
                                                </option>
                                            ))}
                                        </select>
                                        <select
                                            className="w-full sm:w-40 border border-gray-300 rounded-lg p-2 text-sm text-gray-700 focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors duration-200"
                                            onChange={(e) =>
                                                setCompareIndexes((prev) => ({ ...prev, b: e.target.value }))
                                            }
                                        >
                                            <option value="">選擇方案</option>
                                            {presets.map((p, i) => (
                                                <option value={i} key={"b" + i}>
                                                    {p.name}
                                                </option>
                                            ))}
                                        </select>
                                        <button
                                            className="w-full sm:w-auto bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-lg font-medium text-sm transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                                            onClick={comparePresets}
                                            disabled={compareIndexes.a === null || compareIndexes.b === null}
                                        >
                                            開始對比
                                        </button>
                                    </div>
                                    {compareResult && (
                                        <div className="mt-4">
                                            <div className="flex justify-between items-center mb-2">
                                                <h4 className="font-semibold text-base text-gray-800">
                                                    方案對比（B - A）
                                                </h4>
                                                <button
                                                    className="text-sm text-pink-600 hover:text-pink-800 font-medium flex items-center gap-1"
                                                    onClick={() => setIsTableExpanded(!isTableExpanded)}
                                                >
                                                    {isTableExpanded ? "收起" : "展開"}
                                                </button>
                                            </div>
                                            {isTableExpanded && (
                                                <div className="overflow-x-auto transition-all duration-300">
                                                    <table className="w-full text-sm border-collapse">
                                                        <thead>
                                                            <tr className="bg-pink-50">
                                                                <th className="border p-2 text-left text-pink-700">
                                                                    項目
                                                                </th>
                                                                <th className="border p-2 text-left text-pink-700">
                                                                    {presets[compareIndexes.a]?.name || "方案 A"}
                                                                </th>
                                                                <th className="border p-2 text-left text-pink-700">
                                                                    {presets[compareIndexes.b]?.name || "方案 B"}
                                                                </th>
                                                                <th className="border p-2 text-left text-pink-700">
                                                                    差異
                                                                </th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            {[
                                                                { key: "hp", label: "氣血 (hp)" },
                                                                { key: "d_s", label: "氣盾 (d_s)" },
                                                                { key: "d_d", label: "防禦 (d_d)" },
                                                                { key: "d_f", label: "流派抵禦 (d_f)" },
                                                                { key: "d_e", label: "元素抗性 (d_e)" },
                                                                { key: "b_b", label: "格擋 (b_b)" },
                                                                { key: "baseDamage", label: "原傷害" },
                                                                { key: "finalDamage", label: "減傷後傷害" },
                                                                { key: "ehp", label: "有效氣血 (EHP)" },
                                                                { key: "totalReduction", label: "總減傷率" },
                                                            ].map(({ key, label }) => {
                                                                const aValue =
                                                                    key in presets[compareIndexes.a].data
                                                                        ? presets[compareIndexes.a].data[key]
                                                                        : calculate(presets[compareIndexes.a].data)[key];
                                                                const bValue =
                                                                    key in presets[compareIndexes.b].data
                                                                        ? presets[compareIndexes.b].data[key]
                                                                        : calculate(presets[compareIndexes.b].data)[key];
                                                                const aNum = parseFloat(aValue.replace("%", "")) || 0;
                                                                const bNum = parseFloat(bValue.replace("%", "")) || 0;
                                                                const diff = bNum - aNum;
                                                                const isPositive = diff >= 0;
                                                                return (
                                                                    <tr key={key} className="hover:bg-pink-50">
                                                                        <td className="border p-2 text-gray-700">
                                                                            {label}
                                                                        </td>
                                                                        <td className="border p-2 font-medium">{aValue}</td>
                                                                        <td className="border p-2 font-medium">{bValue}</td>
                                                                        <td
                                                                            className={`border p-2 font-medium ${isPositive ? "text-green-600" : "text-red-600"}`}
                                                                        >
                                                                            {diff >= 0 ? "+" : ""}
                                                                            {diff.toFixed(2)}
                                                                            {key === "totalReduction" ? "%" : ""}
                                                                        </td>
                                                                    </tr>
                                                                );
                                                            })}
                                                        </tbody>
                                                    </table>
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>
                    </div>

                    {/* 投資收益曲線分析 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowInvestmentAnalysis(!showInvestmentAnalysis)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    投資收益曲線分析
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showInvestmentAnalysis ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showInvestmentAnalysis ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="mb-4 p-4 bg-gray-50 rounded-lg">
                                <h3 className="text-sm font-semibold text-gray-700 mb-3">
                                    分析模式：
                                </h3>
                                <div className="flex gap-4">
                                    <label className="flex items-center space-x-2 cursor-pointer">
                                        <input
                                            type="radio"
                                            name="analysisMode"
                                            value="incremental"
                                            checked={analysisMode === "incremental"}
                                            onChange={(e) => setAnalysisMode(e.target.value)}
                                            className="w-4 h-4 text-pink-600"
                                        />
                                        <span className="text-sm">增量分析 (從當前面板繼續投資)</span>
                                    </label>
                                    <label className="flex items-center space-x-2 cursor-pointer">
                                        <input
                                            type="radio"
                                            name="analysisMode"
                                            value="from_zero"
                                            checked={analysisMode === "from_zero"}
                                            onChange={(e) => setAnalysisMode(e.target.value)}
                                            className="w-4 h-4 text-pink-600"
                                        />
                                        <span className="text-sm">從零分析 (各屬性從0開始堆疊)</span>
                                    </label>
                                </div>
                            </div>
                            <p className="text-sm text-gray-600 mb-4">
                                {analysisMode === "incremental"
                                    ? "顯示從當前防禦數值基礎上投入不同點數的減傷效果"
                                    : "顯示各防禦屬性從0開始投入不同點數的減傷效果（用於新角色配裝規劃）"}
                            </p>
                            <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                                <div className="flex items-center justify-between mb-3">
                                    <h3 className="text-sm font-semibold text-gray-700">
                                        選擇要顯示的曲線：
                                    </h3>
                                    <div className="flex gap-2">
                                        <button
                                            onClick={handleSelectAll}
                                            className="px-3 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600"
                                        >
                                            全選
                                        </button>
                                        <button
                                            onClick={handleDeselectAll}
                                            className="px-3 py-1 text-xs bg-gray-500 text-white rounded hover:bg-gray-600"
                                        >
                                            全不選
                                        </button>
                                    </div>
                                </div>
                                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                                    {recommendationData
                                        .filter((attr) => attr.attribute !== "d_c_defense")
                                        .map((attr, index) => (
                                            <label
                                                key={attr.attribute}
                                                className="flex items-center space-x-2 cursor-pointer"
                                            >
                                                <input
                                                    type="checkbox"
                                                    checked={selectedCurves[attr.attribute] || false}
                                                    onChange={() => handleCurveToggle(attr.attribute)}
                                                    className="w-4 h-4 text-pink-600 rounded focus:ring-pink-500"
                                                />
                                                <div className="flex items-center space-x-2">
                                                    <div
                                                        className="w-3 h-3 rounded-full"
                                                        style={{ backgroundColor: colors[index % colors.length] }}
                                                    ></div>
                                                    <span className="text-sm text-gray-700">{attr.label}</span>
                                                </div>
                                            </label>
                                        ))}
                                </div>
                            </div>
                            {analysisData.length > 0 ? (
                                <ResponsiveContainer width="100%" height={400}>
                                    <LineChart data={analysisData}>
                                        <CartesianGrid strokeDasharray="3 3" />
                                        <XAxis
                                            dataKey="points"
                                            label={{
                                                value: "投入點數",
                                                position: "insideBottom",
                                                offset: -5,
                                            }}
                                        />
                                        <YAxis label={{ value: "減傷%", angle: -90, position: "insideLeft" }} />
                                        <Tooltip
                                            formatter={(value, name) => [
                                                `${value.toFixed(3)}%`,
                                                recommendationData.find((d) => d.attribute === name)?.label || name,
                                            ]}
                                            labelFormatter={(points) => `投入點數: ${points}`}
                                        />
                                        <Legend />
                                        {recommendationData
                                            .filter((attr) => attr.attribute !== "d_c_defense")
                                            .map((attr, index) => (
                                                selectedCurves[attr.attribute] && (
                                                    <Line
                                                        key={attr.attribute}
                                                        type="monotone"
                                                        dataKey={attr.attribute}
                                                        stroke={colors[index % colors.length]}
                                                        strokeWidth={2}
                                                        dot={false}
                                                        name={attr.label}
                                                    />
                                                )
                                            ))}
                                    </LineChart>
                                </ResponsiveContainer>
                            ) : (
                                <p className="text-sm text-gray-500">正在生成圖表，請稍候...</p>
                            )}
                        </div>
                    </div>

                    {/* 每200點屬性減傷收益 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowIncrementalAnalysis(!showIncrementalAnalysis)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    每200點屬性減傷收益
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showIncrementalAnalysis ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showIncrementalAnalysis ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="flex flex-wrap gap-4 mb-4">
                                {[
                                    { key: "d_s", label: "氣盾", color: "#3b82f6" },
                                    { key: "d_d", label: "防禦", color: "#10b981" },
                                    { key: "d_f", label: "流派抵禦", color: "#8b5cf6" },
                                    { key: "d_e", label: "元素抗性", color: "#14b8a6" },
                                    { key: "b_b", label: "格擋", color: "#f97316" },
                                    { key: "b_c_defense", label: "抗會心數值", color: "#d084d0" },

                                ].map(({ key, label, color }) => (
                                    <label key={key} className="flex items-center">
                                        <input
                                            type="checkbox"
                                            checked={visibility[key]}
                                            onChange={() => toggleVisibility(key)}
                                            className="mr-2"
                                        />
                                        <span style={{ color }}>{label}</span>
                                    </label>
                                ))}
                            </div>
                            <div className="w-full h-[250px] sm:h-[300px] md:h-[350px]">
                                {deltaData.length > 0 ? (
                                    <ResponsiveContainer width="100%" height="100%">
                                        <LineChart data={deltaData}>
                                            <CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
                                            <XAxis
                                                dataKey="point"
                                                label={{
                                                    value: "屬性點",
                                                    position: "insideBottom",
                                                    offset: -5,
                                                    fontSize: 12,
                                                    fill: "#6b7280",
                                                }}
                                                tick={{ fill: "#6b7280", fontSize: 12 }}
                                            />
                                            <YAxis
                                                label={{
                                                    value: "每200點收益 (%)",
                                                    angle: -90,
                                                    position: "insideLeft",
                                                    fontSize: 12,
                                                    fill: "#6b7280",
                                                }}
                                                tick={{ fill: "#6b7280", fontSize: 12 }}
                                            />
                                            <Tooltip content={<CustomTooltip isDelta={true} />} />
                                            <Legend wrapperStyle={{ fontSize: 12 }} />
                                            {visibility.d_s && (
                                                <Line
                                                    type="monotone"
                                                    dataKey="d_s"
                                                    name="氣盾"
                                                    stroke="#3b82f6"
                                                    strokeWidth={2}
                                                    dot={false}
                                                />
                                            )}
                                            {visibility.d_d && (
                                                <Line
                                                    type="monotone"
                                                    dataKey="d_d"
                                                    name="防禦"
                                                    stroke="#10b981"
                                                    strokeWidth={2}
                                                    dot={false}
                                                />
                                            )}
                                            {visibility.d_f && (
                                                <Line
                                                    type="monotone"
                                                    dataKey="d_f"
                                                    name="流派抵禦"
                                                    stroke="#8b5cf6"
                                                    strokeWidth={2}
                                                    dot={false}
                                                />
                                            )}
                                            {visibility.d_e && (
                                                <Line
                                                    type="monotone"
                                                    dataKey="d_e"
                                                    name="元素抗性"
                                                    stroke="#14b8a6"
                                                    strokeWidth={2}
                                                    dot={false}
                                                />
                                            )}
                                            {visibility.b_b && (
                                                <Line
                                                    type="monotone"
                                                    dataKey="b_b"
                                                    name="格擋"
                                                    stroke="#f97316"
                                                    strokeWidth={2}
                                                    dot={false}
                                                />
                                            )}
                                            {visibility.b_c_defense && (
                                                <Line
                                                    type="monotone"
                                                    dataKey="b_c_defense"
                                                    name="抗會心數值"
                                                    stroke="#d084d0"
                                                    strokeWidth={2}
                                                    dot={false}
                                                />
                                            )}

                                        </LineChart>
                                    </ResponsiveContainer>
                                ) : (
                                    <p className="text-sm text-gray-500">正在生成圖表，請稍候...</p>
                                )}
                            </div>
                        </div>
                    </div>

                    <div className="text-center text-xs text-gray-500 mb-4">
                        <p>防守屬性收益計算器 © {new Date().getFullYear()} | 數據僅供參考</p>
                    </div>
                </div>
            );
        };



        const DamageCalculator2 = () => {
            const [inputs, setInputs] = useState({
                skill_multiplier: '1518',
                D: '5000', E: '800', b_c: '900', d_c: '1.8', R: '500', h: '700',
                b_d: '2000', b_s: '700', b_e: '0', flow_percent: '0', damage_increase: '0',
                skill_damage_increase: '0',
                d_s: '2000', d_f: '2000', d_d: '5000', d_e: '0', b_b: '600', hp: '80000',
                b_c_defense: '550', d_c_defense: '0', flow_resist_percent: '0', damage_reduction: '0',
                skill_damage_reduction: '0',
                lambda_1: '358', lambda_2: '0.359', lambda_3: '2860', lambda_4: '531', W: '1',
                gold_i: '0',
            });
            const [inputErrors, setInputErrors] = useState({});
            const [previousResult, setPreviousResult] = useState(null);
            const [previousInputs, setPreviousInputs] = useState(null);
            const [visibility, setVisibility] = useState({
                b_d: true, b_e: true, R: true, h: true, D: true, E: true, b_s: true, b_c: true, d_c: true,
            });
            const [showAttacker, setShowAttacker] = useState(true);
            const [showDefender, setShowDefender] = useState(true);
            const [showOriginal, setShowOriginal] = useState(true);
            const [showCorrected, setShowCorrected] = useState(true);
            const [showDamageResult, setShowDamageResult] = useState(true);
            const [showIncrementalAnalysis, setShowIncrementalAnalysis] = useState(true);
            const [isTableExpanded, setIsTableExpanded] = useState(true);
            const [presets, setPresets] = useState([]);
            const [compareIndexes, setCompareIndexes] = useState({ a: null, b: null });
            const [compareResult, setCompareResult] = useState(null);
            const [investmentPoints, setInvestmentPoints] = useState({
                D: 200, E: 200, R: 200, b_d: 200, b_e: 200, b_s: 200, h: 200, b_c: 200,
            });
            const [critDamagePercent, setCritDamagePercent] = useState(50); // For critical damage % investment (1-200%)
            const [recommendationData, setRecommendationData] = useState([]);
            const [analysisMode, setAnalysisMode] = useState('incremental');

            const goldOptions = [
                { value: '0', label: '無金周天' },
                { value: '0.03', label: '金周天1級' },
                { value: '0.04', label: '金周天2級' },
                { value: '0.05', label: '金周天3級' },
            ];

            const elementWeaknessOptions = [
                { value: '1', label: '無元素弱點' },
                { value: '1.1', label: '碎夢大特' },
            ];

            const colors = ['#3b82f6', '#10b981', '#8b5cf6', '#14b8a6', '#f97316', '#d084d0', '#a4de6c', '#ff6b6b', '#fbbf24'];

            const toNum = (val) => {
                const num = parseFloat(val);
                return isNaN(num) ? 0 : num;
            };

            const handleChange = (e) => {
                const { name, value } = e.target;
                if (name === 'gold_i' || name === 'W') {
                    setInputs((prev) => ({ ...prev, [name]: value }));
                    setInputErrors((prev) => ({ ...prev, [name]: '' }));
                } else {
                    if (value < 0) {
                        setInputErrors((prev) => ({ ...prev, [name]: '輸入值不能為負數' }));
                        return;
                    }
                    if (value > 1000000) {
                        setInputErrors((prev) => ({ ...prev, [name]: '輸入值過大，最大為1000000' }));
                        return;
                    }
                    setInputs((prev) => ({ ...prev, [name]: value }));
                    setInputErrors((prev) => ({ ...prev, [name]: '' }));
                }
            };

            const saveCurrentResult = () => {
                setPreviousResult(calculate(inputs));
                setPreviousInputs({ ...inputs });
            };

            const toggleVisibility = (key) => {
                setVisibility((prev) => ({ ...prev, [key]: !prev[key] }));
            };

            const calculateRecommendedBreakDefense = (d_d, lambda_3 = 2860) => {
                const d_d_num = toNum(d_d);
                const lambda_3_num = toNum(lambda_3);
                if (d_d_num <= 0) return 0;

                const minBreakDefense = d_d_num - lambda_3_num; // 為了 gamma ≥ 50%
                return Math.ceil(minBreakDefense < 0 ? 0 : minBreakDefense);
            };

            const calculateRecommendedAccuracy = (b_b) => {
                const b_b_num = toNum(b_b);
                if (b_b_num <= 0) return 0;
                const r_b_val = b_b_num / (b_b_num + 713);
                const target = r_b_val + 0.01447552448;
                if (target >= 1) return '無法達到97%命中';
                const h_required = (target * 713) / (1 - target);
                const result = Math.ceil(h_required);
                return result > 0 && result < 1000000 ? result : 'ERROR';
            };

            const calculate = (inputs) => {
                const {
                    skill_multiplier, D, E, b_c, d_c, R, h, b_d, b_s, b_e, flow_percent, damage_increase,
                    skill_damage_increase, d_s, d_f, d_d, d_e, b_b, hp, b_c_defense, d_c_defense,
                    flow_resist_percent, damage_reduction, skill_damage_reduction, lambda_1, lambda_2,
                    lambda_3, lambda_4, W, gold_i,
                } = inputs;

                const c = toNum(b_c) - toNum(b_c_defense);
                const p_c = (115 * c + 90) / (c + 940) / 100 + toNum(gold_i);
                const r_h = 143 * toNum(h) / (toNum(h) + 713);
                const r_b = 143 * toNum(b_b) / (toNum(b_b) + 713);
                const p_h_percent = 95 + (r_h - r_b);
                const p_h = Math.min(1, Math.max(0.25, p_h_percent / 100));
                const p_h_1 = p_h;
                const m_c = 1 + p_c * (toNum(d_c) - 1 - toNum(d_c_defense));
                const d_mul = m_c * p_h + 0.5 * (1 - p_h);

                const G = toNum(b_s) >= toNum(d_s)
                    ? 0
                    : toNum(d_s) / 3 <= toNum(b_s)
                        ? 0.5 * (toNum(d_s) - toNum(b_s))
                        : toNum(d_s) - 2 * toNum(b_s);

                const A = toNum(D) + (toNum(R) - toNum(d_f)) - G;

                const gamma = toNum(d_d) - toNum(b_d) > 0
                    ? (toNum(d_d) - toNum(b_d)) / (toNum(d_d) - toNum(b_d) + toNum(lambda_3))
                    : 0;
                const gamma_1 = 1 - gamma;

                const e = toNum(d_e) - toNum(b_e);
                const beta = e > 0 ? e / (e + toNum(lambda_4)) : 0;

                const gamma_2 = gamma > 0 ? 1 - gamma : 1;
                const beta_2 = beta > 0 ? 1 - beta : 1;

                const c_original = toNum(b_c);
                const p_c_original = Math.max(0, (115 * c + 90) / (c + 940) / 100 + toNum(gold_i));
                const r_h_original = 0;
                const r_b_original = 143 * toNum(b_b) / (toNum(b_b) + 713);
                const p_h_original_percent = 95 + (r_h_original - r_b_original);
                const p_h_original = Math.min(1, Math.max(0.25, p_h_original_percent / 100));
                const p_h_1_original = p_h_original;
                const m_c_original = 1 + p_c_original * (toNum(d_c) - 1);
                const d_mul_original = m_c_original * p_h_original + 0.5 * (1 - p_h_original);
                const G_original = toNum(b_s);
                const A_original = toNum(D) + toNum(R) + G_original;
                const gamma_original = 0;
                const beta_original = 0;
                const gamma_original_2 = 1 - gamma_original;
                const beta_original_2 = 1 - beta_original;

                const baseDamage = (
                    (toNum(skill_multiplier) / 100) * (
                        ((toNum(lambda_1) + toNum(lambda_2) * A_original) * (1 - gamma_original)) +
                        toNum(W) * toNum(lambda_2) * toNum(E) * (1 - beta_original)
                    )
                ) * d_mul_original * (1 + toNum(flow_percent)) * (1 + toNum(damage_increase)) * (1 + toNum(skill_damage_increase));

                const finalDamage = (
                    (toNum(skill_multiplier) / 100) * (
                        ((toNum(lambda_1) + toNum(lambda_2) * A) * (1 - gamma)) +
                        toNum(W) * toNum(lambda_2) * toNum(E) * (1 - beta)
                    )
                ) * d_mul * (1 + toNum(flow_percent) - toNum(flow_resist_percent)) * (1 + toNum(damage_increase) - toNum(damage_reduction)) * (1 + toNum(skill_damage_increase) / 100 - toNum(skill_damage_reduction) / 100);

                const totalReduction = finalDamage / baseDamage || 0;
                const ehp = toNum(hp) / (1 - totalReduction) || toNum(hp);

                const base_elementalDamage = (
                    (toNum(skill_multiplier) / 100) * (toNum(W) * toNum(lambda_2) * toNum(E) * (1 - beta_original))
                ) * d_mul_original * (1 + toNum(flow_percent) - toNum(flow_resist_percent)) * (1 + toNum(damage_increase) - toNum(damage_reduction)) * (1 + toNum(skill_damage_increase) / 100 - toNum(skill_damage_reduction) / 100);

                const elementalDamage = (
                    (toNum(skill_multiplier) / 100) * (toNum(W) * toNum(lambda_2) * toNum(E) * (1 - beta))
                ) * d_mul * (1 + toNum(flow_percent) - toNum(flow_resist_percent)) * (1 + toNum(damage_increase) - toNum(damage_reduction)) * (1 + toNum(skill_damage_increase) / 100 - toNum(skill_damage_reduction) / 100);

                const base_elementalDamagePrecentage = base_elementalDamage / baseDamage || 0;
                const elementalDamagePrecentage = elementalDamage / finalDamage || 0;

                const calculateRequiredH = (b_b) => {
                    const b_b_num = toNum(b_b);
                    if (b_b_num === 0) return 0;
                    const r_b_val = 143 * b_b_num / (b_b_num + 713) / 100;
                    const r_h_target = 0.05 + r_b_val;
                    if (r_h_target >= 1.43) return '無法滿命中';
                    const numerator = r_h_target * 100 * 713;
                    const denominator = 143 - r_h_target * 100;
                    if (denominator <= 0) return '無法滿命中';
                    const h_required = Math.ceil(numerator / denominator);
                    return h_required > 0 && h_required < 10000 ? h_required : 'ERROR';
                };

                const full_ph = calculateRequiredH(inputs.b_b);

                return {
                    c: c.toFixed(2),
                    p_c: (p_c * 100).toFixed(2) + '%',
                    r_h: (r_h * 100).toFixed(2) + '%',
                    r_b: (r_b * 100).toFixed(2) + '%',
                    p_h: p_h.toFixed(4),
                    p_h_1: (p_h_1 * 100).toFixed(2) + '%',
                    m_c: m_c.toFixed(4),
                    d_mul: d_mul.toFixed(4),
                    G: G.toFixed(2),
                    A: A.toFixed(2),
                    gamma: (gamma * 100).toFixed(2) + '%',
                    gamma_1: (gamma_1 * 100).toFixed(2) + '%',
                    beta: (beta * 100).toFixed(2) + '%',
                    gamma_2: (gamma_2 * 100).toFixed(2) + '%',
                    beta_2: (beta_2 * 100).toFixed(2) + '%',
                    c_original: c_original.toFixed(2),
                    p_c_original: (p_c_original * 100).toFixed(2) + '%',
                    r_h_original: (r_h_original * 100).toFixed(2) + '%',
                    r_b_original: (r_b_original * 100).toFixed(2) + '%',
                    p_h_original: p_h_original.toFixed(4),
                    p_h_1_original: (p_h_1 * 100).toFixed(2) + '%',
                    m_c_original: m_c_original.toFixed(4),
                    d_mul_original: d_mul_original.toFixed(4),
                    G_original: G_original.toFixed(2),
                    A_original: A_original.toFixed(2),
                    gamma_original: (gamma_original * 100).toFixed(2) + '%',
                    beta_original: (beta_original * 100).toFixed(2) + '%',
                    gamma_original_2: (gamma_original_2 * 100).toFixed(2) + '%',
                    beta_original_2: (beta_original_2 * 100).toFixed(2) + '%',
                    baseDamage: baseDamage.toFixed(2),
                    finalDamage: finalDamage.toFixed(2),
                    totalReduction: (totalReduction * 100).toFixed(2) + '%',
                    ehp: ehp.toFixed(2),
                    base_elementalDamage: base_elementalDamage.toFixed(2),
                    elementalDamage: elementalDamage.toFixed(2),
                    base_elementalDamagePrecentage: (base_elementalDamagePrecentage * 100).toFixed(2) + '%',
                    elementalDamagePrecentage: (elementalDamagePrecentage * 100).toFixed(2) + '%',
                    full_ph: typeof full_ph === 'number' ? full_ph.toFixed(0) : full_ph,
                };
            };

            const calculateInvestmentIncrease = (attr, points) => {
                const params = { ...inputs };
                if (analysisMode === 'from_zero') {
                    if (attr === 'd_c_percent') {
                        // For critical damage percentage, we add the percentage directly to d_c
                        params.d_c = (1 + points / 100).toString();
                    } else {
                        params[attr] = points;
                    }
                } else {
                    if (attr === 'd_c_percent') {
                        // For critical damage percentage, we add the percentage to current d_c
                        const currentDc = toNum(inputs.d_c);
                        params.d_c = (currentDc + points / 100).toString();
                    } else {
                        params[attr] = toNum(inputs[attr]) + points;
                    }
                }
                const newDamage = calculate(params).finalDamage;
                const baseDamage = calculate(inputs).finalDamage;
                return baseDamage ? ((toNum(newDamage) - toNum(baseDamage)) / toNum(baseDamage)) * 100 : 0;
            };

            const analyzeAttackOptions = () => {
                const attributes = [
                    { key: 'D', label: '攻擊' },
                    { key: 'E', label: '元素攻擊' },
                    { key: 'R', label: '流派克制' },
                    { key: 'b_d', label: '破防' },
                    { key: 'b_e', label: '忽視元素抗性' },
                    { key: 'b_s', label: '破盾' },
                    { key: 'b_c', label: '會心' },
                    { key: 'd_c_percent', label: '會心傷害%' },
                ];
                const newRecommendationData = attributes.map(({ key, label }) => ({
                    attribute: key,
                    label,
                    damageIncrease: key === 'd_c_percent'
                        ? calculateInvestmentIncrease(key, critDamagePercent)
                        : calculateInvestmentIncrease(key, investmentPoints[key] || 200),
                })).sort((a, b) => b.damageIncrease - a.damageIncrease);
                setRecommendationData(newRecommendationData);
            };

            const handleInvestmentChange = (attr, value) => {
                setInvestmentPoints((prev) => ({
                    ...prev,
                    [attr]: Math.min(1000, Math.max(1, parseInt(value) || 1)),
                }));
                analyzeAttackOptions();
            };

            const handleCritDamagePercentChange = (value) => {
                const newValue = Math.min(200, Math.max(1, parseInt(value) || 1));
                setCritDamagePercent(newValue);
                analyzeAttackOptions();
            };

            const handleSelectAll = () => {
                setVisibility({
                    b_d: true, b_e: true, R: true, D: true, E: true, b_s: true, b_c: true, d_c: true,
                });
            };

            const handleDeselectAll = () => {
                setVisibility({
                    b_d: false, b_e: false, R: false, h: false, D: false, E: false, b_s: false, b_c: false, d_c: false,
                });
            };

            const handleCurveToggle = (attr) => {
                setVisibility((prev) => ({ ...prev, [attr]: !prev[attr] }));
            };

            const saveCurrentPreset = () => {
                if (presets.length >= 4) return alert('最多只能保存 4 組方案！');
                const name = prompt('請輸入方案名稱：');
                if (!name) return;
                const newPresets = [...presets, { name, data: inputs }];
                setPresets(newPresets);
            };

            const loadPreset = (i) => {
                setInputs(presets[i].data);
                analyzeAttackOptions();
            };

            const deletePreset = (i) => {
                const updated = presets.filter((_, idx) => idx !== i);
                setPresets(updated);
            };

            const comparePresets = () => {
                const a = presets[compareIndexes.a]?.data;
                const b = presets[compareIndexes.b]?.data;
                if (!a || !b) return;
                const diff = {};
                Object.keys(a).forEach((key) => {
                    diff[key] = toNum(b[key]) - toNum(a[key]);
                });
                const resultA = calculate(a);
                const resultB = calculate(b);
                setCompareResult({
                    diff,
                    resultDiff: {
                        baseDamage: toNum(resultB.baseDamage) - toNum(resultA.baseDamage),
                        finalDamage: toNum(resultB.finalDamage) - toNum(resultA.finalDamage),
                        totalReduction: toNum(resultB.totalReduction) - toNum(resultA.totalReduction),
                    },
                });
            };

            useEffect(() => {
                analyzeAttackOptions();
            }, [inputs, analysisMode, investmentPoints, critDamagePercent]);

            const generateChartData = (inputs) => {
                const min_b_c = toNum(inputs.b_c_defense);
                const attribute_points = Array.from({ length: 201 }, (_, i) => min_b_c + i * 50); // 從 b_c_defense 開始
                const increases = { b_d: [], b_e: [], D: [], E: [], R: [], b_s: [], h: [], b_c: [] };
                const delta_increases = { b_d: [], b_e: [], D: [], E: [], R: [], b_s: [], h: [], b_c: [] };

                const calculateDamage = (D, E, R, b_d, b_e, b_s, h, b_c, d_c) => {
                    const params = { ...inputs, D, E, R, b_d, b_e, b_s, h, b_c, d_c };
                    return toNum(calculate(params).finalDamage);
                };

                const calculateRequiredH = (b_b) => {
                    const b_b_num = toNum(b_b);
                    if (b_b_num === 0) return 0;
                    const r_b_val = 143 * b_b_num / (b_b_num + 713) / 100;
                    const r_h_target = 0.05 + r_b_val;
                    if (r_h_target >= 1.43) return 10000;
                    const numerator = r_h_target * 100 * 713;
                    const denominator = 143 - r_h_target * 100;
                    if (denominator <= 0) return 10000;
                    return Math.ceil(numerator / denominator);
                };

                const fullHitRequired = calculateRequiredH(toNum(inputs.b_b));
                const baselineH = Math.min(fullHitRequired, 10000);
                const baseDamage = calculateDamage(
                    toNum(inputs.D), toNum(inputs.E), 0, 0, 0, 0, baselineH, toNum(inputs.b_c), toNum(inputs.d_c)
                );

                const calculateIncrease = (attr, value) => {
                    const params = {
                        D: toNum(inputs.D),
                        E: toNum(inputs.E),
                        R: 0,
                        b_d: 0,
                        b_e: 0,
                        b_s: 0,
                        h: baselineH,
                        b_c: toNum(inputs.b_c),
                        d_c: toNum(inputs.d_c),
                    };

                    if (attr === 'b_c') {
                        params[attr] = value;
                    } else if (['R', 'b_d', 'b_e', 'b_s'].includes(attr)) {
                        params[attr] = value;
                    } else if (attr === 'h') {
                        params[attr] = baselineH + value;
                    } else {
                        params[attr] = toNum(inputs[attr]) + value;
                    }

                    const newDamage = calculateDamage(
                        params.D, params.E, params.R, params.b_d, params.b_e, params.b_s, params.h, params.b_c, params.d_c
                    );
                    const increase = baseDamage ? (newDamage - baseDamage) / baseDamage : 0;
                    return Math.max(0, increase);
                };

                attribute_points.forEach((point) => {
                    increases.D.push(calculateIncrease('D', point));
                    increases.E.push(calculateIncrease('E', point));
                    increases.R.push(calculateIncrease('R', point));
                    increases.b_d.push(calculateIncrease('b_d', point));
                    increases.b_e.push(calculateIncrease('b_e', point));
                    increases.b_s.push(calculateIncrease('b_s', point));
                    increases.h.push(calculateIncrease('h', point));
                    increases.b_c.push(calculateIncrease('b_c', point));
                });

                for (let i = 1; i < increases.b_s.length; i++) {
                    delta_increases.D.push(Math.max(0, increases.D[i] - increases.D[i - 1]));
                    delta_increases.E.push(Math.max(0, increases.E[i] - increases.E[i - 1]));
                    delta_increases.R.push(Math.max(0, increases.R[i] - increases.R[i - 1]));
                    delta_increases.b_d.push(Math.max(0, increases.b_d[i] - increases.b_d[i - 1]));
                    delta_increases.b_e.push(Math.max(0, increases.b_e[i] - increases.b_e[i - 1]));
                    delta_increases.b_s.push(Math.max(0, increases.b_s[i] - increases.b_s[i - 1]));
                    delta_increases.h.push(Math.max(0, increases.h[i] - increases.h[i - 1]));
                    delta_increases.b_c.push(Math.max(0, increases.b_c[i] - increases.b_c[i - 1]));
                }

                const deltaData = attribute_points.slice(1).map((point, i) => ({
                    point,
                    D: delta_increases.D[i],
                    E: delta_increases.E[i],
                    R: delta_increases.R[i],
                    b_d: delta_increases.b_d[i],
                    b_e: delta_increases.b_e[i],
                    b_s: delta_increases.b_s[i],
                    h: delta_increases.h[i],
                    b_c: delta_increases.b_c[i],
                }));

                const increaseData = attribute_points.map((point, i) => ({
                    point,
                    D: increases.D[i],
                    E: increases.E[i],
                    R: increases.R[i],
                    b_d: increases.b_d[i],
                    b_e: increases.b_e[i],
                    b_s: increases.b_s[i],
                    h: increases.h[i],
                    b_c: increases.b_c[i],
                }));

                return {
                    deltaData,
                    increaseData,
                    baselineInfo: {
                        fullHitRequired,
                        baselineH,
                        baseDamage: baseDamage.toFixed(2),
                    },
                };
            };
            const CustomTooltip = ({ active, payload, label, isDelta }) => {
                if (active && payload && payload.length) {
                    return (
                        <div className="bg-white p-3 border border-gray-200 rounded-lg shadow-sm">
                            <p className="text-sm text-gray-700 font-medium">屬性點: {label}</p>
                            {payload.map((entry, index) => (
                                <p key={index} className="text-sm text-gray-600">
                                    <span style={{ color: entry.stroke }}>{entry.name}</span>: {(entry.value * 100).toFixed(isDelta ? 4 : 2)}%
                                </p>
                            ))}
                        </div>
                    );
                }
                return null;
            };

            const result = calculate(inputs);
            const { deltaData, increaseData } = generateChartData(inputs);

            return (
                <div className="p-4 container mx-auto min-h-screen bg-gray-50">
                    {/* 標題 */}
                    <div className="bg-gradient-to-r from-pink-500 to-red-500 rounded-xl p-6 mb-6 shadow-lg">
                        <h1 className="text-xl md:text-2xl font-bold text-center text-white">
                            攻擊計算器
                        </h1>
                        <p className="text-center text-white text-opacity-90 text-sm mt-1">
                            如有問題請聯繫櫻桃白蘭地@緣定今生
                        </p>
                    </div>

                    {/* 攻擊方參數 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-4">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowAttacker(!showAttacker)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    攻擊方參數
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showAttacker ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showAttacker ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <ImageUploader setInputs={setInputs} type="attacker" />
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                {[
                                    {
                                        key: "skill_multiplier",
                                        label: "技能倍率",
                                        icon: "🔥",
                                        tooltip: "如技能倍率為300%，輸入300",
                                    },
                                    { key: "D", label: "攻擊", icon: "⚔️" },
                                    { key: "E", label: "元素攻擊（平均）", icon: "✨" },
                                    { key: "b_c", label: "會心數值", icon: "🎯" },
                                    {
                                        key: "d_c",
                                        label: "會心傷害",
                                        icon: "💥",
                                        tooltip: "除以100，例如180%，輸入1.8",
                                    },
                                    { key: "R", label: "流派克制", icon: "🔄" },
                                    { key: "h", label: "命中", icon: "🎯" },
                                    { key: "b_d", label: "破防", icon: "🛡️" },
                                    { key: "b_s", label: "破盾", icon: "🔨" },
                                    { key: "b_e", label: "忽視元素抗性", icon: "🌀" },
                                    {
                                        key: "flow_percent",
                                        label: "流派克制%",
                                        icon: "📊",
                                        tooltip:
                                            "例如9.5%，輸入0.095。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "damage_increase",
                                        label: "增傷%",
                                        icon: "📈",
                                        tooltip:
                                            "除以100，例如5%，輸入0.05。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "skill_damage_increase",
                                        label: "技能增傷%",
                                        icon: "📈",
                                        tooltip:
                                            "除以100，例如5%，輸入0.05。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "gold_i",
                                        label: "金周天",
                                        icon: "🌟",
                                        type: "select",
                                        options: goldOptions,
                                    },
                                    {
                                        key: "W",
                                        label: "元素弱點",
                                        icon: "🖕🏻",
                                        type: "select",
                                        options: elementWeaknessOptions,
                                    },
                                ].map(({ key, label, icon, type, options, tooltip }) => (
                                    <div key={key} className="flex flex-col group relative">
                                        <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                            <span className="mr-1 md:mr-2">{icon}</span>
                                            {label}
                                            {tooltip && (
                                                <>
                                                    <span className="ml-1 flex items-center justify-center w-4 h-4 rounded-full bg-gray-400 text-white text-xs cursor-help">
                                                        ?
                                                    </span>
                                                    <div className="absolute left-0 top-8 bg-gray-800 text-white text-xs p-2 rounded-lg shadow-md z-10 max-w-xs opacity-0 group-hover:opacity-100 transition-opacity">
                                                        {tooltip}
                                                    </div>
                                                </>
                                            )}
                                        </label>
                                        {type === "select" ? (
                                            <select
                                                name={key}
                                                value={inputs[key]}
                                                onChange={handleChange}
                                                className="border border-gray-200 rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors"
                                                aria-label={label}
                                            >
                                                {options.map((opt) => (
                                                    <option key={opt.value} value={opt.value}>
                                                        {opt.label}
                                                    </option>
                                                ))}
                                            </select>
                                        ) : (
                                            <input
                                                type="number"
                                                name={key}
                                                value={inputs[key]}
                                                onChange={handleChange}
                                                min="0"
                                                max="1000000"
                                                className={`border ${inputErrors[key] ? "border-red-500" : "border-gray-200"} rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors`}
                                                aria-label={label}
                                            />
                                        )}
                                        {inputErrors[key] && (
                                            <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                                        )}
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* 防守方參數 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-4">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowDefender(!showDefender)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    防守方參數
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showDefender ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showDefender ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <ImageUploader setInputs={setInputs} type="defender" />
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                {[
                                    { key: "d_s", label: "氣盾", icon: "🛡️" },
                                    { key: "d_f", label: "流派抵禦", icon: "🔄" },
                                    { key: "d_d", label: "防禦", icon: "🏰" },
                                    { key: "d_e", label: "元素抗性", icon: "🌀" },
                                    { key: "b_b", label: "格擋", icon: "✋" },
                                    { key: "hp", label: "氣血", icon: "❤️" },
                                    { key: "b_c_defense", label: "抗會心數值", icon: "🎯" },
                                    {
                                        key: "d_c_defense",
                                        label: "會心防禦%",
                                        icon: "📊",
                                        tooltip:
                                            "除以100，例如25%，輸入0.25。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "flow_resist_percent",
                                        label: "流派抵禦%",
                                        icon: "📊",
                                        tooltip:
                                            "除以100，例如5%，輸入0.05。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "damage_reduction",
                                        label: "傷害減免%",
                                        icon: "📉",
                                        tooltip:
                                            "除以100，例如15%，輸入0.15。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "skill_damage_reduction",
                                        label: "技能減免%",
                                        icon: "📉",
                                        tooltip:
                                            "除以100，例如5%，輸入0.05。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                ].map(({ key, label, icon, tooltip }) => (
                                    <div key={key} className="flex flex-col group relative">
                                        <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                            <span className="mr-1 md:mr-2">{icon}</span>
                                            {label}
                                            {tooltip && (
                                                <>
                                                    <span className="ml-1 flex items-center justify-center w-4 h-4 rounded-full bg-gray-400 text-white text-xs cursor-help">
                                                        ?
                                                    </span>
                                                    <div className="absolute left-0 top-8 bg-gray-800 text-white text-xs p-2 rounded-lg shadow-md z-10 max-w-xs opacity-0 group-hover:opacity-100 transition-opacity">
                                                        {tooltip}
                                                    </div>
                                                </>
                                            )}
                                        </label>
                                        <input
                                            type="number"
                                            name={key}
                                            value={inputs[key]}
                                            onChange={handleChange}
                                            min="0"
                                            max="1000000"
                                            className={`border ${inputErrors[key] ? "border-red-500" : "border-gray-200"} rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors`}
                                            aria-label={label}
                                        />
                                        {inputErrors[key] && (
                                            <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                                        )}
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* 原數值屬性 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowOriginal(!showOriginal)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    原數值屬性
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showOriginal ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showOriginal ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="grid grid-cols-2 gap-3 mb-4">
                                {[
                                    { label: "真實會心", value: result.c_original },
                                    { label: "會心率", value: result.p_c_original },
                                    { label: "命中率", value: result.p_h_1_original },
                                    { label: "會心傷害倍率", value: result.m_c_original },
                                    { label: "傷害倍率", value: result.d_mul_original },
                                    { label: "剩餘氣盾", value: result.G_original },
                                    { label: "防禦穿透率", value: result.gamma_original_2 },
                                    { label: "元素穿透率", value: result.beta_original_2 },
                                    { label: "元素傷害佔比", value: result.base_elementalDamagePrecentage },
                                ].map(({ label, value }) => (
                                    <div key={label} className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                        <p className="text-xs text-gray-600">{label}</p>
                                        <p className="text-sm font-bold text-gray-800">{value}</p>
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* 修正後屬性 */}
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowCorrected(!showCorrected)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    修正後屬性
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showCorrected ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showCorrected ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="grid grid-cols-2 gap-3">
                                {[
                                    { label: "修正會心", value: result.c },
                                    { label: "會心率", value: result.p_c },
                                    { label: "命中率", value: result.p_h_1 },
                                    { label: "會心傷害倍率", value: result.m_c },
                                    { label: "傷害倍率", value: result.d_mul },
                                    { label: "剩餘氣盾", value: result.G },
                                    { label: "防禦穿透率", value: result.gamma_2 },
                                    { label: "元素穿透率", value: result.beta_2 },
                                    { label: "元素傷害佔比", value: result.elementalDamagePrecentage },
                                ].map(({ label, value }) => (
                                    <div key={label} className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                        <p className="text-xs text-pink-600">{label}</p>
                                        <p className="text-sm font-bold text-pink-800">{value}</p>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* 傷害計算結果 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowDamageResult(!showDamageResult)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    傷害計算結果
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showDamageResult ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showDamageResult ? "max-h-[3000px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="flex justify-end items-center mb-4">
                                <button
                                    className="bg-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-pink-700 transition-colors"
                                    onClick={saveCurrentPreset}
                                >
                                    保存當前方案
                                </button>
                            </div>
                            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-3 mt-6">
                                {[
                                    { label: "原傷害", value: result.baseDamage, color: "pink-100" },
                                    { label: "修正後傷害", value: result.finalDamage, color: "pink-100" },
                                    { label: "滿命中", value: result.full_ph, color: "pink-100" },
                                    {
                                        label: "實際生效傷害百分比",
                                        value: result.totalReduction,
                                        color: "pink-500",
                                        text: "white",
                                    },
                                ].map(({ label, value, color, text }) => (
                                    <div key={label} className={`bg-${color} p-3 rounded-lg`}>
                                        <p className={`text-xs ${text ? `text-${text}` : "text-pink-700"}`}>
                                            {label}
                                        </p>
                                        <p className={`text-lg font-bold ${text ? `text-${text}` : "text-pink-800"}`}>
                                            {value}
                                        </p>
                                    </div>
                                ))}
                            </div>

                            <div className="mt-6">
                                <div className="flex justify-between items-center mb-2">
                                    <div className="flex items-center">
                                        <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                        <h4 className="font-bold text-base text-gray-800">
                                            攻擊投資優先級（！下方先選增量模式！）
                                        </h4>
                                    </div>
                                </div>
                                <div>
                                    <p className="text-sm text-gray-600 mb-4">
                                        針對當前面板配置，通過拖動拉桿或輸入數值調整投資點數，實時查看從現有面板基礎上的增傷效果
                                    </p>
                                    {recommendationData.length > 0 ? (
                                        <div className="space-y-4">
                                            {[
                                                { key: "D", label: "攻擊" },
                                                { key: "E", label: "元素攻擊" },
                                                { key: "R", label: "流派克制" },
                                                { key: "b_d", label: "破防" },
                                                { key: "b_e", label: "忽視元素抗性" },
                                                { key: "b_s", label: "破盾" },
                                                { key: "h", label: "命中" },
                                                { key: "b_c", label: "會心" },
                                            ].map(({ key, label }) => {
                                                const increase = calculateInvestmentIncrease(key, investmentPoints[key]);
                                                const maxIncrease = Math.max(
                                                    ...Object.keys(investmentPoints).map((attr) =>
                                                        calculateInvestmentIncrease(attr, investmentPoints[attr])
                                                    ),
                                                    calculateInvestmentIncrease('d_c_percent', critDamagePercent),
                                                    0.0001
                                                );
                                                const barWidth = `${(increase / maxIncrease) * 100}%`;
                                                return (
                                                    <div key={key} className="flex items-center gap-4">
                                                        <span className="w-24 text-sm font-semibold text-gray-700">{label}</span>
                                                        <input
                                                            type="range"
                                                            min="1"
                                                            max="1000"
                                                            value={investmentPoints[key]}
                                                            onChange={(e) => handleInvestmentChange(key, e.target.value)}
                                                            className="w-1/3 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                        />
                                                        <input
                                                            type="number"
                                                            min="1"
                                                            max="1000"
                                                            value={investmentPoints[key]}
                                                            onChange={(e) => {
                                                                const value = Math.min(1000, Math.max(1, parseInt(e.target.value) || 1));
                                                                handleInvestmentChange(key, value);
                                                            }}
                                                            className="w-20 p-2 border border-gray-200 rounded-lg text-sm focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors"
                                                        />
                                                        <div className="w-1/3 bg-gray-200 rounded-full h-2.5">
                                                            <div
                                                                className="bg-pink-500 h-2.5 rounded-full"
                                                                style={{ width: barWidth }}
                                                            ></div>
                                                        </div>
                                                        <span className="text-sm text-gray-700">{increase.toFixed(2)}% 增傷</span>
                                                    </div>
                                                );
                                            })}
                                            <div className="flex items-center gap-4">
                                                <span className="w-24 text-sm font-semibold text-gray-700">會心傷害%</span>
                                                <input
                                                    type="range"
                                                    min="1"
                                                    max="200"
                                                    value={critDamagePercent}
                                                    onChange={(e) => handleCritDamagePercentChange(e.target.value)}
                                                    className="w-1/3 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                />
                                                <div className="relative w-20">
                                                    <input
                                                        type="number"
                                                        min="1"
                                                        max="200"
                                                        value={critDamagePercent}
                                                        onChange={(e) => {
                                                            const value = Math.min(200, Math.max(1, parseInt(e.target.value) || 1));
                                                            handleCritDamagePercentChange(value);
                                                        }}
                                                        className="w-full p-2 pr-6 border border-gray-200 rounded-lg text-sm focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors"
                                                    />
                                                    <span className="absolute right-2 top-1/2 transform -translate-y-1/2 text-sm text-gray-500">%</span>
                                                </div>
                                                <div className="w-1/3 bg-gray-200 rounded-full h-2.5">
                                                    <div
                                                        className="bg-pink-500 h-2.5 rounded-full"
                                                        style={{
                                                            width: `${(calculateInvestmentIncrease('d_c_percent', critDamagePercent) / Math.max(
                                                                ...Object.keys(investmentPoints).map((attr) =>
                                                                    calculateInvestmentIncrease(attr, investmentPoints[attr])
                                                                ),
                                                                calculateInvestmentIncrease('d_c_percent', critDamagePercent),
                                                                0.0001
                                                            )) * 100}%`
                                                        }}
                                                    ></div>
                                                </div>
                                                <span className="text-sm text-gray-700">{calculateInvestmentIncrease('d_c_percent', critDamagePercent).toFixed(2)}% 增傷</span>
                                            </div>
                                        </div>
                                    ) : (
                                        <p className="text-sm text-red-600">無法生成投資優先級數據，請檢查輸入值。</p>
                                    )}
                                </div>
                            </div>

                            {/* 針對性配裝建議 */}
                            <div className="mt-6 bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4 text-gray-700 flex items-center">
                                    <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                    針對性配裝建議
                                </h2>
                                <h4 className="font-bold text-pink-700 mb-2">
                                    <div className="flex items-center mb-2">
                                        <svg className="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                            <path
                                                fillRule="evenodd"
                                                d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9z"
                                                clipRule="evenodd"
                                            />
                                        </svg>
                                        <span>建議屬性</span>
                                    </div>
                                    <div className="grid grid-cols-2 gap-2">
                                        <div className="bg-pink-50 border border-pink-300 rounded-lg px-3 py-2 text-sm text-pink-800">
                                            建議破防：{calculateRecommendedBreakDefense(inputs.d_d, inputs.lambda_3)} 以上（50%穿透率）
                                        </div>
                                        <div className="bg-pink-50 border border-pink-300 rounded-lg px-3 py-2 text-sm text-pink-800">
                                            建議命中：{calculateRecommendedAccuracy(inputs.b_b)} 以上（97%命中）
                                        </div>
                                    </div>
                                </h4>

                                <div className="space-y-3">
                                    {recommendationData.length > 0 ? (
                                        <>
                                            <div className="flex items-center justify-between p-4 bg-green-50 rounded-lg border-l-4 border-green-500">
                                                <div>
                                                    <span className="font-semibold text-green-800">
                                                        最優投資: {recommendationData[0]?.label}
                                                    </span>
                                                    <p className="text-sm text-green-600 mt-1">
                                                        投資可增傷 {recommendationData[0]?.damageIncrease.toFixed(3)}%
                                                    </p>
                                                </div>
                                            </div>
                                            {recommendationData.length > 1 && (
                                                <div className="flex items-center justify-between p-4 bg-yellow-50 rounded-lg border-l-4 border-yellow-500">
                                                    <div>
                                                        <span className="font-semibold text-yellow-800">
                                                            次優選擇: {recommendationData[1]?.label}
                                                        </span>
                                                        <p className="text-sm text-yellow-600 mt-1">
                                                            投資可增傷 {recommendationData[1]?.damageIncrease.toFixed(3)}%
                                                        </p>
                                                    </div>
                                                </div>
                                            )}
                                            <div className="p-4 bg-blue-50 rounded-lg border-l-4 border-blue-500">
                                                <span className="font-semibold text-blue-800">配裝策略建議:</span>
                                                <p className="text-sm text-blue-600 mt-1">
                                                    面對「當前防守方配置」時，優先堆疊 {recommendationData[0]?.label}{" "}
                                                    {recommendationData[1] ? `和 ${recommendationData[1]?.label}` : ""}，
                                                    可以獲得最佳的攻擊效果。
                                                    <>
                                                        <br />
                                                        請注意，各裝備投放屬性數值不一致，推薦只限200點内收益，使用「從零分析」模式可以看到從頭開始配裝的最優方向。
                                                    </>
                                                </p>
                                            </div>
                                        </>
                                    ) : (
                                        <p className="text-sm text-gray-500">正在生成建議，請稍候...</p>
                                    )}
                                </div>
                            </div>

                            {/* 方案列表 */}
                            <div className="mt-6">
                                <h4 className="font-semibold text-base text-gray-800 mb-3 flex items-center">
                                    <span className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></span>
                                    保存的方案
                                </h4>
                                {presets.length === 0 ? (
                                    <p className="text-sm text-gray-500">尚未保存任何方案</p>
                                ) : (
                                    <div className="grid gap-2">
                                        {presets.map((preset, index) => (
                                            <div
                                                key={index}
                                                className="flex items-center justify-between p-3 bg-pink-50 rounded-lg hover:bg-pink-100 transition-colors duration-200"
                                            >
                                                <span className="font-medium text-gray-700">{preset.name}</span>
                                                <div className="flex gap-2">
                                                    <button
                                                        className="text-sm text-green-600 hover:text-green-800 font-medium transition-colors duration-200 flex items-center gap-1"
                                                        onClick={() => loadPreset(index)}
                                                    >
                                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                                                        </svg>
                                                        載入
                                                    </button>
                                                    <button
                                                        className="text-sm text-red-600 hover:text-red-800 font-medium transition-colors duration-200 flex items-center gap-1"
                                                        onClick={() => deletePreset(index)}
                                                    >
                                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                                        </svg>
                                                        刪除
                                                    </button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>

                            {/* 方案對比 */}
                            {presets.length >= 2 && (
                                <div className="mt-6">
                                    <h4 className="font-semibold text-base text-gray-800 mb-3 flex items-center">
                                        <span className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></span>
                                        對比兩個方案
                                    </h4>
                                    <div className="flex flex-col sm:flex-row gap-3 items-start sm:items-center">
                                        <select
                                            className="w-full sm:w-40 border border-gray-300 rounded-lg p-2 text-sm text-gray-700 focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors duration-200"
                                            onChange={(e) => setCompareIndexes((prev) => ({ ...prev, a: e.target.value }))}
                                        >
                                            <option value="">選擇方案</option>
                                            {presets.map((p, i) => (
                                                <option value={i} key={"a" + i}>
                                                    {p.name}
                                                </option>
                                            ))}
                                        </select>
                                        <select
                                            className="w-full sm:w-40 border border-gray-300 rounded-lg p-2 text-sm text-gray-700 focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors duration-200"
                                            onChange={(e) => setCompareIndexes((prev) => ({ ...prev, b: e.target.value }))}
                                        >
                                            <option value="">選擇方案</option>
                                            {presets.map((p, i) => (
                                                <option value={i} key={"b" + i}>
                                                    {p.name}
                                                </option>
                                            ))}
                                        </select>
                                        <button
                                            className="w-full sm:w-auto bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-lg font-medium text-sm transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                                            onClick={comparePresets}
                                            disabled={compareIndexes.a === null || compareIndexes.b === null}
                                        >
                                            開始對比
                                        </button>
                                    </div>
                                    {compareResult && (
                                        <div className="mt-4">
                                            <div className="flex justify-between items-center mb-2">
                                                <h4 className="font-semibold text-base text-gray-800">
                                                    方案對比（B - A）
                                                </h4>
                                                <button
                                                    className="text-sm text-pink-600 hover:text-pink-800 font-medium flex items-center gap-1"
                                                    onClick={() => setIsTableExpanded(!isTableExpanded)}
                                                >
                                                    {isTableExpanded ? (
                                                        <>
                                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 15l7-7 7 7" />
                                                            </svg>
                                                            收起
                                                        </>
                                                    ) : (
                                                        <>
                                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                                                            </svg>
                                                            展開
                                                        </>
                                                    )}
                                                </button>
                                            </div>
                                            {isTableExpanded && (
                                                <div className="overflow-x-auto transition-all duration-300">
                                                    <table className="w-full text-sm border-collapse">
                                                        <thead>
                                                            <tr className="bg-pink-50">
                                                                <th className="border p-2 text-left text-pink-700">
                                                                    項目
                                                                </th>
                                                                <th className="border p-2 text-left text-pink-700">
                                                                    {presets[compareIndexes.a]?.name || "方案 A"}
                                                                </th>
                                                                <th className="border p-2 text-left text-pink-700">
                                                                    {presets[compareIndexes.b]?.name || "方案 B"}
                                                                </th>
                                                                <th className="border p-2 text-left text-pink-700">
                                                                    差異
                                                                </th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            {[
                                                                { key: "D", label: "攻擊" },
                                                                { key: "E", label: "元素攻擊（平均）" },
                                                                { key: "b_d", label: "破防" },
                                                                { key: "R", label: "流派克制" },
                                                                { key: "b_e", label: "忽視元素抗性" },
                                                                { key: "h", label: "命中" },
                                                                { key: "b_s", label: "破盾" },
                                                                { key: "b_c", label: "會心" },
                                                                { key: "d_c", label: "會心傷害" },
                                                                { key: "gamma_2", label: "防禦穿透率" },
                                                                { key: "beta_2", label: "元素穿透率" },
                                                                { key: "elementalDamagePrecentage", label: "元素傷害佔比" },
                                                                { key: "baseDamage", label: "原傷害" },
                                                                { key: "finalDamage", label: "修正後傷害" },
                                                                { key: "totalReduction", label: "實際生效傷害百分比" },
                                                            ].map(({ key, label }) => {
                                                                const aValue =
                                                                    key in presets[compareIndexes.a].data
                                                                        ? presets[compareIndexes.a].data[key]
                                                                        : calculate(presets[compareIndexes.a].data)[key];
                                                                const bValue =
                                                                    key in presets[compareIndexes.b].data
                                                                        ? presets[compareIndexes.b].data[key]
                                                                        : calculate(presets[compareIndexes.b].data)[key];
                                                                const aNum = parseFloat(aValue.replace("%", "")) || 0;
                                                                const bNum = parseFloat(bValue.replace("%", "")) || 0;
                                                                const diff = bNum - aNum;
                                                                const isPositive = diff >= 0;
                                                                return (
                                                                    <tr key={key} className="hover:bg-pink-50">
                                                                        <td className="border p-2 text-gray-700">
                                                                            {label}
                                                                        </td>
                                                                        <td className="border p-2 font-medium">{aValue}</td>
                                                                        <td className="border p-2 font-medium">{bValue}</td>
                                                                        <td
                                                                            className={`border p-2 font-medium ${isPositive ? "text-green-600" : "text-red-600"}`}
                                                                        >
                                                                            {diff >= 0 ? "+" : ""}
                                                                            {diff.toFixed(2)}
                                                                            {key === "totalReduction" ? "%" : ""}
                                                                        </td>
                                                                    </tr>
                                                                );
                                                            })}
                                                        </tbody>
                                                    </table>
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>
                    </div>

                    {/* 投資收益曲線分析 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div className="flex justify-between items-center cursor-pointer mb-2" onClick={() => setShowIncrementalAnalysis(!showIncrementalAnalysis)}>
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">投資收益曲線分析</h2>
                            </div>
                            <span className="text-pink-700 text-lg">{showIncrementalAnalysis ? '▲' : '▼'}</span>
                        </div>
                        <div className={`transition-all duration-500 overflow-hidden ${showIncrementalAnalysis ? 'max-h-[1500px] opacity-100' : 'max-h-0 opacity-0'}`}>
                            <div className="mb-4 p-4 bg-gray-50 rounded-lg">
                                <h3 className="text-sm font-semibold text-gray-700 mb-3">分析模式：</h3>
                                <div className="flex gap-4">
                                    <label className="flex items-center space-x-2 cursor-pointer">
                                        <input
                                            type="radio"
                                            name="analysisMode"
                                            value="incremental"
                                            checked={analysisMode === 'incremental'}
                                            onChange={(e) => setAnalysisMode(e.target.value)}
                                            className="w-4 h-4 text-pink-600"
                                        />
                                        <span className="text-sm">增量分析 (從當前面板繼續投資)</span>
                                    </label>
                                    <label className="flex items-center space-x-2 cursor-pointer">
                                        <input
                                            type="radio"
                                            name="analysisMode"
                                            value="from_zero"
                                            checked={analysisMode === 'from_zero'}
                                            onChange={(e) => setAnalysisMode(e.target.value)}
                                            className="w-4 h-4 text-pink-600"
                                        />
                                        <span className="text-sm">從零分析 (各屬性從0開始堆疊)</span>
                                    </label>
                                </div>
                            </div>
                            <p className="text-sm text-gray-600 mb-4">
                                {analysisMode === 'incremental'
                                    ? '顯示從當前攻擊數值基礎上投入不同點數的增傷效果'
                                    : '顯示各攻擊屬性從0開始投入不同點數的增傷效果（用於新角色配裝規劃）'}
                            </p>
                            <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                                <div className="flex items-center justify-between mb-3">
                                    <h3 className="text-sm font-semibold text-gray-700">選擇要顯示的曲線：</h3>
                                    <div className="flex gap-2">
                                        <button
                                            onClick={handleSelectAll}
                                            className="px-3 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600"
                                        >
                                            全選
                                        </button>
                                        <button
                                            onClick={handleDeselectAll}
                                            className="px-3 py-1 text-xs bg-gray-500 text-white rounded hover:bg-gray-600"
                                        >
                                            全不選
                                        </button>
                                    </div>
                                </div>
                                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                                    {recommendationData.map((attr, index) => (
                                        <label key={attr.attribute} className="flex items-center space-x-2 cursor-pointer">
                                            <input
                                                type="checkbox"
                                                checked={visibility[attr.attribute] || false}
                                                onChange={() => handleCurveToggle(attr.attribute)}
                                                className="w-4 h-4 text-pink-600 rounded focus:ring-pink-500"
                                            />
                                            <div className="flex items-center space-x-2">
                                                <div className="w-3 h-3 rounded-full" style={{ backgroundColor: colors[index % colors.length] }}></div>
                                                <span className="text-sm text-gray-700">{attr.label}</span>
                                            </div>
                                        </label>
                                    ))}
                                </div>
                            </div>
                            {increaseData.length > 0 ? (
                                <ResponsiveContainer width="100%" height={400}>
                                    <LineChart data={increaseData}>
                                        <CartesianGrid strokeDasharray="3 3" />
                                        <XAxis
                                            dataKey="point"
                                            label={{ value: '投入點數', position: 'insideBottom', offset: -5 }}
                                        />
                                        <YAxis
                                            label={{ value: '增傷%', angle: -90, position: 'insideLeft' }}
                                            tickFormatter={(value) => (value * 100).toFixed(2)}
                                        />
                                        <Tooltip
                                            formatter={(value, name) => [
                                                `${(value * 100).toFixed(2)}%`,
                                                recommendationData.find((d) => d.attribute === name)?.label || name,
                                            ]}
                                            labelFormatter={(points) => `投入點數: ${points}`}
                                        />
                                        <Legend />
                                        {recommendationData.map((attr, index) => visibility[attr.attribute] && (
                                            <Line
                                                key={attr.attribute}
                                                type="monotone"
                                                dataKey={attr.attribute}
                                                stroke={colors[index % colors.length]}
                                                strokeWidth={2}
                                                dot={false}
                                                name={attr.label}
                                            />
                                        ))}
                                    </LineChart>
                                </ResponsiveContainer>
                            ) : (
                                <p className="text-sm text-gray-500">正在生成圖表，請稍候...</p>
                            )}
                        </div>
                    </div>

                    {/* 每200點屬性增傷收益 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div className="flex justify-between items-center cursor-pointer mb-2" onClick={() => setShowIncrementalAnalysis(!showIncrementalAnalysis)}>
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">每200點屬性增傷收益</h2>
                            </div>
                            <span className="text-pink-700 text-lg">{showIncrementalAnalysis ? '▲' : '▼'}</span>
                        </div>
                        <div className={`transition-all duration-500 overflow-hidden ${showIncrementalAnalysis ? 'max-h-[1500px] opacity-100' : 'max-h-0 opacity-0'}`}>
                            <div className="flex flex-wrap gap-4 mb-4">
                                {[
                                    { key: 'D', label: '攻擊', color: '#db2537' },
                                    { key: 'E', label: '元素攻擊', color: '#ff6b6b' },
                                    { key: 'R', label: '克制', color: '#14b8a6' },
                                    { key: 'b_d', label: '破防', color: '#3b82f6' },
                                    { key: 'b_e', label: '忽視元素抗性', color: '#10b981' },
                                    { key: 'b_s', label: '破盾', color: '#8b5cf6' },
                                    { key: 'b_c', label: '會心', color: '#f59e0b' },
                                    { key: 'd_c', label: '會心傷害%', color: '#ef4444' },
                                ].map(({ key, label, color }) => (
                                    <label key={key} className="flex items-center">
                                        <input
                                            type="checkbox"
                                            checked={visibility[key]}
                                            onChange={() => toggleVisibility(key)}
                                            className="mr-2"
                                        />
                                        <span style={{ color }}>{label}</span>
                                    </label>
                                ))}
                            </div>
                            <div className="w-full h-[250px] sm:h-[300px] md:h-[350px]">
                                {deltaData.length > 0 ? (
                                    <ResponsiveContainer width="100%" height="100%">
                                        <LineChart data={deltaData}>
                                            <CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
                                            <XAxis
                                                dataKey="point"
                                                label={{ value: '屬性點', position: 'insideBottom', offset: -5, fontSize: 12, fill: '#6b7280' }}
                                                tick={{ fill: '#6b7280', fontSize: 12 }}
                                            />
                                            <YAxis
                                                label={{ value: '每200點收益 (%)', angle: -90, position: 'insideLeft', fontSize: 12, fill: '#6b7280' }}
                                                tickFormatter={(value) => (value * 100).toFixed(4)}
                                                tick={{ fill: '#6b7280', fontSize: 12 }}
                                            />
                                            <Tooltip content={<CustomTooltip isDelta={true} />} />
                                            <Legend wrapperStyle={{ fontSize: 12 }} />
                                            {visibility.D && (
                                                <Line type="monotone" dataKey="D" name="攻擊" stroke="#db2537" strokeWidth={2} dot={false} />
                                            )}
                                            {visibility.E && (
                                                <Line type="monotone" dataKey="E" name="元素攻擊" stroke="#ff6b6b" strokeWidth={2} dot={false} />
                                            )}
                                            {visibility.R && (
                                                <Line type="monotone" dataKey="R" name="克制" stroke="#14b8a6" strokeWidth={2} dot={false} />
                                            )}
                                            {visibility.b_d && (
                                                <Line type="monotone" dataKey="b_d" name="破防" stroke="#3b82f6" strokeWidth={2} dot={false} />
                                            )}
                                            {visibility.b_e && (
                                                <Line type="monotone" dataKey="b_e" name="忽視元素抗性" stroke="#10b981" strokeWidth={2} dot={false} />
                                            )}
                                            {visibility.b_s && (
                                                <Line type="monotone" dataKey="b_s" name="破盾" stroke="#8b5cf6" strokeWidth={2} dot={false} />
                                            )}
                                            {visibility.b_c && (
                                                <Line type="monotone" dataKey="b_c" name="會心" stroke="#f59e0b" strokeWidth={2} dot={false} />
                                            )}
                                            {visibility.d_c && (
                                                <Line type="monotone" dataKey="d_c" name="會心傷害%" stroke="#ef4444" strokeWidth={2} dot={false} />
                                            )}
                                        </LineChart>
                                    </ResponsiveContainer>
                                ) : (
                                    <p className="text-sm text-gray-500">正在生成圖表，請稍候...</p>
                                )}
                            </div>
                        </div>
                    </div>

                    <div className="text-center text-xs text-gray-500 mb-4">
                        <p>攻擊計算器 © {new Date().getFullYear()} | 數據僅供參考</p>
                    </div>
                </div>
            );
        };

        // Footer Component
        const Footer = () => {
            return (
                <footer className="bg-transparent text-gray-700 p-4 text-center mt-6">
                    <div className="max-w-3xl mx-auto text-sm text-center">
                        <p className="font-semibold mb-1">櫻桃碎碎念</p>
                        <p>
                            公式參考了
                            <a
                                href="https://m.bilibili.com/opus/979579497904865287"
                                target="_blank"
                                rel="noopener noreferrer"
                                className="text-cherry-600 hover:underline"
                            >
                                折字愿为安
                            </a>
                            和
                            <a
                                href="https://b23.tv/C4Iq2IZ"
                                target="_blank"
                                rel="noopener noreferrer"
                                className="text-cherry-600 hover:underline"
                            >
                                进团先发秒伤
                            </a>
                            兩位老師的專欄。經過驗證適用於台服目前版本。考慮到很多人不太喜歡數學，所以才整合成計算器。本來還想加上對塔傷害部分，但因為我一個人難以驗證，結果還是放棄了。後續可能大概還會更新內功和周天，可能吧我也不知道。
                        </p>
                    </div>
                </footer>
            );
        };

        // App Component
        const App = () => {
            const [activeCalculator, setActiveCalculator] = useState(null);

            return (
                <div className="flex min-h-screen flex-col">
                    <div className="flex flex-1">
                        <Sidebar setActiveCalculator={setActiveCalculator} />
                        <div className="flex-1 md:ml-64">
                            {!activeCalculator ? (
                                <HomeMenu setActiveCalculator={setActiveCalculator} />
                            ) : activeCalculator === 'damage' ? (
                                <DamageCalculator />
                            ) : activeCalculator === 'healing' ? (
                                <HealingCalculator />
                            ) : (
                                <DamageCalculator2 />
                            )}
                        </div>
                    </div>
                    <Footer />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById("root"));
        root.render(<App />);

    </script>


</body>

</html>
