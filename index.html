<html lang="zh-TW">

<head>
    <script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
            return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
            if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
                try {
                    var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                    var firstSheetName = workbook.SheetNames[0];
                    var worksheet = workbook.Sheets[firstSheetName];

                    // Convert sheet to JSON to filter blank rows
                    var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                    // Filter out blank rows (rows where all cells are empty, null, or undefined)
                    var filteredData = jsonData.filter(row => row.some(filledCell));

                    // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                    var headerRowIndex = filteredData.findIndex((row, index) =>
                        row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                    );
                    // Fallback
                    if (headerRowIndex === -1 || headerRowIndex > 25) {
                        headerRowIndex = 0;
                    }

                    // Convert filtered JSON back to CSV
                    var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                    csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                    return csv;
                } catch (e) {
                    console.error(e);
                    return "";
                }
            }
            return gk_fileData[filename] || "";
        }
    </script>




    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>遊戲計算器</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/core-js/3.38.1/minified.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-latest/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/recharts@2.12.7/umd/Recharts.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        cherry: {
                            50: '#fff0f6',
                            100: '#ffd6e7',
                            200: '#ffadd2',
                            300: '#ff85b8',
                            400: '#f75998',
                            500: '#eb2f7a',
                            600: '#c41d5d',
                            700: '#9e1045',
                            800: '#78062f',
                            900: '#52001d',
                        },
                        chart: {
                            blue: '#3b82f6',
                            green: '#10b981',
                            purple: '#8b5cf6',
                            teal: '#14b8a6',
                            orange: '#f97316',
                        }
                    }
                }
            }
        }
    </script>
    <script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
            return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
            if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
                try {
                    var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                    var firstSheetName = workbook.SheetNames[0];
                    var worksheet = workbook.Sheets[firstSheetName];
                    var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                    var filteredData = jsonData.filter(row => row.some(filledCell));
                    var headerRowIndex = filteredData.findIndex((row, index) =>
                        row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                    );
                    if (headerRowIndex === -1 || headerRowIndex > 25) {
                        headerRowIndex = 0;
                    }
                    var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                    csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                    return csv;
                } catch (e) {
                    console.error(e);
                    return "";
                }
            }
            return gk_fileData[filename] || "";
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');

        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #fff0f6;
            margin: 0;
            padding: 0;
        }

        .input-focus:focus {
            border-color: #eb2f7a;
            box-shadow: 0 0 0 3px rgba(235, 47, 122, 0.2);
            outline: none;
        }

        .cherry-gradient {
            background: linear-gradient(135deg, #ffd6e7 0%, #eb2f7a 100%);
        }

        .result-card {
            transition: all 0.3s ease;
        }

        .result-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(235, 47, 122, 0.1);
        }

        .scrollbar-cherry::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .scrollbar-cherry::-webkit-scrollbar-track {
            background: #ffd6e7;
        }

        .scrollbar-cherry::-webkit-scrollbar-thumb {
            background-color: #eb2f7a;
            border-radius: 20px;
        }

        .tooltip-hidden {
            display: none;
        }

        .group:hover .tooltip-hidden,
        .group:active .tooltip-hidden {
            display: block;
        }

        @media (max-width: 640px) {
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.125rem;
            }

            input,
            button,
            select {
                font-size: 0.875rem;
                padding: 0.5rem;
            }
        }
    </style>
</head>

<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect } = React;

        const {
            LineChart,
            Line,
            XAxis,
            YAxis,
            CartesianGrid,
            Tooltip,
            Legend,
            ResponsiveContainer,
        } = Recharts;

        // ============= 實戰命中率計算核心函數 =============
        const calculatePracticalHitRate = (h, b_b) => {
            const C_BASE = 9250.0;
            const C_SCALAR = 1.3;
            const PRIMARY_BASE = 0.98;
            const PRIMARY_SCALE = 1.73;
            const THRESHOLD = 0.40;
            const FLOOR_BASE = 0.309;
            const FLOOR_SCALE = -0.000035;  // ✅ 修正：应该是5个零，不是3个零

            const d = h - b_b;
            const C_eff = C_BASE - C_SCALAR * b_b;

            let denominator = d + C_eff;
            if (denominator === 0) {
                denominator = 0.0001;
            }

            const raw_hit_rate = PRIMARY_BASE + PRIMARY_SCALE * (d / denominator);

            if (raw_hit_rate >= THRESHOLD) {
                return {
                    hitRate: Math.min(1, Math.max(0, raw_hit_rate)),
                    mode: "NORMAL"
                };
            } else {
                return {
                    hitRate: Math.min(1, Math.max(0, FLOOR_BASE + FLOOR_SCALE * d)),
                    mode: "FLOOR_ACTIVE"
                };
            }
        };

        // ============= 新的官方預測公式 =============
        const calculateOfficialHitRate = (h, b_b) => {
            const d = h - b_b;
            const hit_rate = 0.95 + 1.419 * (d / (3640 + d));
            return Math.min(1, Math.max(0, hit_rate));
        };

        // Sidebar Component
        const Sidebar = ({ setActiveCalculator }) => {
            const [isOpen, setIsOpen] = useState(false);

            return (
                <>
                    <button
                        className="md:hidden fixed top-4 left-4 z-50 text-cherry-800 p-2 rounded-full bg-cherry-100 hover:bg-cherry-200"
                        onClick={() => setIsOpen(!isOpen)}
                        aria-label="展開側邊欄"
                    >
                        <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16m-7 6h7" />
                        </svg>
                    </button>
                    <div
                        className={`fixed top-0 left-0 h-full bg-cherry-50 w-64 transform ${isOpen ? 'translate-x-0' : '-translate-x-full'
                            } md:translate-x-0 transition-transform duration-300 ease-in-out z-40 shadow-lg`}
                    >
                        <div className="p-4">
                            <h2 className="text-lg font-bold text-cherry-800">計算器</h2>
                            <nav className="mt-4 space-y-2">
                                <button
                                    onClick={() => { setActiveCalculator('damage'); setIsOpen(false); }}
                                    className="block w-full text-left py-2 px-4 text-cherry-700 hover:bg-cherry-100 rounded-lg transition-colors"
                                >
                                    防守計算器
                                </button>
                                <button
                                    onClick={() => { setActiveCalculator('healing'); setIsOpen(false); }}
                                    className="block w-full text-left py-2 px-4 text-cherry-700 hover:bg-cherry-100 rounded-lg transition-colors"
                                >
                                    治療強度計算
                                </button>
                                <button
                                    onClick={() => { setActiveCalculator('damage_2'); setIsOpen(false); }}
                                    className="block w-full text-left py-2 px-4 text-cherry-700 hover:bg-cherry-100 rounded-lg transition-colors"
                                >
                                    攻擊計算器
                                </button>
                            </nav>
                        </div>
                    </div>
                    {isOpen && (
                        <div
                            className="fixed inset-0 bg-black bg-opacity-50 md:hidden z-30"
                            onClick={() => setIsOpen(false)}
                        ></div>
                    )}
                </>
            );
        };

        const HomeMenu = () => {
            const [activeCalculator, setActiveCalculator] = useState(null);

            useEffect(() => {
                // 初次載入跳出提醒
                alert(
                    '⚠️ 1 計算器非最終傷害，僅作面板屬性收益計算之用\n' +
                    '⚠️ 2 僅 PVP 適用，PVE 請自己打木樁測試，1.3版本命中公式已更新\n' +
                    '⚠️ 3 圖片識別使用免費資源，準確度堪憂，建議手動輸入\n' +
                    '⚠️ 4 有問題可聯絡 ID 櫻桃白蘭地，會擺爛式修正'
                );
            }, []);

            // 首頁選單
            if (!activeCalculator) {
                return (
                    <div className="min-h-screen flex flex-col items-center justify-center px-4">
                        <h1 className="text-3xl font-bold text-cherry-800 mb-8">屬性收益分析計算器</h1>
                        <div className="grid grid-cols-1 sm:grid-cols-3 gap-6 w-full max-w-4xl">
                            <button
                                onClick={() => setActiveCalculator('damage')}
                                className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition result-card"
                            >
                                防守計算器
                            </button>
                            <button
                                onClick={() => setActiveCalculator('healing')}
                                className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition result-card"
                            >
                                治療強度計算
                            </button>
                            <button
                                onClick={() => setActiveCalculator('damage_2')}
                                className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition result-card"
                            >
                                攻擊計算器
                            </button>
                        </div>
                    </div>
                );
            }

            // 根據選擇渲染對應的計算器
            return (
                <>
                    <Sidebar setActiveCalculator={setActiveCalculator} />
                    {activeCalculator === 'damage' && <div><DamageCalculator /></div>}
                    {activeCalculator === 'healing' && <div><HealingCalculator /></div>}
                    {activeCalculator === 'damage_2' && <div><DamageCalculator2 /></div>}
                </>
            );
        };


        // ImageUploader Component
        const ImageUploader = ({ setInputs, type }) => {
            const [uploadedImages, setUploadedImages] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [progress, setProgress] = useState(0);
            const [error, setError] = useState(null);

            const handleImageUpload = (event) => {
                const files = Array.from(event.target.files).slice(0, 5); // 限制最多5張圖片
                if (files.length > 0) {
                    setUploadedImages(files);
                    setError(null);
                }
            };

            const preprocessImage = (file) => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.src = URL.createObjectURL(file);
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const MAX_SIZE = 1280;
                        let { width, height } = img;
                        if (width > MAX_SIZE || height > MAX_SIZE) {
                            const ratio = Math.min(MAX_SIZE / width, MAX_SIZE / height);
                            width *= ratio;
                            height *= ratio;
                        }
                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);

                        // Grayscale and binarization
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        for (let i = 0; i < data.length; i += 4) {
                            const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                            const binary = avg > 128 ? 255 : 0;
                            data[i] = data[i + 1] = data[i + 2] = binary;
                        }
                        ctx.putImageData(imageData, 0, 0);

                        canvas.toBlob((blob) => {
                            resolve(blob);
                        }, 'image/png');
                    };
                    img.onerror = () => {
                        setError('圖像加載失敗，請檢查文件格式');
                        resolve(file);
                    };
                });
            };

            const startRecognition = async () => {
                if (uploadedImages.length === 0) return;

                setIsProcessing(true);
                setProgress(0);
                setError(null);

                let combinedValues = {};

                for (let i = 0; i < uploadedImages.length; i++) {
                    const file = uploadedImages[i];
                    try {
                        const processedImage = await preprocessImage(file);

                        const { data: { text } } = await Tesseract.recognize(
                            processedImage,
                            'chi_tra+eng',
                            {
                                logger: m => {
                                    if (m.status === 'recognizing text') {
                                        setProgress(Math.round((i / uploadedImages.length + m.progress / uploadedImages.length) * 100));
                                    }
                                }
                            }
                        );

                        const values = parseText(text, type);
                        if (Object.keys(values).length === 0) {
                            setError(`圖片 ${file.name} 未能識別到有效數據，請確保圖片清晰且包含屬性文字`);
                        }
                        combinedValues = { ...combinedValues, ...values };

                    } catch (error) {
                        console.error(`處理圖片 ${file.name} 時出錯：`, error);
                        setError(`處理圖片 ${file.name} 時出錯：${error.message}`);
                    }
                }

                if (Object.keys(combinedValues).length > 0) {
                    setInputs(prev => ({ ...prev, ...combinedValues }));
                }
                setIsProcessing(false);
                setProgress(0);
            };

            const parseText = (text, type) => {
                const values = {};
                const regex = /([\u4e00-\u9fa5]+[\u4e00-\u9fa5\s：:]*)\s*[：:]*\s*([\d.,\/%-]+(?:\s*-\s*\d+)?)/g;
                let match;

                while ((match = regex.exec(text)) !== null) {
                    const label = match[1].trim().replace(/\s+/g, '');
                    let value = match[2].replace(/[,]/g, '').replace('%', '');

                    if (type === 'attacker') {
                        if (label.includes('技能倍率')) values.skill_multiplier = value;
                        if (label.includes('攻擊') && !label.includes('元素攻擊') && !label.includes('攻擊%')) {
                            const [low] = value.split('-').map(Number);
                            values.D = low.toString();
                        }
                        if (label.includes('元素攻擊')) values.E = value;
                        if (label.includes('會心數值') || (label.includes('會心') && !label.includes('會心傷害') && !label.includes('會心防禦'))) {
                            values.b_c = value;
                        }
                        if (label.includes('會心傷害')) {
                            values.d_c = (parseFloat(value) / 100).toString();
                        }
                        if (label.includes('流派克制') && !label.includes('流派克制%')) {
                            const [baseValue] = value.split('/').map(v => v.trim());
                            values.R = baseValue;
                        }
                        if (label.includes('流派克制%')) {
                            const [, percentValue] = value.split('/').map(v => parseFloat(v));
                            values.flow_percent = (percentValue / 100).toString();
                        }
                        if (label.includes('命中')) values.h = value;
                        if (label.includes('破防')) values.b_d = value;
                        if (label.includes('破盾')) values.b_s = value;
                        if (label.includes('忽視元素抗性')) values.b_e = value;
                        if (label.includes('增傷')) {
                            values.damage_increase = (parseFloat(value) / 100).toString();
                        }
                        if (label.includes('技能增傷')) {
                            values.skill_damage_increase = (parseFloat(value) / 100).toString();
                        }
                        if (label.includes('金周天')) {
                            if (value.includes('1級') || value.includes('1')) values.gold_i = '0.03';
                            else if (value.includes('2級') || value.includes('2')) values.gold_i = '0.04';
                            else if (value.includes('3級') || value.includes('3')) values.gold_i = '0.05';
                            else values.gold_i = '0';
                        }
                    } else if (type === 'defender') {
                        if (label.includes('氣血')) values.hp = value.split('/')[0];
                        if (label.includes('防禦')) values.d_d = value;
                        if (label.includes('抗會心數值') || (label.includes('會心') && !label.includes('會心傷害') && !label.includes('會心防禦'))) {
                            values.b_c_defense = value;
                        }
                        if (label.includes('會心防禦')) {
                            values.d_c_defense = (parseFloat(value) / 100).toString();
                        }
                        if (label.includes('格擋')) values.b_b = value;
                        if (label.includes('元素抗性')) values.d_e = value;
                        if (label.includes('傷害減免')) {
                            values.damage_reduction = (parseFloat(value) / 100).toString();
                        }
                        if (label.includes('流派抵禦') && !label.includes('流派抵禦%')) {
                            const [baseValue] = value.split('/').map(v => v.trim());
                            values.d_f = baseValue;
                        }
                        if (label.includes('流派抵禦%')) {
                            const [, percentValue] = value.split('/').map(v => parseFloat(v));
                            values.flow_resist_percent = (percentValue / 100).toString();
                        }
                        if (label.includes('怪物克制')) {
                            const [, second] = value.split('/').map(v => parseFloat(v));
                            values.flow_resist_percent = (second / 100).toString();
                        }
                        if (label.includes('氣盾')) values.d_s = value;
                        if (label.includes('技能減免')) values.skill_damage_reduction = (parseFloat(value) / 100).toString();
                    }

                    if (label.includes('破防')) values.armor_break = value;
                    if (label.includes('命中')) values.hit = value;
                    if (label.includes('元素攻擊')) values.elemental_attack = value;
                    if (label.includes('首領克制')) {
                        const [first] = value.split('/').map(v => parseFloat(v));
                        values.boss_restraint = first.toString();
                    }
                    if (label.includes('流派克制')) {
                        const [first, second] = value.split('/').map(v => parseFloat(v));
                        values.faction_restraint = Math.max(first, second).toString();
                    }
                    if (label.includes('抗性忽視')) values.resistance_ignore = value;
                    if (label.includes('治療強度')) values.healing_power_equip = value;
                }
                return values;
            };

            return (
                <div className="mb-4">
                    <label className="block mb-2 text-sm font-medium text-gray-700">
                        {type === 'attacker' ? '上傳攻擊方截圖' : type === 'defender' ? '上傳防守方截圖' : '上傳截圖'}
                    </label>
                    <input
                        type="file"
                        accept="image/*"
                        onChange={handleImageUpload}
                        multiple
                        className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-cherry-500 file:text-white hover:file:bg-cherry-600"
                    />
                    {error && (
                        <p className="mt-2 text-sm text-red-600">{error}</p>
                    )}
                    {uploadedImages.length > 0 && (
                        <div className="mt-2 flex items-center space-x-2">
                            <p className="text-xs text-gray-500">已選 {uploadedImages.length} 張圖片</p>
                            <button
                                onClick={startRecognition}
                                disabled={isProcessing}
                                className="bg-cherry-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-cherry-700 disabled:bg-cherry-300 transition-colors"
                            >
                                {isProcessing ? `識別中... ${progress}%` : '開始識別'}
                            </button>
                        </div>
                    )}
                    {isProcessing && (
                        <div className="mt-2 w-full bg-gray-200 rounded-full h-2.5">
                            <div
                                className="bg-cherry-600 h-2.5 rounded-full transition-all duration-300"
                                style={{ width: `${progress}%` }}
                            ></div>
                        </div>
                    )}
                </div>
            );
        };

        //治療計算機-更新

        const HealingCalculator = () => {
            const [inputs, setInputs] = useState({
                armor_break: "0",
                hit: "0",
                elemental_attack: "0",
                boss_restraint: "0",
                faction_restraint: "0",
                resistance_ignore: "0",
                healing_power_equip: "0",
                max_attack: "6032",
                min_attack: "6032",
                crit: "1460",
                crit_damage: "190",
                healing_power: "5141",
                skill_level: "21",
                gold_i: "0",
                water_constellation: "0.06",
                faction_skills: "0.30",
                permanent_skill: "0.05",
                skill_type: "chuzhan",
                custom_permanent_skill: "0",
                healing_decrease: "0",
                skill_increase: "0"
            });

            const [inputErrors, setInputErrors] = useState({});
            const [showThresholdCalculator, setShowThresholdCalculator] = useState(true);
            const [showHealingCalculator, setShowHealingCalculator] = useState(true);
            const [showInvestmentAnalysis, setShowInvestmentAnalysis] = useState(true);
            const [showIncrementalAnalysis, setShowIncrementalAnalysis] = useState(true);
            const [analysisMode, setAnalysisMode] = useState('incremental');
            const [visibility, setVisibility] = useState({
                max_attack: true,
                healing_power: true,
                crit: true,
                crit_damage: true,
            });
            const [investmentPoints, setInvestmentPoints] = useState({
                max_attack: 200,
                healing_power: 200,
                crit: 200,
                crit_damage: 10,
            });
            const [recommendationData, setRecommendationData] = useState([]);

            const goldOptions = [
                { value: '0', label: '無金周天' },
                { value: '0.03', label: '金周天1級' },
                { value: '0.04', label: '金周天2級' },
                { value: '0.05', label: '金周天3級' },
            ];

            const waterConstellationOptions = [
                { value: '0', label: '無水周天' },
                { value: '0.04', label: '水周天1級 4%' },
                { value: '0.05', label: '水周天2級 5%' },
                { value: '0.06', label: '水周天3級 6%' },
            ];

            const factionSkillsOptions = [
                { value: '0', label: '無流派技能' },
                { value: '0.05', label: '一個 5%' },
                { value: '0.10', label: '兩個 10%' },
                { value: '0.15', label: '三個 15%' },
                { value: '0.20', label: '四個 20%' },
                { value: '0.30', label: '五個 30%' },
            ];

            const permanentSkillOptions = [
                { value: '0', label: '無常駐内功' },
                { value: '0.05', label: '内功日月 5%' },
                { value: 'custom', label: '其他（可輸入）' },
            ];

            const skillIncreaseOptions = [
                { value: '0', label: '無技能增强' },
                { value: 'singleskillincrease', label: '單體技能增强' },
                { value: 'AOEskillincrease', label: '群體技能增强' },
                { value: 'baofaskillincrease', label: '爆發技能增强' },
                { value: 'continuousskillincrease', label: '持續技能增强' },
            ];

            const skillTypeOptions = [
                { value: 'chuzhan', label: '初綻(化境) - 爆發治療', tag: '爆發' },
                { value: 'fufeng', label: '扶風(化境) - 每秒群體治療-5秒', tag: '群體' },
                { value: 'qingfeng', label: '清風垂露(化境) - 初始群體治療+持續每3秒治療-10分鐘', tag: '持續' },
                { value: 'caiyi', label: '彩翼(化境) - 初始群體治療+持續每秒治療-7秒', tag: '群體' },
                { value: 'pingA', label: '點絳(化境) - 平A', tag: '單體' },
                { value: 'beidongqun', label: '蝶戀花·夢染 - 被動群體治療', tag: '群體' },
            ];

            const skillTagToIncreaseMap = {
                '單體': 'singleskillincrease',
                '群體': 'AOEskillincrease',
                '爆發': 'baofaskillincrease',
                '持續': 'continuousskillincrease',
            };

            const colors = [
                '#3b82f6', '#10b981', '#8b5cf6', '#14b8a6', '#f97316', '#d084d0'
            ];

            const handleChange = (e) => {
                const { name, value } = e.target;
                if (['gold_i', 'water_constellation', 'faction_skills', 'permanent_skill', 'skill_type'].includes(name)) {
                    setInputs((prev) => ({ ...prev, [name]: value }));
                    setInputErrors((prev) => ({ ...prev, [name]: '' }));
                } else {
                    if (value < 0) {
                        setInputErrors((prev) => ({ ...prev, [name]: '輸入值不能為負數' }));
                        return;
                    }
                    if (value > 1000000) {
                        setInputErrors((prev) => ({ ...prev, [name]: '輸入值過大，最大為1000000' }));
                        return;
                    }
                    setInputs((prev) => ({ ...prev, [name]: value }));
                    setInputErrors((prev) => ({ ...prev, [name]: '' }));
                }
            };

            const toNum = (val) => parseFloat(val) || 0;

            // 获取技能参数
            const getSkillParams = (skillType) => {
                const skillParams = {
                    chuzhan: {
                        initialMultiplier: 3.66,
                        continuousMultiplier: 0,
                        targetMultiplier: 0,
                        selfMultiplier: 0,
                        lamer1: 81,
                        lamer2: 291.64,
                        skillBonus: 0,
                        guangEffect: 0.18,
                        description: '初綻(化境)',
                        hasLuoxia: true,
                        type: 'burst',
                        displayName: '爆發治療(366%)',
                        hasSkillIncrease: false
                    },
                    fufeng: {
                        initialMultiplier: 0,
                        continuousMultiplier: 0.79,
                        continuousInterval: 1,
                        targetMultiplier: 0,
                        selfMultiplier: 0,
                        lamer1: 25,
                        lamer2: 1131.4,
                        skillBonus: 0.1,
                        guangEffect: 0,
                        description: '扶風(化境)',
                        hasLuoxia: true,
                        type: 'continuous',
                        displayName: '持續治療(79%/秒)',
                        hasSkillIncrease: true
                    },
                    qingfeng: {
                        initialMultiplier: 0.75,
                        continuousMultiplier: 0.31,
                        continuousInterval: 3,
                        targetMultiplier: 0,
                        selfMultiplier: 0,
                        lamer1_initial: 35,
                        lamer2_initial: 185.4,
                        lamer1_continuous: 35,
                        lamer2_continuous: 85.1,
                        skillBonus: 0.1,
                        guangEffect: 0,
                        description: '清風垂露(化境)',
                        hasLuoxia: true,
                        type: 'mixed',
                        initialDisplayName: '初始群體治療(75%)',
                        continuousDisplayName: '持續治療(31%/3秒)',
                        hasSkillIncrease: false
                    },
                    caiyi: {
                        initialMultiplier: 1.0,
                        continuousMultiplier: 0.25,
                        continuousInterval: 1,
                        targetMultiplier: 0,
                        selfMultiplier: 0,
                        lamer1: 40,
                        lamer2: 1411.8,
                        skillBonus: 0.1,
                        guangEffect: 0,
                        description: '彩翼(化境)',
                        hasLuoxia: false,
                        type: 'mixed',
                        initialDisplayName: '初始治療(100%)',
                        continuousDisplayName: '持續治療(25%/秒)',
                        hasSkillIncrease: true
                    },
                    pingA: {
                        initialMultiplier: 0,
                        continuousMultiplier: 0,
                        targetMultiplier: 0.31,
                        selfMultiplier: 0.52,
                        lamer1_target: 28,
                        lamer2_target: 25.3,
                        lamer1_self: 41,
                        lamer2_self: 39.4,
                        skillBonus: 0.1,
                        guangEffect: 0,
                        description: '點絳(化境)',
                        hasLuoxia: true,
                        type: 'split',
                        targetDisplayName: '對目標治療(31%)',
                        selfDisplayName: '對自身治療(52%)',
                        hasSkillIncrease: false
                    },
                    beidongqun: {
                        initialMultiplier: 0.81,
                        continuousMultiplier: 0,
                        targetMultiplier: 0,
                        selfMultiplier: 0,
                        fixedCoefficient: 300.7,
                        skillBonus: 0,
                        guangEffect: 0,
                        description: '蝶戀花·夢染',
                        hasLuoxia: false,
                        type: 'burst',
                        displayName: '被動群體治療(81%)',
                        hasSkillIncrease: true
                    },
                };
                return skillParams[skillType] || skillParams.chuzhan;
            };

            // 原有的治疗强度阈值转换计算
            const calculateThresholdHealing = () => {
                const {
                    armor_break, hit, elemental_attack, boss_restraint, faction_restraint, resistance_ignore, healing_power_equip
                } = inputs;

                const attributeConversion = (
                    (toNum(armor_break) * 3 / 1000) +
                    (toNum(hit) * 9 / 1000) +
                    (toNum(elemental_attack) * 7 / 1000) +
                    (toNum(boss_restraint) * 3 / 1000) +
                    (toNum(faction_restraint) * 3 / 1000) +
                    (toNum(resistance_ignore) * 9 / 1000)
                );

                const healingPower = Math.floor(attributeConversion) * 100 + toNum(healing_power_equip) + 622;

                return {
                    attributeConversion: attributeConversion.toFixed(2),
                    healingPower: healingPower.toFixed(0)
                };
            };

            // 新的治疗量计算
            const calculateHealing = () => {
                const {
                    max_attack, min_attack, crit, crit_damage, healing_power, skill_level,
                    gold_i, water_constellation, faction_skills, permanent_skill, skill_type, healing_decrease, skill_increase
                } = inputs;

                const skillParams = getSkillParams(skill_type);

                // 面板攻击
                const panelAttack = (toNum(max_attack) + toNum(min_attack)) / 2;
                const maxAttack = toNum(max_attack);
                const minAttack = toNum(min_attack);

                // 技能增強值計算
                let skillIncreaseValue = 0;
                if (skillParams.hasSkillIncrease) {
                    const selectedSkill = skillTypeOptions.find(skill => skill.value === inputs.skill_type);
                    if (selectedSkill && inputs.skill_increase !== '0') {
                        if (skillTagToIncreaseMap[selectedSkill.tag] === inputs.skill_increase) {
                            skillIncreaseValue = toNum(inputs.skill_increase_value);
                        }
                    }
                }

                // 治疗倍率
                let permanentSkillValue = toNum(permanent_skill);
                if (inputs.permanent_skill === 'custom') {
                    permanentSkillValue = toNum(inputs.custom_permanent_skill) / 100;
                }
                const skillHealingBonus = skillParams.skillBonus;
                const healingMultiplier = 1 + toNum(water_constellation) + toNum(faction_skills) + permanentSkillValue + skillHealingBonus;

                // 会心率计算
                const c = toNum(crit);
                const critRateBase = 0.0001942440983381886 * c + 0.15402923129921037;
                const critRate = Math.min(1, Math.max(0, critRateBase + toNum(gold_i)));

                // 会心伤害计算
                const critDamageMultiplier = (toNum(crit_damage) / 100 - 1) / 2 + 1;

                // 减疗影响
                const decreaseMultiplier = (1 - toNum(healing_decrease) / 100);

                // 技能系数计算函数
                const calculateSkillCoefficient = (lamer1, lamer2, isFixed = false) => {
                    if (isFixed) {
                        return lamer2; // 对于固定系数，lamer2存储固定值
                    }
                    return lamer1 * toNum(skill_level) - lamer2;
                };

                // 基础治疗计算函数
                const calculateBaseHealing = (attack, multiplier, skillCoeff) => {
                    return ((attack + toNum(healing_power) + skillCoeff + skillIncreaseValue) * multiplier * healingMultiplier) * decreaseMultiplier;
                };

                // 计算单个部分的治疗数据
                const calculateHealingPart = (attack, multiplier, displayName, lamer1, lamer2, isFixed = false) => {
                    const skillCoeff = calculateSkillCoefficient(lamer1, lamer2, isFixed);

                    const panelHealing = calculateBaseHealing((toNum(max_attack) + toNum(min_attack)) / 2, multiplier, skillCoeff);
                    const maxHealing = calculateBaseHealing(toNum(max_attack), multiplier, skillCoeff);
                    const minHealing = calculateBaseHealing(toNum(min_attack), multiplier, skillCoeff);
                    const critPanelHealing = panelHealing * critDamageMultiplier;
                    const critMaxHealing = maxHealing * critDamageMultiplier;
                    const critMinHealing = minHealing * critDamageMultiplier;
                    const averageHealing = (1 - critRate) * panelHealing + critRate * critPanelHealing;

                    return {
                        displayName,
                        multiplierPercent: (multiplier * 100).toFixed(0) + '%',
                        panelHealing: panelHealing.toFixed(0),
                        maxHealing: maxHealing.toFixed(0),
                        minHealing: minHealing.toFixed(0),
                        critPanelHealing: critPanelHealing.toFixed(0),
                        critMaxHealing: critMaxHealing.toFixed(0),
                        critMinHealing: critMinHealing.toFixed(0),
                        averageHealing: averageHealing.toFixed(0),
                        luoxiaHealing: skillParams.hasLuoxia ? (averageHealing * 0.18).toFixed(0) : null,
                        skillCoefficient: skillCoeff.toFixed(1)
                    };
                };

                let result = {
                    panelAttack: panelAttack.toFixed(0),
                    maxAttack: maxAttack.toFixed(0),
                    minAttack: minAttack.toFixed(0),
                    skillCoefficient: "多套参数",
                    healingMultiplier: healingMultiplier.toFixed(3),
                    skillHealingBonus: (skillHealingBonus * 100).toFixed(0),
                    critRate: (critRate * 100).toFixed(2),
                    critDamageMultiplier: critDamageMultiplier.toFixed(3),
                    critTotalMultiplier: (critRate * critDamageMultiplier + (1 - critRate)).toFixed(3),
                    skillDescription: skillParams.description,
                    hasLuoxia: skillParams.hasLuoxia,
                    skillType: skillParams.type,
                    guangEffect: skillParams.guangEffect,
                    healingParts: []
                };

                // 根据技能类型计算治疗部分
                if (skillParams.type === 'burst') {
                    if (skillParams.fixedCoefficient !== undefined) {
                        // 蝶恋花·梦染等固定系数技能
                        result.healingParts.push(
                            calculateHealingPart(panelAttack, skillParams.initialMultiplier, skillParams.displayName, 0, skillParams.fixedCoefficient, true)
                        );
                    } else {
                        // 初绽等普通技能
                        result.healingParts.push(
                            calculateHealingPart(panelAttack, skillParams.initialMultiplier, skillParams.displayName, skillParams.lamer1, skillParams.lamer2)
                        );
                    }

                    // 霞光效果（初绽特有）
                    if (skillParams.guangEffect > 0) {
                        const totalAverage = parseFloat(result.healingParts[0].averageHealing);
                        result.guangHealing = (totalAverage * skillParams.guangEffect).toFixed(0);
                    }

                } else if (skillParams.type === 'continuous') {
                    // 扶风等持续技能
                    result.healingParts.push(
                        calculateHealingPart(panelAttack, skillParams.continuousMultiplier, skillParams.displayName, skillParams.lamer1, skillParams.lamer2)
                    );

                } else if (skillParams.type === 'mixed') {
                    if (skillParams.lamer1_initial !== undefined) {
                        // 清风垂露 - 使用不同的初始和持续参数
                        result.healingParts.push(
                            calculateHealingPart(panelAttack, skillParams.initialMultiplier, skillParams.initialDisplayName, skillParams.lamer1_initial, skillParams.lamer2_initial)
                        );
                        result.healingParts.push(
                            calculateHealingPart(panelAttack, skillParams.continuousMultiplier, skillParams.continuousDisplayName, skillParams.lamer1_continuous, skillParams.lamer2_continuous)
                        );
                    } else {
                        // 彩翼等其他混合技能 - 使用相同参数
                        result.healingParts.push(
                            calculateHealingPart(panelAttack, skillParams.initialMultiplier, skillParams.initialDisplayName, skillParams.lamer1, skillParams.lamer2)
                        );
                        result.healingParts.push(
                            calculateHealingPart(panelAttack, skillParams.continuousMultiplier, skillParams.continuousDisplayName, skillParams.lamer1, skillParams.lamer2)
                        );
                    }

                } else if (skillParams.type === 'split') {
                    // 点绛 - 使用不同的目标和自身参数
                    result.healingParts.push(
                        calculateHealingPart(panelAttack, skillParams.targetMultiplier, skillParams.targetDisplayName, skillParams.lamer1_target, skillParams.lamer2_target)
                    );
                    result.healingParts.push(
                        calculateHealingPart(panelAttack, skillParams.selfMultiplier, skillParams.selfDisplayName, skillParams.lamer1_self, skillParams.lamer2_self)
                    );
                }

                // 计算总平均治疗量
                const totalAverageHealing = result.healingParts.reduce((sum, part) => sum + parseFloat(part.averageHealing), 0);
                result.totalAverageHealing = totalAverageHealing.toFixed(0);

                return result;
            };

            // 计算单个属性投资的增傷效果
            const calculateInvestmentIncrease = (attr, points) => {
                const params = { ...inputs };

                if (analysisMode === 'from_zero') {
                    if (attr === 'crit_damage') {
                        params[attr] = (100 + points).toString();
                    } else if (attr === 'max_attack') {
                        params.max_attack = points.toString();
                        params.min_attack = points.toString();
                    } else {
                        params[attr] = points.toString();
                    }
                } else {
                    if (attr === 'crit_damage') {
                        params[attr] = (toNum(inputs[attr]) + points).toString();
                    } else if (attr === 'max_attack') {
                        params.max_attack = (toNum(inputs.max_attack) + points).toString();
                        params.min_attack = (toNum(inputs.min_attack) + points).toString();
                    } else {
                        params[attr] = (toNum(inputs[attr]) + points).toString();
                    }
                }

                const newResult = calculateHealingWithParams(params);
                const baseResult = calculateHealing();
                const newHealing = toNum(newResult.totalAverageHealing);
                const baseHealing = toNum(baseResult.totalAverageHealing);

                return baseHealing ? ((newHealing - baseHealing) / baseHealing) * 100 : 0;
            };

            const analyzeHealingOptions = () => {
                const attributes = [
                    { key: 'max_attack', label: '攻擊' },
                    { key: 'healing_power', label: '治療強度' },
                    { key: 'crit', label: '會心' },
                    { key: 'crit_damage', label: '會心傷害%' },
                ];

                const newRecommendationData = attributes.map(({ key, label }) => ({
                    attribute: key,
                    label,
                    healingIncrease: key === 'crit_damage'
                        ? calculateInvestmentIncrease(key, investmentPoints[key] || 10)
                        : calculateInvestmentIncrease(key, investmentPoints[key] || 200),
                })).sort((a, b) => b.healingIncrease - a.healingIncrease);

                setRecommendationData(newRecommendationData);
            };

            const handleInvestmentChange = (attr, value) => {
                setInvestmentPoints((prev) => ({
                    ...prev,
                    [attr]: Math.min(1000, Math.max(1, parseInt(value) || 1)),
                }));
                analyzeHealingOptions();
            };

            const toggleVisibility = (key) => {
                setVisibility((prev) => ({ ...prev, [key]: !prev[key] }));
            };

            const handleSelectAll = () => {
                const allSelected = {};
                Object.keys(visibility).forEach(key => {
                    allSelected[key] = true;
                });
                setVisibility(allSelected);
            };

            const handleDeselectAll = () => {
                const allSelected = {};
                Object.keys(visibility).forEach(key => {
                    allSelected[key] = false;
                });
                setVisibility(allSelected);
            };

            const generateChartData = () => {
                const attribute_points = Array.from({ length: 51 }, (_, i) => i * 200);
                const increases = {
                    max_attack: [], healing_power: [], crit: [], crit_damage: [],
                };
                const delta_increases = {
                    max_attack: [], healing_power: [], crit: [], crit_damage: [],
                };

                const baseHealing = toNum(calculateHealing().totalAverageHealing);

                const calculateIncrease = (attr, value) => {
                    const params = { ...inputs };

                    if (analysisMode === 'from_zero') {
                        if (attr === 'crit_damage') {
                            params[attr] = (100 + value / 10).toString();
                        } else if (attr === 'max_attack') {
                            params.max_attack = value.toString();
                            params.min_attack = value.toString();
                        } else {
                            params[attr] = value.toString();
                        }
                    } else {
                        if (attr === 'crit_damage') {
                            params[attr] = (toNum(inputs[attr]) + value / 10).toString();
                        } else if (attr === 'max_attack') {
                            params.max_attack = (toNum(inputs.max_attack) + value).toString();
                            params.min_attack = (toNum(inputs.min_attack) + value).toString();
                        } else {
                            params[attr] = (toNum(inputs[attr]) + value).toString();
                        }
                    }

                    const newHealing = toNum(calculateHealingWithParams(params).totalAverageHealing);
                    const referenceHealing = analysisMode === 'from_zero' ?
                        toNum(calculateHealingWithParams({
                            ...inputs,
                            healing_power: inputs.healing_power,
                            max_attack: analysisMode === 'from_zero' ? '0' : inputs.max_attack,
                            min_attack: analysisMode === 'from_zero' ? '0' : inputs.min_attack,
                            crit: analysisMode === 'from_zero' ? '0' : inputs.crit,
                            crit_damage: analysisMode === 'from_zero' ? '100' : inputs.crit_damage
                        }).totalAverageHealing) :
                        baseHealing;

                    return referenceHealing ? ((newHealing - referenceHealing) / referenceHealing) : 0;
                };

                attribute_points.forEach((point) => {
                    Object.keys(increases).forEach(attr => {
                        increases[attr].push(calculateIncrease(attr, point));
                    });
                });

                for (let i = 1; i < increases.max_attack.length; i++) {
                    Object.keys(delta_increases).forEach(attr => {
                        delta_increases[attr].push(Math.max(0, increases[attr][i] - increases[attr][i - 1]));
                    });
                }

                const deltaData = attribute_points.slice(1).map((point, i) => {
                    const dataPoint = { point };
                    Object.keys(delta_increases).forEach(attr => {
                        dataPoint[attr] = delta_increases[attr][i];
                    });
                    return dataPoint;
                });

                const increaseData = attribute_points.map((point, i) => {
                    const dataPoint = { point };
                    Object.keys(increases).forEach(attr => {
                        dataPoint[attr] = increases[attr][i];
                    });
                    return dataPoint;
                });

                return { deltaData, increaseData };
            };

            const calculateHealingWithParams = (params) => {
                const skillParams = getSkillParams(params.skill_type || inputs.skill_type);
                const panelAttack = (toNum(params.max_attack) + toNum(params.min_attack)) / 2;

                // 技能增強值計算
                let skillIncreaseValue = 0;
                if (skillParams.hasSkillIncrease) {
                    const selectedSkill = skillTypeOptions.find(skill => skill.value === inputs.skill_type);
                    if (selectedSkill && inputs.skill_increase !== '0') {
                        if (skillTagToIncreaseMap[selectedSkill.tag] === inputs.skill_increase) {
                            skillIncreaseValue = toNum(inputs.skill_increase_value);
                        }
                    }
                }

                const skillHealingBonus = skillParams.skillBonus;
                let permanentSkillValue = toNum(params.permanent_skill);
                if (params.permanent_skill === 'custom') {
                    permanentSkillValue = toNum(params.custom_permanent_skill) / 100;
                }
                const healingMultiplier = 1 + toNum(params.water_constellation) + toNum(params.faction_skills) + permanentSkillValue + skillHealingBonus;

                const c = toNum(params.crit);
                const critRateBase = 0.0001942440983381886 * c + 0.15402923129921037;
                const critRate = Math.min(1, Math.max(0, critRateBase + toNum(params.gold_i)));
                const critDamageMultiplier = (toNum(params.crit_damage) / 100 - 1) / 2 + 1;
                const decreaseMultiplier = (1 - toNum(params.healing_decrease) / 100);

                // 技能系数计算函数
                const calculateSkillCoefficient = (lamer1, lamer2, isFixed = false) => {
                    if (isFixed) {
                        return lamer2; // 对于固定系数，lamer2存储固定值
                    }
                    return lamer1 * toNum(params.skill_level) - lamer2;
                };

                const calculateBaseHealing = (attack, multiplier, skillCoeff) => {
                    return ((attack + toNum(params.healing_power) + skillCoeff + skillIncreaseValue) * multiplier * healingMultiplier) * decreaseMultiplier;
                };

                let totalAverageHealing = 0;

                if (skillParams.type === 'burst') {
                    let skillCoeff;
                    if (skillParams.fixedCoefficient !== undefined) {
                        skillCoeff = calculateSkillCoefficient(0, skillParams.fixedCoefficient, true);
                    } else {
                        skillCoeff = calculateSkillCoefficient(skillParams.lamer1, skillParams.lamer2);
                    }

                    const panelInitial = calculateBaseHealing(panelAttack, skillParams.initialMultiplier, skillCoeff);
                    const critInitialPanel = panelInitial * critDamageMultiplier;
                    const averageInitial = (1 - critRate) * panelInitial + critRate * critInitialPanel;
                    totalAverageHealing = averageInitial;

                } else if (skillParams.type === 'continuous') {
                    const skillCoeff = calculateSkillCoefficient(skillParams.lamer1, skillParams.lamer2);
                    const panelContinuous = calculateBaseHealing(panelAttack, skillParams.continuousMultiplier, skillCoeff);
                    const critContinuousPanel = panelContinuous * critDamageMultiplier;
                    const averageContinuous = (1 - critRate) * panelContinuous + critRate * critContinuousPanel;
                    totalAverageHealing = averageContinuous;

                } else if (skillParams.type === 'mixed') {
                    if (skillParams.lamer1_initial !== undefined) {
                        // 清风垂露
                        const initialSkillCoeff = calculateSkillCoefficient(skillParams.lamer1_initial, skillParams.lamer2_initial);
                        const continuousSkillCoeff = calculateSkillCoefficient(skillParams.lamer1_continuous, skillParams.lamer2_continuous);

                        const panelInitial = calculateBaseHealing(panelAttack, skillParams.initialMultiplier, initialSkillCoeff);
                        const panelContinuous = calculateBaseHealing(panelAttack, skillParams.continuousMultiplier, continuousSkillCoeff);
                        const critInitialPanel = panelInitial * critDamageMultiplier;
                        const critContinuousPanel = panelContinuous * critDamageMultiplier;
                        const averageInitial = (1 - critRate) * panelInitial + critRate * critInitialPanel;
                        const averageContinuous = (1 - critRate) * panelContinuous + critRate * critContinuousPanel;
                        totalAverageHealing = averageInitial + averageContinuous;
                    } else {
                        // 彩翼等
                        const skillCoeff = calculateSkillCoefficient(skillParams.lamer1, skillParams.lamer2);
                        const panelInitial = calculateBaseHealing(panelAttack, skillParams.initialMultiplier, skillCoeff);
                        const panelContinuous = calculateBaseHealing(panelAttack, skillParams.continuousMultiplier, skillCoeff);
                        const critInitialPanel = panelInitial * critDamageMultiplier;
                        const critContinuousPanel = panelContinuous * critDamageMultiplier;
                        const averageInitial = (1 - critRate) * panelInitial + critRate * critInitialPanel;
                        const averageContinuous = (1 - critRate) * panelContinuous + critRate * critContinuousPanel;
                        totalAverageHealing = averageInitial + averageContinuous;
                    }

                } else if (skillParams.type === 'split') {
                    const targetSkillCoeff = calculateSkillCoefficient(skillParams.lamer1_target, skillParams.lamer2_target);
                    const selfSkillCoeff = calculateSkillCoefficient(skillParams.lamer1_self, skillParams.lamer2_self);

                    const panelTarget = calculateBaseHealing(panelAttack, skillParams.targetMultiplier, targetSkillCoeff);
                    const panelSelf = calculateBaseHealing(panelAttack, skillParams.selfMultiplier, selfSkillCoeff);
                    const critTargetPanel = panelTarget * critDamageMultiplier;
                    const critSelfPanel = panelSelf * critDamageMultiplier;
                    const averageTarget = (1 - critRate) * panelTarget + critRate * critTargetPanel;
                    const averageSelf = (1 - critRate) * panelSelf + critRate * critSelfPanel;
                    totalAverageHealing = averageTarget + averageSelf;
                }

                return { totalAverageHealing: totalAverageHealing.toFixed(0) };
            };

            useEffect(() => {
                analyzeHealingOptions();
            }, [inputs, analysisMode, investmentPoints]);

            const thresholdResult = calculateThresholdHealing();
            const healingResult = calculateHealing();
            const { deltaData, increaseData } = generateChartData();

            const CustomTooltip = ({ active, payload, label, isDelta }) => {
                if (active && payload && payload.length) {
                    return (
                        <div className="bg-white p-3 border border-gray-200 rounded-lg shadow-sm">
                            <p className="text-sm text-gray-700 font-medium">屬性點: {label}</p>
                            {payload.map((entry, index) => (
                                <p key={index} className="text-sm text-gray-600">
                                    <span style={{ color: entry.stroke }}>{entry.name}</span>: {(entry.value * 100).toFixed(isDelta ? 4 : 2)}%
                                </p>
                            ))}
                        </div>
                    );
                }
                return null;
            };

            return (
                <div className="p-4 container mx-auto min-h-screen">
                    <div className="cherry-gradient rounded-xl p-6 mb-6 shadow-lg">
                        <h1 className="text-xl md:text-2xl font-bold text-center text-white">治療強度計算器</h1>
                        <p className="text-center text-white text-opacity-90 text-sm mt-1">如有問題請聯繫櫻桃白蘭地@緣定今生</p>
                    </div>

                    {/* 新的治疗量计算器 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowHealingCalculator(!showHealingCalculator)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">治療量計算器</h2>
                            </div>
                            <span className="text-cherry-700 text-lg">
                                {showHealingCalculator ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showHealingCalculator ? "max-h-[2000px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <ImageUploader setInputs={setInputs} type="healing" />
                            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                                {[
                                    { key: "max_attack", label: "最大攻擊", icon: "⚔️" },
                                    { key: "min_attack", label: "最小攻擊", icon: "🗡️" },
                                    { key: "crit", label: "會心", icon: "🎯" },
                                    { key: "crit_damage", label: "會心傷害%", icon: "💥", tooltip: "例如180%，輸入180" },
                                    { key: "healing_power", label: "治療強度", icon: "💉" },
                                    { key: "skill_level", label: "技能等級", icon: "📈" },
                                    { key: "healing_decrease", label: "減療%", icon: "📉", tooltip: "例如25%，輸入25" },
                                ].map(({ key, label, icon, tooltip }) => (
                                    <div key={key} className="flex flex-col group relative">
                                        <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                            <span className="mr-1 md:mr-2">{icon}</span>
                                            {label}
                                            {tooltip && (
                                                <>
                                                    <span className="ml-1 flex items-center justify-center w-4 h-4 rounded-full bg-gray-400 text-white text-xs cursor-help">
                                                        ?
                                                    </span>
                                                    <div className="absolute left-0 top-8 bg-gray-800 text-white text-xs p-2 rounded-lg shadow-md z-10 max-w-xs opacity-0 group-hover:opacity-100 transition-opacity">
                                                        {tooltip}
                                                    </div>
                                                </>
                                            )}
                                        </label>
                                        <input
                                            type="number"
                                            name={key}
                                            value={inputs[key]}
                                            onChange={handleChange}
                                            min="0"
                                            max="1000000"
                                            className={`input-focus border ${inputErrors[key] ? 'border-red-500' : 'border-gray-200'} rounded-lg p-2 text-sm w-full`}
                                            aria-label={label}
                                        />
                                        {inputErrors[key] && (
                                            <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                                        )}
                                    </div>
                                ))}
                            </div>

                            {/* 下拉选单 */}
                            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                                <div className="flex flex-col">
                                    <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                        <span className="mr-1 md:mr-2">🌸</span>技能類型
                                    </label>
                                    <select
                                        name="skill_type"
                                        value={inputs.skill_type}
                                        onChange={handleChange}
                                        className="border border-gray-200 rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-cherry-500 focus:border-cherry-500 transition-colors"
                                    >
                                        {skillTypeOptions.map((opt) => (
                                            <option key={opt.value} value={opt.value}>
                                                {opt.label}
                                            </option>
                                        ))}
                                    </select>
                                </div>

                                <div className="flex flex-col">
                                    <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                        <span className="mr-1 md:mr-2">🌟</span>金周天
                                    </label>
                                    <select
                                        name="gold_i"
                                        value={inputs.gold_i}
                                        onChange={handleChange}
                                        className="border border-gray-200 rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-cherry-500 focus:border-cherry-500 transition-colors"
                                    >
                                        {goldOptions.map((opt) => (
                                            <option key={opt.value} value={opt.value}>
                                                {opt.label}
                                            </option>
                                        ))}
                                    </select>
                                </div>

                                <div className="flex flex-col">
                                    <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                        <span className="mr-1 md:mr-2">💧</span>水周天
                                    </label>
                                    <select
                                        name="water_constellation"
                                        value={inputs.water_constellation}
                                        onChange={handleChange}
                                        className="border border-gray-200 rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-cherry-500 focus:border-cherry-500 transition-colors"
                                    >
                                        {waterConstellationOptions.map((opt) => (
                                            <option key={opt.value} value={opt.value}>
                                                {opt.label}
                                            </option>
                                        ))}
                                    </select>
                                </div>

                                <div className="flex flex-col">
                                    <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                        <span className="mr-1 md:mr-2">🔄</span>流派技能數量
                                    </label>
                                    <select
                                        name="faction_skills"
                                        value={inputs.faction_skills}
                                        onChange={handleChange}
                                        className="border border-gray-200 rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-cherry-500 focus:border-cherry-500 transition-colors"
                                    >
                                        {factionSkillsOptions.map((opt) => (
                                            <option key={opt.value} value={opt.value}>
                                                {opt.label}
                                            </option>
                                        ))}
                                    </select>
                                </div>

                                <div className="flex flex-col">
                                    <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                        <span className="mr-1 md:mr-2">📿</span>常駐内功
                                    </label>
                                    <select
                                        name="permanent_skill"
                                        value={inputs.permanent_skill}
                                        onChange={handleChange}
                                        className="border border-gray-200 rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-cherry-500 focus:border-cherry-500 transition-colors"
                                    >
                                        {permanentSkillOptions.map((opt) => (
                                            <option key={opt.value} value={opt.value}>
                                                {opt.label}
                                            </option>
                                        ))}
                                    </select>
                                    {inputs.permanent_skill === 'custom' && (
                                        <input
                                            type="number"
                                            name="custom_permanent_skill"
                                            placeholder="請輸入百分比，例如：5"
                                            value={inputs.custom_permanent_skill || ''}
                                            onChange={handleChange}
                                            min="0"
                                            max="100"
                                            className="mt-2 border border-gray-200 rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-cherry-500 focus:border-cherry-500 transition-colors"
                                        />
                                    )}
                                </div>

                                {/* 技能增強選單 */}
                                <div className="flex flex-col">
                                    <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                        <span className="mr-1 md:mr-2">⚡</span>技能增強
                                    </label>
                                    <select
                                        name="skill_increase"
                                        value={inputs.skill_increase}
                                        onChange={handleChange}
                                        className="border border-gray-200 rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-cherry-500 focus:border-cherry-500 transition-colors"
                                    >
                                        {skillIncreaseOptions.map((opt) => (
                                            <option key={opt.value} value={opt.value}>
                                                {opt.label}
                                            </option>
                                        ))}
                                    </select>
                                    {inputs.skill_increase !== '0' && (
                                        <input
                                            type="number"
                                            name="skill_increase_value"
                                            placeholder="請輸入數值，例如：600"
                                            value={inputs.skill_increase_value || ''}
                                            onChange={handleChange}
                                            min="0"
                                            max="100000"
                                            className="mt-2 border border-gray-200 rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-cherry-500 focus:border-cherry-500 transition-colors"
                                        />
                                    )}
                                </div>
                            </div>

                            {/* 治疗量计算结果 */}
                            <div className="result-card bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100">
                                <div className="flex items-center mb-4">
                                    <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                                    <h3 className="font-bold text-base md:text-lg text-gray-800">
                                        治療量計算結果 - {healingResult.skillDescription}
                                    </h3>
                                </div>

                                {/* 基础数据 */}
                                <div className="grid grid-cols-2 sm:grid-cols-4 gap-3 mb-6">
                                    <div className="bg-cherry-50 p-3 rounded-lg">
                                        <p className="text-xs text-cherry-700">面板攻擊</p>
                                        <p className="text-sm font-bold text-cherry-800">{healingResult.panelAttack}</p>
                                    </div>
                                    <div className="bg-cherry-50 p-3 rounded-lg">
                                        <p className="text-xs text-cherry-700">技能等級</p>
                                        <p className="text-sm font-bold text-cherry-800">{inputs.skill_level}</p>
                                    </div>
                                    <div className="bg-cherry-50 p-3 rounded-lg">
                                        <p className="text-xs text-cherry-700">技能治療加成</p>
                                        <p className="text-sm font-bold text-cherry-800">{healingResult.skillHealingBonus}%</p>
                                    </div>
                                    <div className="bg-cherry-50 p-3 rounded-lg">
                                        <p className="text-xs text-cherry-700">治療倍率</p>
                                        <p className="text-sm font-bold text-cherry-800">{healingResult.healingMultiplier}</p>
                                    </div>
                                    <div className="bg-blue-50 p-3 rounded-lg">
                                        <p className="text-xs text-blue-700">會心率</p>
                                        <p className="text-sm font-bold text-blue-800">{healingResult.critRate}%</p>
                                    </div>
                                    <div className="bg-blue-50 p-3 rounded-lg">
                                        <p className="text-xs text-blue-700">會心傷害倍率</p>
                                        <p className="text-sm font-bold text-blue-800">{healingResult.critDamageMultiplier}</p>
                                    </div>
                                    <div className="bg-blue-50 p-3 rounded-lg">
                                        <p className="text-xs text-blue-700">會心總倍率</p>
                                        <p className="text-sm font-bold text-blue-800">{healingResult.critTotalMultiplier}</p>
                                    </div>
                                    <div className="bg-purple-50 p-3 rounded-lg">
                                        <p className="text-xs text-purple-700">總平均治療量</p>
                                        <p className="text-lg font-bold text-purple-800">{healingResult.totalAverageHealing}</p>
                                    </div>
                                </div>

                                {/* 分段显示治疗部分 */}
                                {healingResult.healingParts && healingResult.healingParts.map((part, index) => (
                                    <div key={index} className="mb-6 p-4 bg-gradient-to-r from-green-50 to-blue-50 rounded-lg border-l-4 border-green-500">
                                        <h4 className="font-bold text-lg text-gray-800 mb-3 flex items-center">
                                            <span className="mr-2">{index === 0 ? '🎯' : index === 1 ? '🔄' : '💫'}</span>
                                            {part.displayName}
                                            <span className="ml-2 text-sm text-gray-600">
                                                (系數: {part.skillCoefficient})
                                            </span>
                                        </h4>

                                        <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-3">
                                            <div className="bg-white p-3 rounded-lg shadow-sm">
                                                <p className="text-xs text-gray-600">面板治療量</p>
                                                <p className="text-sm font-bold text-gray-800">{part.panelHealing}</p>
                                            </div>
                                            <div className="bg-white p-3 rounded-lg shadow-sm">
                                                <p className="text-xs text-gray-600">不會心最大治療量</p>
                                                <p className="text-sm font-bold text-gray-800">{part.maxHealing}</p>
                                            </div>
                                            <div className="bg-white p-3 rounded-lg shadow-sm">
                                                <p className="text-xs text-gray-600">不會心最小治療量</p>
                                                <p className="text-sm font-bold text-gray-800">{part.minHealing}</p>
                                            </div>
                                            <div className="bg-green-100 p-3 rounded-lg shadow-sm">
                                                <p className="text-xs text-green-700">平均治療量</p>
                                                <p className="text-lg font-bold text-green-800">{part.averageHealing}</p>
                                            </div>
                                            <div className="bg-orange-100 p-3 rounded-lg shadow-sm">
                                                <p className="text-xs text-orange-700">會心最大治療量</p>
                                                <p className="text-sm font-bold text-orange-800">{part.critMaxHealing}</p>
                                            </div>
                                            <div className="bg-orange-100 p-3 rounded-lg shadow-sm">
                                                <p className="text-xs text-orange-700">會心最小治療量</p>
                                                <p className="text-sm font-bold text-orange-800">{part.critMinHealing}</p>
                                            </div>
                                            {part.luoxiaHealing && (
                                                <div className="bg-indigo-100 p-3 rounded-lg shadow-sm">
                                                    <p className="text-xs text-indigo-700">落霞轉換治療量 (18%)</p>
                                                    <p className="text-sm font-bold text-indigo-800">{part.luoxiaHealing}</p>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* 治疗属性投资分析 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowInvestmentAnalysis(!showInvestmentAnalysis)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">治療屬性投資分析</h2>
                            </div>
                            <span className="text-cherry-700 text-lg">
                                {showInvestmentAnalysis ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showInvestmentAnalysis ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="mb-4 p-4 bg-gray-50 rounded-lg">
                                <h3 className="text-sm font-semibold text-gray-700 mb-3">分析模式：</h3>
                                <div className="flex gap-4">
                                    <label className="flex items-center space-x-2 cursor-pointer">
                                        <input
                                            type="radio"
                                            name="analysisMode"
                                            value="incremental"
                                            checked={analysisMode === 'incremental'}
                                            onChange={(e) => setAnalysisMode(e.target.value)}
                                            className="w-4 h-4 text-cherry-600"
                                        />
                                        <span className="text-sm">增量分析 (從當前屬性繼續投資)</span>
                                    </label>
                                    <label className="flex items-center space-x-2 cursor-pointer">
                                        <input
                                            type="radio"
                                            name="analysisMode"
                                            value="from_zero"
                                            checked={analysisMode === 'from_zero'}
                                            onChange={(e) => setAnalysisMode(e.target.value)}
                                            className="w-4 h-4 text-cherry-600"
                                        />
                                        <span className="text-sm">從零分析 (各屬性從0開始堆疊)</span>
                                    </label>
                                </div>
                            </div>

                            {recommendationData.length > 0 && (
                                <div className="space-y-4 mb-6">
                                    {[
                                        { key: "max_attack", label: "攻擊", increment: 200 },
                                        { key: "healing_power", label: "治療強度", increment: 200 },
                                        { key: "crit", label: "會心", increment: 200 },
                                        { key: "crit_damage", label: "會心傷害%", increment: 10 },
                                    ].map(({ key, label, increment }) => {
                                        const increase = key === 'crit_damage'
                                            ? calculateInvestmentIncrease(key, investmentPoints[key])
                                            : calculateInvestmentIncrease(key, investmentPoints[key]);
                                        const maxIncrease = Math.max(
                                            ...Object.keys(investmentPoints).map((attr) =>
                                                attr === 'crit_damage'
                                                    ? calculateInvestmentIncrease(attr, investmentPoints[attr])
                                                    : calculateInvestmentIncrease(attr, investmentPoints[attr])
                                            ),
                                            0.0001
                                        );
                                        const barWidth = `${(increase / maxIncrease) * 100}%`;
                                        return (
                                            <div key={key} className="flex items-center gap-4">
                                                <span className="w-32 text-sm font-semibold text-gray-700">{label}</span>
                                                <input
                                                    type="range"
                                                    min={key === 'crit_damage' ? "1" : "1"}
                                                    max={key === 'crit_damage' ? "200" : "1000"}
                                                    value={investmentPoints[key]}
                                                    onChange={(e) => handleInvestmentChange(key, e.target.value)}
                                                    className="w-1/3 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                />
                                                <input
                                                    type="number"
                                                    min={key === 'crit_damage' ? "1" : "1"}
                                                    max={key === 'crit_damage' ? "200" : "1000"}
                                                    value={investmentPoints[key]}
                                                    onChange={(e) => {
                                                        const maxVal = key === 'crit_damage' ? 200 : 1000;
                                                        const value = Math.min(maxVal, Math.max(1, parseInt(e.target.value) || 1));
                                                        handleInvestmentChange(key, value);
                                                    }}
                                                    className="w-20 p-2 border border-gray-200 rounded-lg text-sm focus:ring-2 focus:ring-cherry-500 focus:border-cherry-500 transition-colors"
                                                />
                                                <div className="w-1/3 bg-gray-200 rounded-full h-2.5">
                                                    <div
                                                        className="bg-cherry-500 h-2.5 rounded-full"
                                                        style={{ width: barWidth }}
                                                    ></div>
                                                </div>
                                                <span className="text-sm text-gray-700">
                                                    {increase.toFixed(2)}% 治療提升
                                                </span>
                                            </div>
                                        );
                                    })}
                                </div>
                            )}

                            {/* 配装建议 */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4 text-gray-700 flex items-center">
                                    <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                                    治療配裝建議
                                </h2>
                                <div className="space-y-3">
                                    {recommendationData.length > 0 ? (
                                        <>
                                            <div className="flex items-center justify-between p-4 bg-green-50 rounded-lg border-l-4 border-green-500">
                                                <div>
                                                    <span className="font-semibold text-green-800">
                                                        最優投資: {recommendationData[0]?.label}
                                                    </span>
                                                    <p className="text-sm text-green-600 mt-1">
                                                        投資200點可提升治療 {recommendationData[0]?.healingIncrease.toFixed(3)}%
                                                    </p>
                                                </div>
                                            </div>
                                            {recommendationData.length > 1 && (
                                                <div className="flex items-center justify-between p-4 bg-yellow-50 rounded-lg border-l-4 border-yellow-500">
                                                    <div>
                                                        <span className="font-semibold text-yellow-800">
                                                            次優選擇: {recommendationData[1]?.label}
                                                        </span>
                                                        <p className="text-sm text-yellow-600 mt-1">
                                                            投資200點可提升治療 {recommendationData[1]?.healingIncrease.toFixed(3)}%
                                                        </p>
                                                    </div>
                                                </div>
                                            )}
                                            <div className="p-4 bg-blue-50 rounded-lg border-l-4 border-blue-500">
                                                <span className="font-semibold text-blue-800">配裝策略建議:</span>
                                                <p className="text-sm text-blue-600 mt-1">
                                                    使用「{healingResult.skillDescription}」技能時，優先堆疊 {recommendationData[0]?.label}{" "}
                                                    {recommendationData[1] ? `和 ${recommendationData[1]?.label}` : ""}，
                                                    可以獲得最佳的治療效果。
                                                    <br />
                                                    請注意不同技能類型的收益優先級可能不同，建議針對主要使用的技能進行優化。
                                                </p>
                                            </div>
                                        </>
                                    ) : (
                                        <p className="text-sm text-gray-500">正在生成建議，請稍候...</p>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* 收益曲线分析 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowIncrementalAnalysis(!showIncrementalAnalysis)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">治療屬性收益曲線分析</h2>
                            </div>
                            <span className="text-cherry-700 text-lg">
                                {showIncrementalAnalysis ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showIncrementalAnalysis ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                                <div className="flex items-center justify-between mb-3">
                                    <h3 className="text-sm font-semibold text-gray-700">選擇要顯示的曲線：</h3>
                                    <div className="flex gap-2">
                                        <button
                                            onClick={handleSelectAll}
                                            className="px-3 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600"
                                        >
                                            全選
                                        </button>
                                        <button
                                            onClick={handleDeselectAll}
                                            className="px-3 py-1 text-xs bg-gray-500 text-white rounded hover:bg-gray-600"
                                        >
                                            全不選
                                        </button>
                                    </div>
                                </div>
                                <div className="grid grid-cols-2 md:grid-cols-2 gap-3">
                                    {[
                                        { key: 'max_attack', label: '攻擊' },
                                        { key: 'healing_power', label: '治療強度' },
                                        { key: 'crit', label: '會心' },
                                        { key: 'crit_damage', label: '會心傷害%' },
                                    ].map(({ key, label }, index) => (
                                        <label key={key} className="flex items-center space-x-2 cursor-pointer">
                                            <input
                                                type="checkbox"
                                                checked={visibility[key] || false}
                                                onChange={() => toggleVisibility(key)}
                                                className="w-4 h-4 text-cherry-600 rounded focus:ring-cherry-500"
                                            />
                                            <div className="flex items-center space-x-2">
                                                <div
                                                    className="w-3 h-3 rounded-full"
                                                    style={{ backgroundColor: colors[index % colors.length] }}
                                                ></div>
                                                <span className="text-sm text-gray-700">{label}</span>
                                            </div>
                                        </label>
                                    ))}
                                </div>
                            </div>

                            {increaseData.length > 0 ? (
                                <ResponsiveContainer width="100%" height={400}>
                                    <LineChart data={increaseData}>
                                        <CartesianGrid strokeDasharray="3 3" />
                                        <XAxis
                                            dataKey="point"
                                            label={{ value: '投入點數', position: 'insideBottom', offset: -5 }}
                                        />
                                        <YAxis
                                            label={{ value: '治療提升%', angle: -90, position: 'insideLeft' }}
                                            tickFormatter={(value) => (value * 100).toFixed(2)}
                                        />
                                        <Tooltip
                                            formatter={(value, name) => [
                                                `${(value * 100).toFixed(2)}%`,
                                                [
                                                    { key: 'max_attack', label: '攻擊' },
                                                    { key: 'healing_power', label: '治療強度' },
                                                    { key: 'crit', label: '會心' },
                                                    { key: 'crit_damage', label: '會心傷害%' },
                                                ].find(item => item.key === name)?.label || name,
                                            ]}
                                            labelFormatter={(points) => `投入點數: ${points}`}
                                        />
                                        <Legend />
                                        {Object.keys(visibility).map((key, index) => visibility[key] && (
                                            <Line
                                                key={key}
                                                type="monotone"
                                                dataKey={key}
                                                stroke={[
                                                    '#db2537', '#ff6b6b', '#14b8a6', '#3b82f6'
                                                ][index % 4]}
                                                strokeWidth={2}
                                                dot={false}
                                                name={[
                                                    { key: 'max_attack', label: '攻擊' },
                                                    { key: 'healing_power', label: '治療強度' },
                                                    { key: 'crit', label: '會心' },
                                                    { key: 'crit_damage', label: '會心傷害%' },
                                                ].find(item => item.key === key)?.label || key}
                                            />
                                        ))}
                                    </LineChart>
                                </ResponsiveContainer>
                            ) : (
                                <p className="text-sm text-gray-500">正在生成圖表，請稍候...</p>
                            )}

                            {/* 每200点增量收益 */}
                            <div className="mt-8">
                                <h3 className="font-bold text-base text-gray-800 mb-4">每200點屬性治療收益</h3>
                                <div className="flex flex-wrap gap-4 mb-4">
                                    {[
                                        { key: 'max_attack', label: '攻擊', color: '#db2537' },
                                        { key: 'healing_power', label: '治療強度', color: '#ff6b6b' },
                                        { key: 'crit', label: '會心', color: '#14b8a6' },
                                        { key: 'crit_damage', label: '會心傷害%', color: '#3b82f6' },
                                    ].map(({ key, label, color }) => (
                                        <label key={key} className="flex items-center">
                                            <input
                                                type="checkbox"
                                                checked={visibility[key]}
                                                onChange={() => toggleVisibility(key)}
                                                className="mr-2"
                                            />
                                            <span style={{ color }}>{label}</span>
                                        </label>
                                    ))}
                                </div>
                                <div className="w-full h-[300px]">
                                    {deltaData.length > 0 ? (
                                        <ResponsiveContainer width="100%" height="100%">
                                            <LineChart data={deltaData}>
                                                <CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
                                                <XAxis
                                                    dataKey="point"
                                                    label={{ value: '屬性點', position: 'insideBottom', offset: -5, fontSize: 12, fill: '#6b7280' }}
                                                    tick={{ fill: '#6b7280', fontSize: 12 }}
                                                />
                                                <YAxis
                                                    label={{ value: '每200點收益 (%)', angle: -90, position: 'insideLeft', fontSize: 12, fill: '#6b7280' }}
                                                    tickFormatter={(value) => (value * 100).toFixed(4)}
                                                    tick={{ fill: '#6b7280', fontSize: 12 }}
                                                />
                                                <Tooltip content={<CustomTooltip isDelta={true} />} />
                                                <Legend wrapperStyle={{ fontSize: 12 }} />
                                                {Object.keys(visibility).map((key, index) => visibility[key] && (
                                                    <Line
                                                        key={key}
                                                        type="monotone"
                                                        dataKey={key}
                                                        name={[
                                                            { key: 'max_attack', label: '攻擊' },
                                                            { key: 'healing_power', label: '治療強度' },
                                                            { key: 'crit', label: '會心' },
                                                            { key: 'crit_damage', label: '會心傷害%' },
                                                        ].find(item => item.key === key)?.label || key}
                                                        stroke={[
                                                            '#db2537', '#ff6b6b', '#14b8a6', '#3b82f6'
                                                        ][index % 4]}
                                                        strokeWidth={2}
                                                        dot={false}
                                                    />
                                                ))}
                                            </LineChart>
                                        </ResponsiveContainer>
                                    ) : (
                                        <p className="text-sm text-gray-500">正在生成圖表，請稍候...</p>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* 原有的治疗强度阈值转换计算器 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowThresholdCalculator(!showThresholdCalculator)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">治療強度閾值轉換計算器</h2>
                            </div>
                            <span className="text-cherry-700 text-lg">
                                {showThresholdCalculator ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showThresholdCalculator ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 mb-4">
                                {[
                                    { key: "armor_break", label: "破防", icon: "🛡️" },
                                    { key: "hit", label: "命中", icon: "🎯" },
                                    { key: "elemental_attack", label: "元素攻擊", icon: "✨" },
                                    { key: "boss_restraint", label: "首領克制", icon: "👑" },
                                    { key: "faction_restraint", label: "流派克制", icon: "🔄" },
                                    { key: "resistance_ignore", label: "抗性忽視", icon: "🌀" },
                                    { key: "healing_power_equip", label: "治療強度（裝備）", icon: "💉" }
                                ].map(({ key, label, icon }) => (
                                    <div key={key} className="flex flex-col">
                                        <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                            <span className="mr-1 md:mr-2">{icon}</span>{label}
                                        </label>
                                        <input
                                            type="number"
                                            name={key}
                                            value={inputs[key]}
                                            onChange={handleChange}
                                            min="0"
                                            max="1000000"
                                            className={`input-focus border ${inputErrors[key] ? 'border-red-500' : 'border-gray-200'} rounded-lg p-2 text-sm w-full`}
                                            aria-label={label}
                                        />
                                        {inputErrors[key] && (
                                            <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                                        )}
                                    </div>
                                ))}
                            </div>

                            <div className="result-card bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100">
                                <div className="flex items-center mb-4">
                                    <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                                    <h3 className="font-bold text-base md:text-lg text-gray-800">閾值轉換結果</h3>
                                </div>
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                                    <div className="bg-cherry-50 p-3 rounded-lg">
                                        <p className="text-xs text-cherry-700">屬性轉換值</p>
                                        <p className="text-lg md:text-xl font-bold text-cherry-800">{thresholdResult.attributeConversion}</p>
                                    </div>
                                    <div className="bg-cherry-500 p-3 rounded-lg">
                                        <p className="text-xs text-white">總治療強度</p>
                                        <p className="text-lg md:text-xl font-bold text-white">{thresholdResult.healingPower}</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const DamageCalculator = () => {
            // 初始輸入狀態
            const [inputs, setInputs] = useState({
                skill_multiplier: "1518",
                D: "5000",
                E: "800",
                b_c: "900",
                d_c: "1.8",
                R: "500",
                h: "700",
                b_d: "2000",
                b_s: "700",
                b_e: "0",
                flow_percent: "0",
                damage_increase: "0",
                skill_damage_increase: "0",
                d_s: "2000",
                d_f: "2000",
                d_d: "5000",
                d_e: "0",
                b_b: "1340",
                hp: "80000",
                b_c_defense: "550",
                d_c_defense: "0",
                flow_resist_percent: "0",
                damage_reduction: "0",
                skill_damage_reduction: "0",
                lambda_1: "358",
                lambda_2: "0.359",
                lambda_3: "2860",
                lambda_4: "531",
                W: "1",
                gold_i: "0",
            });

            const [inputErrors, setInputErrors] = useState({});
            const [visibility, setVisibility] = useState({
                d_s: true,
                d_f: true,
                d_d: true,
                d_e: true,
                b_b: true,
                b_c_defense: true,
            });
            const [showAttacker, setShowAttacker] = useState(true);
            const [showDefender, setShowDefender] = useState(true);
            const [showOriginal, setShowOriginal] = useState(true);
            const [showReduced, setShowReduced] = useState(true);
            const [showDamageResult, setShowDamageResult] = useState(true);
            const [showInvestmentAnalysis, setShowInvestmentAnalysis] = useState(true);
            const [showIncrementalAnalysis, setShowIncrementalAnalysis] = useState(true);
            const [isTableExpanded, setIsTableExpanded] = useState(true);
            const [analysisData, setAnalysisData] = useState([]);
            const [recommendationData, setRecommendationData] = useState([]);
            const [selectedCurves, setSelectedCurves] = useState({});
            const [analysisMode, setAnalysisMode] = useState("incremental");
            const [investmentPoints, setInvestmentPoints] = useState({
                d_s: 200,
                d_f: 200,
                d_d: 200,
                d_e: 200,
                b_b: 200,
                b_c_defense: 200,
                d_c_defense: 200,
            });
            const [critDefensePercent, setCritDefensePercent] = useState(10);

            // 使用 useState 替代 localStorage
            const [presets, setPresets] = useState(() => {
                const savedPresets = localStorage.getItem("damageCalculatorPresets");
                return savedPresets ? JSON.parse(savedPresets) : [];
            });
            // 當 presets 變化時，同步保存到 localStorage
            useEffect(() => {
                localStorage.setItem("damageCalculatorPresets", JSON.stringify(presets));
            }, [presets]);

            const [compareIndexes, setCompareIndexes] = useState({ a: null, b: null });
            const [compareResult, setCompareResult] = useState(null);

            const goldOptions = [
                { value: "0", label: "無金周天" },
                { value: "0.03", label: "金周天1級" },
                { value: "0.04", label: "金周天2級" },
                { value: "0.05", label: "金周天3級" },
            ];

            const elementWeaknessOptions = [
                { value: "1", label: "無元素弱點" },
                { value: "1.1", label: "碎夢大特" },
            ];

            // 全零防禦基準
            const zeroDefense = {
                d_s: 0,
                d_f: 0,
                d_d: 0,
                d_e: 0,
                b_b: 0,
                hp: 0,
                b_c_defense: 0,
                d_c_defense: 0,
                flow_resist_percent: 0,
                damage_reduction: 0,
                skill_damage_reduction: 0,
            };

            // 工具函數：將值轉為數字，若無效則返回 0
            const safeNum = (val) => {
                const num = parseFloat(val);
                return isNaN(num) || !isFinite(num) ? 0 : num;
            };

            // 計算傷害函數
            const calculateDamage = (
                D,
                R,
                b_s,
                d_s,
                d_f,
                b_d,
                d_d,
                E,
                b_e,
                d_e,
                b_c,
                d_c,
                h,
                b_b,
                b_c_defense,
                d_c_defense,
                flow_percent,
                damage_increase,
                flow_resist_percent,
                damage_reduction,
                skill_damage_increase,
                skill_damage_reduction,
                lambda_1,
                lambda_2,
                lambda_3,
                lambda_4,
                W,
                gold_i,
                skill_multiplier
            ) => {
                const p_h_official = calculateOfficialHitRate(safeNum(h), safeNum(b_b));

                // ===== 實戰預測公式（用於實際戰鬥計算）=====
                const practical_result = calculatePracticalHitRate(safeNum(h), safeNum(b_b));
                const p_h = practical_result.hitRate;
                const hit_mode = practical_result.mode;

                // 會心相關計算
                const c = safeNum(b_c) - safeNum(b_c_defense);
                const p_c = Math.min(1, Math.max(0, (115 * c + 90) / (c + 940) / 100 + safeNum(gold_i)));

                const p_h_1 = p_h;
                const m_c = 1 + p_c * Math.max(0, (safeNum(d_c) - 1 - safeNum(d_c_defense)));
                const d_mul = m_c * p_h + 0.5 * (1 - p_h);

                // 氣盾計算
                const G = safeNum(b_s) >= safeNum(d_s)
                    ? 0
                    : safeNum(d_s) / 3 <= safeNum(b_s)
                        ? 0.5 * (safeNum(d_s) - safeNum(b_s))
                        : safeNum(d_s) - 2 * safeNum(b_s);

                const A = safeNum(D) + (safeNum(R) - safeNum(d_f)) - G;

                // 防禦和元素減免
                const gamma = safeNum(d_d) - safeNum(b_d) > 0
                    ? (safeNum(d_d) - safeNum(b_d)) / (safeNum(d_d) - safeNum(b_d) + safeNum(lambda_3))
                    : 0;
                const gamma_1 = 1 - gamma;

                const e = safeNum(d_e) - safeNum(b_e);
                const beta = e > 0 ? e / (e + safeNum(lambda_4)) : 0;

                const gamma_2 = gamma > 0 ? 1 - gamma : 1;
                const beta_2 = beta > 0 ? 1 - beta : 1;

                const skillDamageIncrease = safeNum(skill_damage_increase) / 100;
                const skillDamageReduction = safeNum(skill_damage_reduction) / 100;

                const damage =
                    (safeNum(skill_multiplier) / 100) *
                    ((safeNum(lambda_1) + safeNum(lambda_2) * A) * (1 - gamma) +
                        safeNum(W) * safeNum(lambda_2) * safeNum(E) * (1 - beta)) *
                    d_mul *
                    (1 + safeNum(flow_percent) - safeNum(flow_resist_percent)) *
                    (1 + safeNum(damage_increase) - safeNum(damage_reduction)) *
                    (1 + skillDamageIncrease - skillDamageReduction);

                return isNaN(damage) || !isFinite(damage) ? 0 : Math.max(0, damage);
            };


            // 傷害計算函數
            const calculate = (inputs) => {
                const {
                    skill_multiplier, D, E, b_c, d_c, R, h, b_d, b_s, b_e, flow_percent, damage_increase,
                    skill_damage_increase, d_s, d_f, d_d, d_e, b_b, hp, b_c_defense, d_c_defense,
                    flow_resist_percent, damage_reduction, skill_damage_reduction, lambda_1, lambda_2,
                    lambda_3, lambda_4, W, gold_i,
                } = inputs;

                // ===== 新的官方預測公式（僅用於UI顯示）=====
                const p_h_official = calculateOfficialHitRate(safeNum(h), safeNum(b_b));

                // ===== 實戰預測公式（用於實際戰鬥計算）=====
                const practical_result = calculatePracticalHitRate(safeNum(h), safeNum(b_b));
                const p_h = practical_result.hitRate;
                const hit_mode = practical_result.mode;

                // 會心相關計算
                const c = safeNum(b_c) - safeNum(b_c_defense);
                const p_c = Math.min(1, Math.max(0, (115 * c + 90) / (c + 940) / 100 + safeNum(gold_i)));

                const p_h_1 = 1 - p_h;
                const m_c = 1 + p_c * Math.max(0, (safeNum(d_c) - 1 - safeNum(d_c_defense)));
                const d_mul = m_c * p_h + 0.5 * (1 - p_h);

                // 氣盾計算
                const G = safeNum(b_s) >= safeNum(d_s)
                    ? 0
                    : safeNum(d_s) / 3 <= safeNum(b_s)
                        ? 0.5 * (safeNum(d_s) - safeNum(b_s))
                        : safeNum(d_s) - 2 * safeNum(b_s);

                const A = safeNum(D) + (safeNum(R) - safeNum(d_f)) - G;

                // 防禦和元素減免
                const gamma = safeNum(d_d) - safeNum(b_d) > 0
                    ? (safeNum(d_d) - safeNum(b_d)) / (safeNum(d_d) - safeNum(b_d) + safeNum(lambda_3))
                    : 0;
                const gamma_1 = 1 - gamma;

                const e = safeNum(d_e) - safeNum(b_e);
                const beta = e > 0 ? e / (e + safeNum(lambda_4)) : 0;

                const gamma_2 = gamma > 0 ? 1 - gamma : 1;
                const beta_2 = beta > 0 ? 1 - beta : 1;

                // ===== 原數值屬性計算（無防守）=====
                const c_original = safeNum(b_c);
                const p_c_original = Math.min(1, Math.max(0, (115 * c_original + 90) / (c_original + 940) / 100 + safeNum(gold_i)));

                // 原數值也使用新的官方公式（命中0，格擋保持）
                const p_h_original = calculateOfficialHitRate(0, safeNum(b_b));
                const p_h_1_original = p_h_original;
                const m_c_original = 1 + p_c_original * (safeNum(d_c) - 1);
                const d_mul_original = m_c_original * p_h_original + 0.5 * (1 - p_h_original);

                const G_original = 0;
                const A_original = safeNum(D) + safeNum(R) - G_original;
                const gamma_original = 0;
                const beta_original = 0;
                const gamma_original_2 = 1 - gamma_original;
                const beta_original_2 = 1 - beta_original;

                // 傷害計算
                const baseDamage = (
                    (safeNum(skill_multiplier) / 100) * (
                        ((safeNum(lambda_1) + safeNum(lambda_2) * A_original) * (1 - gamma_original)) +
                        safeNum(W) * safeNum(lambda_2) * safeNum(E) * (1 - beta_original)
                    )
                ) * d_mul_original * (1 + safeNum(flow_percent)) * (1 + safeNum(damage_increase)) * (1 + safeNum(skill_damage_increase));

                const finalDamage = (
                    (safeNum(skill_multiplier) / 100) * (
                        ((safeNum(lambda_1) + safeNum(lambda_2) * A) * (1 - gamma)) +
                        safeNum(W) * safeNum(lambda_2) * safeNum(E) * (1 - beta)
                    )
                ) * d_mul * (1 + safeNum(flow_percent) - safeNum(flow_resist_percent)) * (1 + safeNum(damage_increase) - safeNum(damage_reduction)) * (1 + safeNum(skill_damage_increase) / 100 - safeNum(skill_damage_reduction) / 100);

                const totalReduction = baseDamage && isFinite(baseDamage) && baseDamage > 0
                    ? Math.max(0, 1 - finalDamage / baseDamage)
                    : 0;
                const ehp = safeNum(hp) / (1 - totalReduction) || safeNum(hp);

                return {
                    c: c.toFixed(2),
                    p_c: (p_c * 100).toFixed(2) + '%',

                    // 官方預測命中率
                    p_h_official: (p_h_official * 100).toFixed(2) + '%',
                    block_rate_official: ((1 - p_h_official) * 100).toFixed(2) + '%',

                    // 實戰預測命中率
                    p_h_practical: (p_h * 100).toFixed(2) + '%',
                    hit_mode: hit_mode,
                    block_rate_practical: ((1 - p_h) * 100).toFixed(2) + '%',

                    // 用於實際傷害計算的值
                    p_h: p_h.toFixed(4),
                    p_h_1: (p_h_1 * 100).toFixed(2) + '%',
                    m_c: m_c.toFixed(4),
                    d_mul: d_mul.toFixed(4),
                    G: G.toFixed(2),
                    A: A.toFixed(2),
                    gamma: (gamma * 100).toFixed(2) + '%',
                    gamma_1: (gamma_1 * 100).toFixed(2) + '%',
                    beta: (beta * 100).toFixed(2) + '%',
                    gamma_2: (gamma_2 * 100).toFixed(2) + '%',
                    beta_2: (beta_2 * 100).toFixed(2) + '%',

                    // 原數值屬性
                    c_original: c_original.toFixed(2),
                    p_c_original: (p_c_original * 100).toFixed(2) + '%',
                    p_h_original: (p_h_original * 100).toFixed(2) + '%',
                    p_h_1_original: (p_h_1_original * 100).toFixed(2) + '%',
                    m_c_original: m_c_original.toFixed(4),
                    d_mul_original: d_mul_original.toFixed(4),
                    G_original: G_original.toFixed(2),
                    A_original: A_original.toFixed(2),
                    gamma_original: (gamma_original * 100).toFixed(2) + '%',
                    beta_original: (beta_original * 100).toFixed(2) + '%',
                    gamma_original_2: (gamma_original_2 * 100).toFixed(2) + '%',
                    beta_original_2: (beta_original_2 * 100).toFixed(2) + '%',

                    baseDamage: isNaN(baseDamage) || !isFinite(baseDamage) ? "0.00" : baseDamage.toFixed(2),
                    finalDamage: isNaN(finalDamage) || !isFinite(finalDamage) ? "0.00" : finalDamage.toFixed(2),
                    totalReduction: (totalReduction * 100).toFixed(2) + '%',
                    ehp: isNaN(ehp) || !isFinite(ehp) ? "0.00" : ehp.toFixed(2),
                };
            };

            // 計算單個屬性投資的減傷效果
            const calculateInvestmentReduction = (attr, points) => {
                const params = {
                    d_s: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_s),
                    d_d: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_d),
                    d_f: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_f),
                    d_e: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_e),
                    b_b: analysisMode === "from_zero" ? 0 : safeNum(inputs.b_b),
                    b_c_defense: analysisMode === "from_zero" ? 0 : safeNum(inputs.b_c_defense),
                    d_c_defense: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_c_defense),
                };

                // 添加百分比處理邏輯
                if (attr === "d_c_defense_percent") {
                    const increment = analysisMode === "from_zero" ? points / 100 : points / 100;
                    params.d_c_defense = (analysisMode === "from_zero" ? 0 : safeNum(inputs.d_c_defense)) + increment;
                } else {
                    const increment = attr === "d_c_defense" ? Math.min(2.0, Math.max(0.01, points / 200 * 0.01)) : points;
                    params[attr] = (analysisMode === "from_zero" ? 0 : safeNum(inputs[attr])) + increment;
                }

                const d_reduced = calculateDamage(
                    safeNum(inputs.D),
                    safeNum(inputs.R),
                    safeNum(inputs.b_s),
                    params.d_s,
                    params.d_f,
                    safeNum(inputs.b_d),
                    params.d_d,
                    safeNum(inputs.E),
                    safeNum(inputs.b_e),
                    params.d_e,
                    safeNum(inputs.b_c),
                    safeNum(inputs.d_c),
                    safeNum(inputs.h),
                    params.b_b,
                    params.b_c_defense,
                    params.d_c_defense,
                    safeNum(inputs.flow_percent),
                    safeNum(inputs.damage_increase),
                    safeNum(inputs.flow_resist_percent),
                    safeNum(inputs.damage_reduction),
                    safeNum(inputs.skill_damage_increase),
                    safeNum(inputs.skill_damage_reduction),
                    safeNum(inputs.lambda_1),
                    safeNum(inputs.lambda_2),
                    safeNum(inputs.lambda_3),
                    safeNum(inputs.lambda_4),
                    safeNum(inputs.W),
                    safeNum(inputs.gold_i),
                    safeNum(inputs.skill_multiplier)
                );
                const baseDamage = parseFloat(calculate(inputs).finalDamage) || 0;
                const reduction = baseDamage && isFinite(baseDamage) && baseDamage > 0 && d_reduced >= 0
                    ? Math.max(0, (baseDamage - d_reduced) / baseDamage * 100)
                    : 0;
                return isNaN(reduction) || !isFinite(reduction) ? 0 : reduction;
            };

            // 會心防禦百分比變更處理函數
            const handleCritDefensePercentChange = (value) => {
                const newValue = Math.min(100, Math.max(1, parseInt(value) || 1));
                setCritDefensePercent(newValue);
                analyzeDefenseOptions();
            };

            // 生成每200點屬性減傷收益數據
            const generateChartData = (inputs) => {
                const attribute_points = Array.from({ length: 51 }, (_, i) => i * 200);
                const reductions = {
                    d_s: [], d_d: [], d_f: [], d_e: [], b_b: [], b_c_defense: [],
                };
                const delta_reductions = {
                    d_s: [], d_d: [], d_f: [], d_e: [], b_b: [], b_c_defense: [],
                };

                const baseParams = {
                    d_s: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_s),
                    d_d: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_d),
                    d_f: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_f),
                    d_e: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_e),
                    b_b: analysisMode === "from_zero" ? 0 : safeNum(inputs.b_b),
                    b_c_defense: analysisMode === "from_zero" ? 0 : safeNum(inputs.b_c_defense),
                    d_c_defense: analysisMode === "from_zero" ? 0 : safeNum(inputs.d_c_defense),
                };

                const d_original = calculateDamage(
                    safeNum(inputs.D),
                    safeNum(inputs.R),
                    safeNum(inputs.b_s),
                    baseParams.d_s,
                    baseParams.d_f,
                    safeNum(inputs.b_d),
                    baseParams.d_d,
                    safeNum(inputs.E),
                    safeNum(inputs.b_e),
                    baseParams.d_e,
                    safeNum(inputs.b_c),
                    safeNum(inputs.d_c),
                    safeNum(inputs.h),
                    baseParams.b_b,
                    baseParams.b_c_defense,
                    baseParams.d_c_defense,
                    safeNum(inputs.flow_percent),
                    safeNum(inputs.damage_increase),
                    safeNum(inputs.flow_resist_percent),
                    safeNum(inputs.damage_reduction),
                    safeNum(inputs.skill_damage_increase),
                    safeNum(inputs.skill_damage_reduction),
                    safeNum(inputs.lambda_1),
                    safeNum(inputs.lambda_2),
                    safeNum(inputs.lambda_3),
                    safeNum(inputs.lambda_4),
                    safeNum(inputs.W),
                    safeNum(inputs.gold_i),
                    safeNum(inputs.skill_multiplier)
                );

                const calculateReduction = (attr, value) => {
                    const params = { ...baseParams };
                    const increment = attr === "d_c_defense" ? Math.min(2.0, Math.max(0.01, value / 200 * 0.01)) : value;
                    params[attr] = (analysisMode === "from_zero" ? 0 : safeNum(inputs[attr])) + increment;
                    const d_reduced = calculateDamage(
                        safeNum(inputs.D),
                        safeNum(inputs.R),
                        safeNum(inputs.b_s),
                        params.d_s,
                        params.d_f,
                        safeNum(inputs.b_d),
                        params.d_d,
                        safeNum(inputs.E),
                        safeNum(inputs.b_e),
                        params.d_e,
                        safeNum(inputs.b_c),
                        safeNum(inputs.d_c),
                        safeNum(inputs.h),
                        params.b_b,
                        params.b_c_defense,
                        params.d_c_defense,
                        safeNum(inputs.flow_percent),
                        safeNum(inputs.damage_increase),
                        safeNum(inputs.flow_resist_percent),
                        safeNum(inputs.damage_reduction),
                        safeNum(inputs.skill_damage_increase),
                        safeNum(inputs.skill_damage_reduction),
                        safeNum(inputs.lambda_1),
                        safeNum(inputs.lambda_2),
                        safeNum(inputs.lambda_3),
                        safeNum(inputs.lambda_4),
                        safeNum(inputs.W),
                        safeNum(inputs.gold_i),
                        safeNum(inputs.skill_multiplier)
                    );
                    const reduction = d_original && isFinite(d_original) && d_original > 0 && d_reduced >= 0
                        ? Math.max(0, (1 - d_reduced / d_original) * 100)
                        : 0;
                    return isNaN(reduction) || !isFinite(reduction) ? 0 : reduction;
                };

                attribute_points.forEach((point) => {
                    reductions.d_s.push(calculateReduction("d_s", point));
                    reductions.d_d.push(calculateReduction("d_d", point));
                    reductions.d_f.push(calculateReduction("d_f", point));
                    reductions.d_e.push(calculateReduction("d_e", point));
                    reductions.b_b.push(calculateReduction("b_b", point));
                    reductions.b_c_defense.push(calculateReduction("b_c_defense", point));
                });

                for (let i = 1; i < reductions.d_s.length; i++) {
                    delta_reductions.d_s.push(Math.max(0, reductions.d_s[i] - reductions.d_s[i - 1]));
                    delta_reductions.d_d.push(Math.max(0, reductions.d_d[i] - reductions.d_d[i - 1]));
                    delta_reductions.d_f.push(Math.max(0, reductions.d_f[i] - reductions.d_f[i - 1]));
                    delta_reductions.d_e.push(Math.max(0, reductions.d_e[i] - reductions.d_e[i - 1]));
                    delta_reductions.b_b.push(Math.max(0, reductions.b_b[i] - reductions.b_b[i - 1]));
                    delta_reductions.b_c_defense.push(Math.max(0, reductions.b_c_defense[i] - reductions.b_c_defense[i - 1]));
                }

                const deltaData = attribute_points.slice(1).map((point, i) => ({
                    point,
                    d_s: delta_reductions.d_s[i],
                    d_d: delta_reductions.d_d[i],
                    d_f: delta_reductions.d_f[i],
                    d_e: delta_reductions.d_e[i],
                    b_b: delta_reductions.b_b[i],
                    b_c_defense: delta_reductions.b_c_defense[i],
                }));

                const reductionData = attribute_points.map((point, i) => ({
                    point,
                    d_s: reductions.d_s[i],
                    d_d: reductions.d_d[i],
                    d_f: reductions.d_f[i],
                    d_e: reductions.d_e[i],
                    b_b: reductions.b_b[i],
                    b_c_defense: reductions.b_c_defense[i],
                }));

                return { deltaData, reductionData };
            };

            // 輸入處理
            const handleChange = (e) => {
                const { name, value } = e.target;
                if (name === "gold_i" || name === "W") {
                    setInputs((prev) => ({ ...prev, [name]: value }));
                    setInputErrors((prev) => ({ ...prev, [name]: "" }));
                } else {
                    if (value > 1000000) {
                        setInputErrors((prev) => ({
                            ...prev,
                            [name]: "輸入值過大，最大為1000000",
                        }));
                        return;
                    }
                    setInputs((prev) => ({ ...prev, [name]: value }));
                    setInputErrors((prev) => ({ ...prev, [name]: "" }));
                }
            };

            // 處理滑塊或文本框變化
            const handleInvestmentChange = (attr, value) => {
                setInvestmentPoints((prev) => ({
                    ...prev,
                    [attr]: Math.min(1000, Math.max(1, parseInt(value) || 1)),
                }));
                analyzeDefenseOptions();
            };

            // 切換曲線可見性
            const toggleVisibility = (key) => {
                setVisibility((prev) => ({ ...prev, [key]: !prev[key] }));
            };

            // 全選曲線
            const handleSelectAll = () => {
                const allSelected = {};
                recommendationData.forEach((attr) => {
                    if (attr.attribute !== "d_c_defense") {
                        allSelected[attr.attribute] = true;
                    }
                });
                setSelectedCurves(allSelected);
                setVisibility(allSelected);
            };

            // 全不選曲線
            const handleDeselectAll = () => {
                setSelectedCurves({});
                setVisibility({});
            };

            // 切換單條曲線
            const handleCurveToggle = (attribute) => {
                setSelectedCurves((prev) => ({
                    ...prev,
                    [attribute]: !prev[attribute],
                }));
                setVisibility((prev) => ({
                    ...prev,
                    [attribute]: !prev[attribute],
                }));
            };

            // 防禦選項分析
            const analyzeDefenseOptions = () => {
                const attackInputs = {
                    skill_multiplier: inputs.skill_multiplier,
                    D: inputs.D,
                    E: inputs.E,
                    b_c: inputs.b_c,
                    d_c: inputs.d_c,
                    R: inputs.R,
                    h: inputs.h,
                    b_d: inputs.b_d,
                    b_s: inputs.b_s,
                    b_e: inputs.b_e,
                    flow_percent: inputs.flow_percent,
                    damage_increase: inputs.damage_increase,
                    skill_damage_increase: inputs.skill_damage_increase,
                    W: inputs.W,
                    gold_i: inputs.gold_i,
                };
                const defenseInputs = {
                    d_s: inputs.d_s,
                    d_f: inputs.d_f,
                    d_d: inputs.d_d,
                    d_e: inputs.d_e,
                    b_b: inputs.b_b,
                    hp: inputs.hp,
                    b_c_defense: inputs.b_c_defense,
                    d_c_defense: inputs.d_c_defense,
                    flow_resist_percent: inputs.flow_resist_percent,
                    damage_reduction: inputs.damage_reduction,
                    skill_damage_reduction: inputs.skill_damage_reduction,
                };
                const constants = {
                    lambda_1: inputs.lambda_1,
                    lambda_2: inputs.lambda_2,
                    lambda_3: inputs.lambda_3,
                    lambda_4: inputs.lambda_4,
                };

                const baseDamage = parseFloat(calculate({ ...attackInputs, ...defenseInputs, ...constants }).finalDamage) || 0;
                if (!baseDamage || isNaN(baseDamage) || !isFinite(baseDamage) || baseDamage <= 0) {
                    console.error("Base damage is invalid:", baseDamage);
                    setRecommendationData([]);
                    setAnalysisData([]);
                    return;
                }

                const defenseAttributes = [
                    { key: "d_s", label: "氣盾", increment: 200, type: "shield" },
                    { key: "d_f", label: "流派抵禦", increment: 200, type: "flow" },
                    { key: "d_d", label: "防禦", increment: 200, type: "defense" },
                    { key: "d_e", label: "元素抗性", increment: 200, type: "element" },
                    { key: "b_b", label: "格擋", increment: 200, type: "block" },
                    { key: "b_c_defense", label: "抗會心數值", increment: 200, type: "crit_resist" },
                    { key: "d_c_defense_percent", label: "會心防禦%（百分比）", increment: critDefensePercent, type: "crit_defense_percent" },
                ];

                const benefits = [];
                const points = 200;

                defenseAttributes.forEach((attr) => {
                    const modifiedDefense = { ...defenseInputs };
                    let increment;

                    if (attr.key === "d_c_defense") {
                        increment = Math.min(2.0, Math.max(0.01, points / 200 * 0.01));
                    } else if (attr.key === "d_c_defense_percent") {
                        increment = critDefensePercent / 100; // 使用百分比
                    } else {
                        increment = points;
                    }

                    modifiedDefense[attr.key === "d_c_defense_percent" ? "d_c_defense" : attr.key] = safeNum(defenseInputs[attr.key === "d_c_defense_percent" ? "d_c_defense" : attr.key]) + increment;

                    const newDamage = parseFloat(calculate({ ...attackInputs, ...modifiedDefense, ...constants }).finalDamage) || 0;
                    const damageReduction = baseDamage && isFinite(baseDamage) && baseDamage > 0
                        ? Math.max(0, ((baseDamage - newDamage) / baseDamage) * 100)
                        : 0;
                    benefits.push({
                        attribute: attr.key,
                        label: attr.label,
                        type: attr.type,
                        damageReduction,
                        currentValue: defenseInputs[attr.key === "d_c_defense_percent" ? "d_c_defense" : attr.key],
                        increment: increment,
                        efficiency: damageReduction / (points / 200) || 0,
                    });
                });

                const sortedBenefits = benefits.sort((a, b) => b.damageReduction - a.damageReduction);
                setRecommendationData(sortedBenefits);

                const initialSelected = {};
                sortedBenefits.forEach((attr, index) => {
                    if (attr.attribute !== "d_c_defense") {
                        initialSelected[attr.attribute] = index < 5;
                    }
                });
                if (Object.keys(selectedCurves).length === 0) {
                    setSelectedCurves(initialSelected);
                    setVisibility(initialSelected);
                }

                const chartData = [];
                const pointsRange = Array.from({ length: 26 }, (_, i) => i * 400);

                pointsRange.forEach((totalPoints) => {
                    const point = { points: totalPoints };
                    sortedBenefits.forEach((attr) => {
                        if (attr.attribute === "d_c_defense") return; // 跳過 d_c_defense
                        const modifiedDefense =
                            analysisMode === "from_zero" ? { ...zeroDefense } : { ...defenseInputs };
                        const increment =
                            attr.attribute === "d_c_defense"
                                ? Math.min(2.0, Math.max(0.01, totalPoints / 200 * 0.01))
                                : totalPoints;
                        const baseValue =
                            analysisMode === "from_zero"
                                ? 0
                                : safeNum(defenseInputs[attr.attribute]);
                        modifiedDefense[attr.attribute] = baseValue + increment;
                        const referenceDamage =
                            analysisMode === "from_zero"
                                ? parseFloat(calculate({ ...attackInputs, ...zeroDefense, ...constants }).finalDamage) || 0
                                : baseDamage;
                        const newDamage = parseFloat(calculate({ ...attackInputs, ...modifiedDefense, ...constants }).finalDamage) || 0;
                        const reduction = referenceDamage && isFinite(referenceDamage) && referenceDamage > 0
                            ? Math.max(0, ((referenceDamage - newDamage) / referenceDamage) * 100)
                            : 0;
                        point[attr.attribute] = reduction;
                    });
                    chartData.push(point);
                });

                setAnalysisData(chartData);
                console.log("Analysis Data:", chartData);
                console.log("Recommendation Data:", sortedBenefits);
            };

            // 當輸入或分析模式變化時更新分析
            useEffect(() => {
                analyzeDefenseOptions();
            }, [inputs, analysisMode, investmentPoints, critDefensePercent]);

            const CustomTooltip = ({ active, payload, label, isDelta }) => {
                if (active && payload && payload.length) {
                    return (
                        <div className="bg-white p-3 border border-gray-200 rounded-lg shadow-sm">
                            <p className="text-sm text-gray-700 font-medium">屬性點: {label}</p>
                            {payload.map((entry, index) => (
                                <p key={index} className="text-sm text-gray-600">
                                    <span style={{ color: entry.stroke }}>{entry.name}</span>:{" "}
                                    {(entry.value * (isDelta ? 1 : 1)).toFixed(isDelta ? 4 : 2)}%
                                </p>
                            ))}
                        </div>
                    );
                }
                return null;
            };

            const result = calculate(inputs);
            const { deltaData, reductionData } = generateChartData(inputs);

            // 保存方案
            const saveCurrentPreset = () => {
                if (presets.length >= 4) return alert("最多只能保存 4 組方案！");
                const name = prompt("請輸入方案名稱：");
                if (!name) return;
                const newPresets = [...presets, { name, data: inputs }];
                setPresets(newPresets);
            };

            // 載入方案
            const loadPreset = (i) => {
                setInputs(presets[i].data);
                analyzeDefenseOptions();
            };

            // 刪除方案
            const deletePreset = (i) => {
                const updated = presets.filter((_, idx) => idx !== i);
                setPresets(updated);
            };

            // 對比方案
            const comparePresets = () => {
                const a = presets[compareIndexes.a]?.data;
                const b = presets[compareIndexes.b]?.data;
                if (!a || !b) return;

                const diff = {};
                Object.keys(a).forEach((key) => {
                    diff[key] = safeNum(b[key]) - safeNum(a[key]);
                });

                const resultA = calculate(a);
                const resultB = calculate(b);

                setCompareResult({
                    diff,
                    resultDiff: {
                        baseDamage: safeNum(resultB.baseDamage) - safeNum(resultA.baseDamage),
                        finalDamage: safeNum(resultB.finalDamage) - safeNum(resultA.finalDamage),
                        totalReduction: safeNum(resultB.totalReduction) - safeNum(resultA.totalReduction),
                    },
                });
            };

            const colors = [
                "#3b82f6",
                "#10b981",
                "#8b5cf6",
                "#14b8a6",
                "#f97316",
                "#d084d0",
            ];

            return (
                <div className="p-4 container mx-auto min-h-screen bg-gray-50">
                    {/* 標題 */}
                    <div className="bg-gradient-to-r from-pink-500 to-red-500 rounded-xl p-6 mb-6 shadow-lg">
                        <h1 className="text-xl md:text-2xl font-bold text-center text-white">
                            防守屬性收益計算器
                        </h1>
                        <p className="text-center text-white text-opacity-90 text-sm mt-1">
                            如有問題請聯繫櫻桃白蘭地@緣定今生
                        </p>
                    </div>

                    {/* 攻擊方參數 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-4">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowAttacker(!showAttacker)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    攻擊方參數
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showAttacker ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showAttacker ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                {[
                                    {
                                        key: "skill_multiplier",
                                        label: "技能倍率",
                                        icon: "🔥",
                                        tooltip: "如技能倍率為300%，輸入300",
                                    },
                                    { key: "D", label: "攻擊", icon: "⚔️" },
                                    { key: "E", label: "元素攻擊（平均）", icon: "✨" },
                                    { key: "b_c", label: "會心數值", icon: "🎯" },
                                    {
                                        key: "d_c",
                                        label: "會心傷害",
                                        icon: "💥",
                                        tooltip: "除以100，例如180%，輸入1.8",
                                    },
                                    { key: "R", label: "流派克制", icon: "🔄" },
                                    { key: "h", label: "命中", icon: "🎯" },
                                    { key: "b_d", label: "破防", icon: "🛡️" },
                                    { key: "b_s", label: "破盾", icon: "🔨" },
                                    { key: "b_e", label: "忽視元素抗性", icon: "🌀" },
                                    {
                                        key: "flow_percent",
                                        label: "流派克制%",
                                        icon: "📊",
                                        tooltip:
                                            "例如9.5%，輸入0.095。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "damage_increase",
                                        label: "增傷%",
                                        icon: "📈",
                                        tooltip:
                                            "除以100，例如5%，輸入0.05。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "skill_damage_increase",
                                        label: "技能增傷%",
                                        icon: "📈",
                                        tooltip:
                                            "除以100，例如5%，輸入0.05。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "gold_i",
                                        label: "金周天",
                                        icon: "🌟",
                                        type: "select",
                                        options: goldOptions,
                                    },
                                    {
                                        key: "W",
                                        label: "元素弱點",
                                        icon: "💢",
                                        type: "select",
                                        options: elementWeaknessOptions,
                                    },
                                ].map(({ key, label, icon, type, options, tooltip }) => (
                                    <div key={key} className="flex flex-col group relative">
                                        <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                            <span className="mr-1 md:mr-2">{icon}</span>
                                            {label}
                                            {tooltip && (
                                                <>
                                                    <span className="ml-1 flex items-center justify-center w-4 h-4 rounded-full bg-gray-400 text-white text-xs cursor-help">
                                                        ?
                                                    </span>
                                                    <div className="absolute left-0 top-8 bg-gray-800 text-white text-xs p-2 rounded-lg shadow-md z-10 max-w-xs opacity-0 group-hover:opacity-100 transition-opacity">
                                                        {tooltip}
                                                    </div>
                                                </>
                                            )}
                                        </label>
                                        {type === "select" ? (
                                            <select
                                                name={key}
                                                value={inputs[key]}
                                                onChange={handleChange}
                                                className="border border-gray-200 rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors"
                                                aria-label={label}
                                            >
                                                {options.map((opt) => (
                                                    <option key={opt.value} value={opt.value}>
                                                        {opt.label}
                                                    </option>
                                                ))}
                                            </select>
                                        ) : (
                                            <input
                                                type="number"
                                                name={key}
                                                value={inputs[key]}
                                                onChange={handleChange}
                                                className={`border ${inputErrors[key] ? "border-red-500" : "border-gray-200"} rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors`}
                                                aria-label={label}
                                            />
                                        )}
                                        {inputErrors[key] && (
                                            <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                                        )}
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* 防守方參數 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-4">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowDefender(!showDefender)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    防守方參數
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showDefender ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showDefender ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                {[
                                    { key: "d_s", label: "氣盾", icon: "🛡️" },
                                    { key: "d_f", label: "流派抵禦", icon: "🔄" },
                                    { key: "d_d", label: "防禦", icon: "🏰" },
                                    { key: "d_e", label: "元素抗性", icon: "🌀" },
                                    { key: "b_b", label: "格擋", icon: "✋" },
                                    { key: "hp", label: "氣血", icon: "❤️" },
                                    { key: "b_c_defense", label: "抗會心數值", icon: "🎯" },
                                    {
                                        key: "d_c_defense",
                                        label: "會心防禦%",
                                        icon: "📊",
                                        tooltip:
                                            "除以100，例如25%，輸入0.25。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "flow_resist_percent",
                                        label: "流派抵禦%",
                                        icon: "📊",
                                        tooltip:
                                            "除以100，例如5%，輸入0.05。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "damage_reduction",
                                        label: "傷害減免%",
                                        icon: "📉",
                                        tooltip:
                                            "除以100，例如15%，輸入0.15。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "skill_damage_reduction",
                                        label: "技能減免%",
                                        icon: "📉",
                                        tooltip:
                                            "除以100，例如5%，輸入0.05。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                ].map(({ key, label, icon, tooltip }) => (
                                    <div key={key} className="flex flex-col group relative">
                                        <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                            <span className="mr-1 md:mr-2">{icon}</span>
                                            {label}
                                            {tooltip && (
                                                <>
                                                    <span className="ml-1 flex items-center justify-center w-4 h-4 rounded-full bg-gray-400 text-white text-xs cursor-help">
                                                        ?
                                                    </span>
                                                    <div className="absolute left-0 top-8 bg-gray-800 text-white text-xs p-2 rounded-lg shadow-md z-10 max-w-xs opacity-0 group-hover:opacity-100 transition-opacity">
                                                        {tooltip}
                                                    </div>
                                                </>
                                            )}
                                        </label>
                                        <input
                                            type="number"
                                            name={key}
                                            value={inputs[key]}
                                            onChange={handleChange}
                                            className={`border ${inputErrors[key] ? "border-red-500" : "border-gray-200"} rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors`}
                                            aria-label={label}
                                        />
                                        {inputErrors[key] && (
                                            <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                                        )}
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* 原數值屬性和減傷後屬性 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowOriginal(!showOriginal)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    原數值屬性
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showOriginal ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showOriginal ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="grid grid-cols-2 gap-3 mb-4">
                                <div className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-gray-600">真實會心</p>
                                    <p className="text-sm font-bold text-gray-800">{result.c_original}</p>
                                </div>
                                <div className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-gray-600">會心率</p>
                                    <p className="text-sm font-bold text-gray-800">{result.p_c_original}</p>
                                </div>

                                {/* 官方預測命中率 - 原数值 */}
                                <div className="bg-blue-50 p-2 md:p-3 rounded-lg border border-blue-200">
                                    <p className="text-xs text-blue-600">官方預測命中率</p>
                                    <p className="text-sm font-bold text-blue-800">{result.p_h_original}</p>
                                </div>

                                <div className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-gray-600">會心傷害倍率</p>
                                    <p className="text-sm font-bold text-gray-800">{result.m_c_original}</p>
                                </div>
                                <div className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-gray-600">傷害倍率</p>
                                    <p className="text-sm font-bold text-gray-800">{result.d_mul_original}</p>
                                </div>
                                <div className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-gray-600">剩餘氣盾</p>
                                    <p className="text-sm font-bold text-gray-800">{result.G_original}</p>
                                </div>
                                <div className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-gray-600">防禦傷害減免</p>
                                    <p className="text-sm font-bold text-gray-800">{result.gamma_original}</p>
                                </div>
                                <div className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-gray-600">元素傷害減免</p>
                                    <p className="text-sm font-bold text-gray-800">{result.beta_original}</p>
                                </div>
                            </div>
                        </div>

                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowReduced(!showReduced)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    減傷後屬性
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showReduced ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showReduced ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="grid grid-cols-2 gap-3">
                                <div className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-pink-600">修正會心</p>
                                    <p className="text-sm font-bold text-pink-800">{result.c}</p>
                                </div>
                                <div className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-pink-600">會心率</p>
                                    <p className="text-sm font-bold text-pink-800">{result.p_c}</p>
                                </div>

                                {/* 官方預測命中率/格擋率 */}
                                <div className="bg-blue-50 p-2 md:p-3 rounded-lg border border-blue-200">
                                    <p className="text-xs text-blue-600">官方預測命中率</p>
                                    <p className="text-sm font-bold text-blue-800">{result.p_h_official}</p>
                                </div>
                                <div className="bg-blue-50 p-2 md:p-3 rounded-lg border border-blue-200">
                                    <p className="text-xs text-blue-600">官方預測格擋率</p>
                                    <p className="text-sm font-bold text-blue-800">{result.block_rate_official}</p>
                                </div>

                                {/* 實戰預測命中率/格擋率 */}
                                <div className="bg-green-50 p-2 md:p-3 rounded-lg border border-green-200 group relative">
                                    <p className="text-xs text-green-600 flex items-center">
                                        實戰預測命中率
                                        <span className="ml-1 flex items-center justify-center w-3 h-3 rounded-full bg-gray-400 text-white text-xs cursor-help">
                                            ?
                                        </span>
                                        <div className="absolute left-0 bottom-full mb-2 bg-gray-800 text-white text-xs p-2 rounded-lg shadow-md z-10 max-w-xs opacity-0 group-hover:opacity-100 transition-opacity whitespace-normal">
                                            必中傷害如火周天、神特、眾妙的灼燒傷害會影響命中率顯示，實際技能命中率不變
                                        </div>
                                    </p>
                                    <div className="flex items-center gap-2">
                                        <p className="text-sm font-bold text-green-800">{result.p_h_practical}</p>
                                        {result.hit_mode === "FLOOR_ACTIVE" && (
                                            <span className="text-xs bg-orange-500 text-white px-2 py-0.5 rounded-full">
                                                保底
                                            </span>
                                        )}
                                    </div>
                                </div>
                                <div className="bg-green-50 p-2 md:p-3 rounded-lg border border-green-200">
                                    <p className="text-xs text-green-600">實戰預測格擋率</p>
                                    <p className="text-sm font-bold text-green-800">{result.block_rate_practical}</p>
                                </div>

                                <div className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-pink-600">會心傷害倍率</p>
                                    <p className="text-sm font-bold text-pink-800">{result.m_c}</p>
                                </div>
                                <div className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-pink-600">傷害倍率</p>
                                    <p className="text-sm font-bold text-pink-800">{result.d_mul}</p>
                                </div>
                                <div className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-pink-600">剩餘氣盾</p>
                                    <p className="text-sm font-bold text-pink-800">{result.G}</p>
                                </div>
                                <div className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-pink-600">防禦傷害減免</p>
                                    <p className="text-sm font-bold text-pink-800">{result.gamma}</p>
                                </div>
                                <div className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-pink-600">元素傷害減免</p>
                                    <p className="text-sm font-bold text-pink-800">{result.beta}</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* 傷害計算結果 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowDamageResult(!showDamageResult)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    傷害計算結果
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showDamageResult ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showDamageResult ? "max-h-[3000px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="flex justify-end items-center mb-4">
                                <button
                                    className="bg-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-pink-700 transition-colors"
                                    onClick={saveCurrentPreset}
                                >
                                    保存當前方案
                                </button>
                            </div>
                            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-3 mt-6">
                                {[
                                    { label: "原傷害", value: result.baseDamage, color: "pink-100" },
                                    {
                                        label: "減傷後傷害",
                                        value: result.finalDamage,
                                        color: "pink-100",
                                    },
                                    { label: "有效氣血 (EHP)", value: result.ehp, color: "pink-100" },
                                    {
                                        label: "總減傷率",
                                        value: result.totalReduction,
                                        color: "pink-500",
                                        text: "white",
                                    },
                                ].map(({ label, value, color, text }) => (
                                    <div key={label} className={`bg-${color} p-3 rounded-lg`}>
                                        <p
                                            className={`text-xs ${text ? `text-${text}` : "text-pink-700"}`}
                                        >
                                            {label}
                                        </p>
                                        <p
                                            className={`text-lg font-bold ${text ? `text-${text}` : "text-pink-800"}`}
                                        >
                                            {value}
                                        </p>
                                    </div>
                                ))}
                            </div>
                            <div className="mt-6">
                                <div className="flex justify-between items-center mb-2">
                                    <div className="flex items-center">
                                        <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                        <h4 className="font-bold text-base text-gray-800">
                                            防禦投資優先級 （！下方先選增量模式！）
                                        </h4>
                                    </div>
                                </div>
                                <div>
                                    <p className="text-sm text-gray-600 mb-4">
                                        針對當前攻擊配置，通過拖動拉桿或輸入數值調整投資點數（1-1000），實時查看從現有面板基礎上的減傷效果
                                    </p>
                                    {recommendationData.length > 0 ? (
                                        <div className="space-y-4">
                                            {[
                                                { key: "d_s", label: "氣盾" },
                                                { key: "d_f", label: "流派抵禦" },
                                                { key: "d_d", label: "防禦" },
                                                { key: "d_e", label: "元素抗性" },
                                                { key: "b_b", label: "格擋" },
                                                { key: "b_c_defense", label: "抗會心數值" },
                                            ].map(({ key, label }) => {
                                                const reduction = calculateInvestmentReduction(key, investmentPoints[key]);
                                                const maxReduction = Math.max(
                                                    ...Object.keys(investmentPoints).map((attr) =>
                                                        calculateInvestmentReduction(attr, investmentPoints[attr])
                                                    ),
                                                    0.0001
                                                );
                                                const barWidth = `${(reduction / maxReduction) * 100}%`;
                                                return (
                                                    <div key={key} className="flex items-center gap-4">
                                                        <span className="w-24 text-sm font-semibold text-gray-700">{label}</span>
                                                        <input
                                                            type="range"
                                                            min="1"
                                                            max="1000"
                                                            value={investmentPoints[key]}
                                                            onChange={(e) => handleInvestmentChange(key, e.target.value)}
                                                            className="w-1/3 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                        />
                                                        <input
                                                            type="number"
                                                            min="1"
                                                            max="1000"
                                                            value={investmentPoints[key]}
                                                            onChange={(e) => {
                                                                const value = Math.min(1000, Math.max(1, parseInt(e.target.value) || 1));
                                                                handleInvestmentChange(key, value);
                                                            }}
                                                            className="w-20 p-2 border border-gray-200 rounded-lg text-sm focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors"
                                                        />
                                                        <div className="w-1/3 bg-gray-200 rounded-full h-2.5">
                                                            <div
                                                                className="bg-pink-500 h-2.5 rounded-full"
                                                                style={{ width: barWidth }}
                                                            ></div>
                                                        </div>
                                                        <span className="text-sm text-gray-700">
                                                            {reduction.toFixed(2)}% 減傷
                                                        </span>
                                                    </div>
                                                );
                                            })}
                                            <div className="flex items-center gap-4">
                                                <span className="w-24 text-sm font-semibold text-gray-700">會心防禦%</span>
                                                <input
                                                    type="range"
                                                    min="1"
                                                    max="100"
                                                    value={critDefensePercent}
                                                    onChange={(e) => handleCritDefensePercentChange(e.target.value)}
                                                    className="w-1/3 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                />
                                                <div className="relative w-20">
                                                    <input
                                                        type="number"
                                                        min="1"
                                                        max="100"
                                                        value={critDefensePercent}
                                                        onChange={(e) => {
                                                            const value = Math.min(100, Math.max(1, parseInt(e.target.value) || 1));
                                                            handleCritDefensePercentChange(value);
                                                        }}
                                                        className="w-full p-2 pr-6 border border-gray-200 rounded-lg text-sm focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors"
                                                    />
                                                    <span className="absolute right-2 top-1/2 transform -translate-y-1/2 text-sm text-gray-500">%</span>
                                                </div>
                                                <div className="w-1/3 bg-gray-200 rounded-full h-2.5">
                                                    <div
                                                        className="bg-pink-500 h-2.5 rounded-full"
                                                        style={{
                                                            width: `${(calculateInvestmentReduction('d_c_defense_percent', critDefensePercent) / Math.max(
                                                                ...Object.keys(investmentPoints).map((attr) =>
                                                                    calculateInvestmentReduction(attr, investmentPoints[attr])
                                                                ),
                                                                calculateInvestmentReduction('d_c_defense_percent', critDefensePercent),
                                                                0.0001
                                                            )) * 100}%`
                                                        }}
                                                    ></div>
                                                </div>
                                                <span className="text-sm text-gray-700">
                                                    {calculateInvestmentReduction('d_c_defense_percent', critDefensePercent).toFixed(2)}% 減傷
                                                </span>
                                            </div>
                                        </div>
                                    ) : (
                                        <p className="text-sm text-red-600">
                                            無法生成投資優先級數據，請檢查輸入值。
                                        </p>
                                    )}
                                </div>
                            </div>

                            {/* 針對性配裝建議 */}
                            <div className="mt-6 bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4 text-gray-700 flex items-center">
                                    <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                    針對性配裝建議
                                </h2>
                                <div className="space-y-3">
                                    {recommendationData.length > 0 ? (
                                        <>
                                            <div className="flex items-center justify-between p-4 bg-green-50 rounded-lg border-l-4 border-green-500">
                                                <div>
                                                    <span className="font-semibold text-green-800">
                                                        最優投資: {recommendationData[0]?.label}
                                                    </span>
                                                    <p className="text-sm text-green-600 mt-1">
                                                        投資200點數可減傷{" "}
                                                        {recommendationData[0]?.damageReduction.toFixed(3)}%
                                                    </p>
                                                </div>
                                            </div>
                                            {recommendationData.length > 1 && (
                                                <div className="flex items-center justify-between p-4 bg-yellow-50 rounded-lg border-l-4 border-yellow-500">
                                                    <div>
                                                        <span className="font-semibold text-yellow-800">
                                                            次優選擇: {recommendationData[1]?.label}
                                                        </span>
                                                        <p className="text-sm text-yellow-600 mt-1">
                                                            投資200點數可減傷{" "}
                                                            {recommendationData[1]?.damageReduction.toFixed(3)}%
                                                        </p>
                                                    </div>
                                                </div>
                                            )}
                                            <div className="p-4 bg-blue-50 rounded-lg border-l-4 border-blue-500">
                                                <span className="font-semibold text-blue-800">
                                                    配裝策略建議:
                                                </span>
                                                <p className="text-sm text-blue-600 mt-1">
                                                    面對「敵方當前攻擊配置」時，優先堆疊 {recommendationData[0]?.label}{" "}
                                                    {recommendationData[1] ? `和 ${recommendationData[1]?.label}` : ""}，
                                                    可以獲得最佳的防禦效果。

                                                    <>
                                                        <br />
                                                        請注意，各裝備投放屬性數值不一致，推薦只限200點内收益，使用「從零分析」模式可以看到新角色從頭開始配裝的最優方向。
                                                    </>

                                                </p>
                                            </div>
                                        </>
                                    ) : (
                                        <p className="text-sm text-gray-500">正在生成建議，請稍候...</p>
                                    )}
                                </div>
                            </div>

                            {/* 方案列表 */}
                            <div className="mt-6">
                                <h4 className="font-semibold text-base text-gray-800 mb-3 flex items-center">
                                    <span className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></span>
                                    保存的方案
                                </h4>
                                {presets.length === 0 ? (
                                    <p className="text-sm text-gray-500">尚未保存任何方案</p>
                                ) : (
                                    <div className="grid gap-2">
                                        {presets.map((preset, index) => (
                                            <div
                                                key={index}
                                                className="flex items-center justify-between p-3 bg-pink-50 rounded-lg hover:bg-pink-100 transition-colors duration-200"
                                            >
                                                <span className="font-medium text-gray-700">{preset.name}</span>
                                                <div className="flex gap-2">
                                                    <button
                                                        className="text-sm text-green-600 hover:text-green-800 font-medium transition-colors duration-200 flex items-center gap-1"
                                                        onClick={() => loadPreset(index)}
                                                    >
                                                        載入
                                                    </button>
                                                    <button
                                                        className="text-sm text-red-600 hover:text-red-800 font-medium transition-colors duration-200 flex items-center gap-1"
                                                        onClick={() => deletePreset(index)}
                                                    >
                                                        刪除
                                                    </button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>

                            {/* 方案對比 */}
                            {presets.length >= 2 && (
                                <div className="mt-6">
                                    <h4 className="font-semibold text-base text-gray-800 mb-3 flex items-center">
                                        <span className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></span>
                                        對比兩個方案
                                    </h4>
                                    <div className="flex flex-col sm:flex-row gap-3 items-start sm:items-center">
                                        <select
                                            className="w-full sm:w-40 border border-gray-300 rounded-lg p-2 text-sm text-gray-700 focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors duration-200"
                                            onChange={(e) =>
                                                setCompareIndexes((prev) => ({ ...prev, a: e.target.value }))
                                            }
                                        >
                                            <option value="">選擇方案</option>
                                            {presets.map((p, i) => (
                                                <option value={i} key={"a" + i}>
                                                    {p.name}
                                                </option>
                                            ))}
                                        </select>
                                        <select
                                            className="w-full sm:w-40 border border-gray-300 rounded-lg p-2 text-sm text-gray-700 focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors duration-200"
                                            onChange={(e) =>
                                                setCompareIndexes((prev) => ({ ...prev, b: e.target.value }))
                                            }
                                        >
                                            <option value="">選擇方案</option>
                                            {presets.map((p, i) => (
                                                <option value={i} key={"b" + i}>
                                                    {p.name}
                                                </option>
                                            ))}
                                        </select>
                                        <button
                                            className="w-full sm:w-auto bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-lg font-medium text-sm transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                                            onClick={comparePresets}
                                            disabled={compareIndexes.a === null || compareIndexes.b === null}
                                        >
                                            開始對比
                                        </button>
                                    </div>
                                    {compareResult && (
                                        <div className="mt-4">
                                            <div className="flex justify-between items-center mb-2">
                                                <h4 className="font-semibold text-base text-gray-800">
                                                    方案對比（B - A）
                                                </h4>
                                                <button
                                                    className="text-sm text-pink-600 hover:text-pink-800 font-medium flex items-center gap-1"
                                                    onClick={() => setIsTableExpanded(!isTableExpanded)}
                                                >
                                                    {isTableExpanded ? "收起" : "展開"}
                                                </button>
                                            </div>
                                            {isTableExpanded && (
                                                <div className="overflow-x-auto transition-all duration-300">
                                                    <table className="w-full text-sm border-collapse">
                                                        <thead>
                                                            <tr className="bg-pink-50">
                                                                <th className="border p-2 text-left text-pink-700">
                                                                    項目
                                                                </th>
                                                                <th className="border p-2 text-left text-pink-700">
                                                                    {presets[compareIndexes.a]?.name || "方案 A"}
                                                                </th>
                                                                <th className="border p-2 text-left text-pink-700">
                                                                    {presets[compareIndexes.b]?.name || "方案 B"}
                                                                </th>
                                                                <th className="border p-2 text-left text-pink-700">
                                                                    差異
                                                                </th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            {[
                                                                { key: "hp", label: "氣血 (hp)" },
                                                                { key: "d_s", label: "氣盾 (d_s)" },
                                                                { key: "d_d", label: "防禦 (d_d)" },
                                                                { key: "d_f", label: "流派抵禦 (d_f)" },
                                                                { key: "d_e", label: "元素抗性 (d_e)" },
                                                                { key: "b_b", label: "格擋 (b_b)" },
                                                                { key: "baseDamage", label: "原傷害" },
                                                                { key: "finalDamage", label: "減傷後傷害" },
                                                                { key: "ehp", label: "有效氣血 (EHP)" },
                                                                { key: "totalReduction", label: "總減傷率" },
                                                            ].map(({ key, label }) => {
                                                                const aValue =
                                                                    key in presets[compareIndexes.a].data
                                                                        ? presets[compareIndexes.a].data[key]
                                                                        : calculate(presets[compareIndexes.a].data)[key];
                                                                const bValue =
                                                                    key in presets[compareIndexes.b].data
                                                                        ? presets[compareIndexes.b].data[key]
                                                                        : calculate(presets[compareIndexes.b].data)[key];
                                                                const aNum = parseFloat(aValue.replace("%", "")) || 0;
                                                                const bNum = parseFloat(bValue.replace("%", "")) || 0;
                                                                const diff = bNum - aNum;
                                                                const isPositive = diff >= 0;
                                                                return (
                                                                    <tr key={key} className="hover:bg-pink-50">
                                                                        <td className="border p-2 text-gray-700">
                                                                            {label}
                                                                        </td>
                                                                        <td className="border p-2 font-medium">{aValue}</td>
                                                                        <td className="border p-2 font-medium">{bValue}</td>
                                                                        <td
                                                                            className={`border p-2 font-medium ${isPositive ? "text-green-600" : "text-red-600"}`}
                                                                        >
                                                                            {diff >= 0 ? "+" : ""}
                                                                            {diff.toFixed(2)}
                                                                            {key === "totalReduction" ? "%" : ""}
                                                                        </td>
                                                                    </tr>
                                                                );
                                                            })}
                                                        </tbody>
                                                    </table>
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>
                    </div>

                    {/* 投資收益曲線分析 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowInvestmentAnalysis(!showInvestmentAnalysis)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    投資收益曲線分析
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showInvestmentAnalysis ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showInvestmentAnalysis ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="mb-4 p-4 bg-gray-50 rounded-lg">
                                <h3 className="text-sm font-semibold text-gray-700 mb-3">
                                    分析模式：
                                </h3>
                                <div className="flex gap-4">
                                    <label className="flex items-center space-x-2 cursor-pointer">
                                        <input
                                            type="radio"
                                            name="analysisMode"
                                            value="incremental"
                                            checked={analysisMode === "incremental"}
                                            onChange={(e) => setAnalysisMode(e.target.value)}
                                            className="w-4 h-4 text-pink-600"
                                        />
                                        <span className="text-sm">增量分析 (從當前面板繼續投資)</span>
                                    </label>
                                    <label className="flex items-center space-x-2 cursor-pointer">
                                        <input
                                            type="radio"
                                            name="analysisMode"
                                            value="from_zero"
                                            checked={analysisMode === "from_zero"}
                                            onChange={(e) => setAnalysisMode(e.target.value)}
                                            className="w-4 h-4 text-pink-600"
                                        />
                                        <span className="text-sm">從零分析 (各屬性從0開始堆疊)</span>
                                    </label>
                                </div>
                            </div>
                            <p className="text-sm text-gray-600 mb-4">
                                {analysisMode === "incremental"
                                    ? "顯示從當前防禦數值基礎上投入不同點數的減傷效果"
                                    : "顯示各防禦屬性從0開始投入不同點數的減傷效果（用於新角色配裝規劃）"}
                            </p>
                            <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                                <div className="flex items-center justify-between mb-3">
                                    <h3 className="text-sm font-semibold text-gray-700">
                                        選擇要顯示的曲線：
                                    </h3>
                                    <div className="flex gap-2">
                                        <button
                                            onClick={handleSelectAll}
                                            className="px-3 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600"
                                        >
                                            全選
                                        </button>
                                        <button
                                            onClick={handleDeselectAll}
                                            className="px-3 py-1 text-xs bg-gray-500 text-white rounded hover:bg-gray-600"
                                        >
                                            全不選
                                        </button>
                                    </div>
                                </div>
                                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                                    {recommendationData
                                        .filter((attr) => attr.attribute !== "d_c_defense" && attr.attribute !== "d_c_defense_percent")
                                        .map((attr, index) => (
                                            <label
                                                key={attr.attribute}
                                                className="flex items-center space-x-2 cursor-pointer"
                                            >
                                                <input
                                                    type="checkbox"
                                                    checked={selectedCurves[attr.attribute] || false}
                                                    onChange={() => handleCurveToggle(attr.attribute)}
                                                    className="w-4 h-4 text-pink-600 rounded focus:ring-pink-500"
                                                />
                                                <div className="flex items-center space-x-2">
                                                    <div
                                                        className="w-3 h-3 rounded-full"
                                                        style={{ backgroundColor: colors[index % colors.length] }}
                                                    ></div>
                                                    <span className="text-sm text-gray-700">{attr.label}</span>
                                                </div>
                                            </label>
                                        ))}
                                </div>
                            </div>
                            {analysisData.length > 0 ? (
                                <ResponsiveContainer width="100%" height={400}>
                                    <LineChart data={analysisData}>
                                        <CartesianGrid strokeDasharray="3 3" />
                                        <XAxis
                                            dataKey="points"
                                            label={{
                                                value: "投入點數",
                                                position: "insideBottom",
                                                offset: -5,
                                            }}
                                        />
                                        <YAxis label={{ value: "減傷%", angle: -90, position: "insideLeft" }} />
                                        <Tooltip
                                            formatter={(value, name) => [
                                                `${value.toFixed(3)}%`,
                                                recommendationData.find((d) => d.attribute === name)?.label || name,
                                            ]}
                                            labelFormatter={(points) => `投入點數: ${points}`}
                                        />
                                        <Legend />
                                        {recommendationData
                                            .filter((attr) => attr.attribute !== "d_c_defense")
                                            .map((attr, index) => (
                                                selectedCurves[attr.attribute] && (
                                                    <Line
                                                        key={attr.attribute}
                                                        type="monotone"
                                                        dataKey={attr.attribute}
                                                        stroke={colors[index % colors.length]}
                                                        strokeWidth={2}
                                                        dot={false}
                                                        name={attr.label}
                                                    />
                                                )
                                            ))}
                                    </LineChart>
                                </ResponsiveContainer>
                            ) : (
                                <p className="text-sm text-gray-500">正在生成圖表，請稍候...</p>
                            )}
                        </div>
                    </div>

                    {/* 每200點屬性減傷收益 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowIncrementalAnalysis(!showIncrementalAnalysis)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    每200點屬性減傷收益
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showIncrementalAnalysis ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showIncrementalAnalysis ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="flex flex-wrap gap-4 mb-4">
                                {[
                                    { key: "d_s", label: "氣盾", color: "#3b82f6" },
                                    { key: "d_d", label: "防禦", color: "#10b981" },
                                    { key: "d_f", label: "流派抵禦", color: "#8b5cf6" },
                                    { key: "d_e", label: "元素抗性", color: "#14b8a6" },
                                    { key: "b_b", label: "格擋", color: "#f97316" },
                                    { key: "b_c_defense", label: "抗會心數值", color: "#d084d0" },

                                ].map(({ key, label, color }) => (
                                    <label key={key} className="flex items-center">
                                        <input
                                            type="checkbox"
                                            checked={visibility[key]}
                                            onChange={() => toggleVisibility(key)}
                                            className="mr-2"
                                        />
                                        <span style={{ color }}>{label}</span>
                                    </label>
                                ))}
                            </div>
                            <div className="w-full h-[250px] sm:h-[300px] md:h-[350px]">
                                {deltaData.length > 0 ? (
                                    <ResponsiveContainer width="100%" height="100%">
                                        <LineChart data={deltaData}>
                                            <CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
                                            <XAxis
                                                dataKey="point"
                                                label={{
                                                    value: "屬性點",
                                                    position: "insideBottom",
                                                    offset: -5,
                                                    fontSize: 12,
                                                    fill: "#6b7280",
                                                }}
                                                tick={{ fill: "#6b7280", fontSize: 12 }}
                                            />
                                            <YAxis
                                                label={{
                                                    value: "每200點收益 (%)",
                                                    angle: -90,
                                                    position: "insideLeft",
                                                    fontSize: 12,
                                                    fill: "#6b7280",
                                                }}
                                                tick={{ fill: "#6b7280", fontSize: 12 }}
                                            />
                                            <Tooltip content={<CustomTooltip isDelta={true} />} />
                                            <Legend wrapperStyle={{ fontSize: 12 }} />
                                            {visibility.d_s && (
                                                <Line
                                                    type="monotone"
                                                    dataKey="d_s"
                                                    name="氣盾"
                                                    stroke="#3b82f6"
                                                    strokeWidth={2}
                                                    dot={false}
                                                />
                                            )}
                                            {visibility.d_d && (
                                                <Line
                                                    type="monotone"
                                                    dataKey="d_d"
                                                    name="防禦"
                                                    stroke="#10b981"
                                                    strokeWidth={2}
                                                    dot={false}
                                                />
                                            )}
                                            {visibility.d_f && (
                                                <Line
                                                    type="monotone"
                                                    dataKey="d_f"
                                                    name="流派抵禦"
                                                    stroke="#8b5cf6"
                                                    strokeWidth={2}
                                                    dot={false}
                                                />
                                            )}
                                            {visibility.d_e && (
                                                <Line
                                                    type="monotone"
                                                    dataKey="d_e"
                                                    name="元素抗性"
                                                    stroke="#14b8a6"
                                                    strokeWidth={2}
                                                    dot={false}
                                                />
                                            )}
                                            {visibility.b_b && (
                                                <Line
                                                    type="monotone"
                                                    dataKey="b_b"
                                                    name="格擋"
                                                    stroke="#f97316"
                                                    strokeWidth={2}
                                                    dot={false}
                                                />
                                            )}
                                            {visibility.b_c_defense && (
                                                <Line
                                                    type="monotone"
                                                    dataKey="b_c_defense"
                                                    name="抗會心數值"
                                                    stroke="#d084d0"
                                                    strokeWidth={2}
                                                    dot={false}
                                                />
                                            )}

                                        </LineChart>
                                    </ResponsiveContainer>
                                ) : (
                                    <p className="text-sm text-gray-500">正在生成圖表，請稍候...</p>
                                )}
                            </div>
                        </div>
                    </div>

                    <div className="text-center text-xs text-gray-500 mb-4">
                        <p>防守屬性收益計算器 © {new Date().getFullYear()} | 數據僅供參考</p>
                    </div>
                </div>
            );
        };



        const DamageCalculator2 = () => {
            // 初始化状态 - 在实际环境中可以从localStorage读取
            const [inputs, setInputs] = useState(() => {
                // 在您的环境中，可以取消注释以下代码来支持localStorage

                const saved = localStorage.getItem('damageCalculatorInputs');
                return saved ? JSON.parse(saved) : {
                    skill_multiplier: '1518', D: '5000', E: '800', b_c: '900', d_c: '1.8', R: '500', h: '700',
                    b_d: '2000', b_s: '700', b_e: '0', flow_percent: '0', damage_increase: '0',
                    skill_damage_increase: '0', d_s: '2000', d_f: '2000', d_d: '5000', d_e: '0', b_b: '600', hp: '80000',
                    b_c_defense: '550', d_c_defense: '0', flow_resist_percent: '0', damage_reduction: '0',
                    skill_damage_reduction: '0', lambda_1: '358', lambda_2: '0.359', lambda_3: '2860', lambda_4: '531', W: '1',
                    gold_i: '0',
                };
                return {
                    skill_multiplier: '1518', D: '5000', E: '800', b_c: '900', d_c: '1.8', R: '500', h: '700',
                    b_d: '2000', b_s: '700', b_e: '0', flow_percent: '0', damage_increase: '0',
                    skill_damage_increase: '0', d_s: '2000', d_f: '2000', d_d: '5000', d_e: '0', b_b: '600', hp: '80000',
                    b_c_defense: '550', d_c_defense: '0', flow_resist_percent: '0', damage_reduction: '0',
                    skill_damage_reduction: '0', lambda_1: '358', lambda_2: '0.359', lambda_3: '2860', lambda_4: '531', W: '1',
                    gold_i: '0',
                };
            });

            const [presets, setPresets] = useState(() => {
                try {
                    const savedPresets = localStorage.getItem("damageCalculatorPresets");
                    return savedPresets ? JSON.parse(savedPresets) : [];
                } catch {
                    return [];
                }
                return [];
            });

            const [inputErrors, setInputErrors] = useState({});
            const [previousResult, setPreviousResult] = useState(null);
            const [previousInputs, setPreviousInputs] = useState(null);
            const [visibility, setVisibility] = useState({
                b_d: true, b_e: true, R: true, h: true, D: false, E: false, b_s: true, b_c: true,
            });
            const [showAttacker, setShowAttacker] = useState(true);
            const [showDefender, setShowDefender] = useState(true);
            const [showOriginal, setShowOriginal] = useState(true);
            const [showCorrected, setShowCorrected] = useState(true);
            const [showDamageResult, setShowDamageResult] = useState(true);
            const [showIncrementalAnalysis, setShowIncrementalAnalysis] = useState(true);
            const [isTableExpanded, setIsTableExpanded] = useState(true);
            const [compareIndexes, setCompareIndexes] = useState({ a: null, b: null });
            const [compareResult, setCompareResult] = useState(null);
            const [investmentPoints, setInvestmentPoints] = useState({
                D: 200, E: 200, R: 200, b_d: 200, b_e: 200, b_s: 200, h: 200, b_c: 200,
            });
            const [critDamagePercent, setCritDamagePercent] = useState(10);
            const [recommendationData, setRecommendationData] = useState([]);
            const [analysisMode, setAnalysisMode] = useState('incremental');

            // 当 inputs 变化时，保存到 localStorage（在您的环境中取消注释）
            useEffect(() => {
                try {
                    localStorage.setItem('damageCalculatorInputs', JSON.stringify(inputs));
                } catch (error) {
                    console.error('保存输入数据失败:', error);
                }
            }, [inputs]);

            //当 presets 变化时，保存到 localStorage
            useEffect(() => {
                try {
                    localStorage.setItem("damageCalculatorPresets", JSON.stringify(presets));
                } catch (error) {
                    console.error('保存预设数据失败:', error);
                }
            }, [presets]);

            const goldOptions = [
                { value: '0', label: '無金周天' },
                { value: '0.03', label: '金周天1級' },
                { value: '0.04', label: '金周天2級' },
                { value: '0.05', label: '金周天3級' },
            ];

            const elementWeaknessOptions = [
                { value: '1', label: '無元素弱點' },
                { value: '1.1', label: '碎夢大特' },
            ];

            const colors = [
                '#db2537',      // 攻擊 - 深紅
                '#ff6b6b',      // 元素攻擊 - 淺紅
                '#14b8a6',      // 流派克制 - 青綠
                '#3b82f6',    // 破防 - 藍色
                '#10b981',    // 忽視元素抗性 - 綠色
                '#8b5cf6',    // 破盾 - 紫色
                '#f59e0b',      // 命中 - 橙色
                '#ec4899',    // 會心 - 粉色
            ];

            const toNum = (val) => {
                const num = parseFloat(val);
                return isNaN(num) ? 0 : num;
            };

            const handleChange = (e) => {
                const { name, value } = e.target;
                if (name === 'gold_i' || name === 'W') {
                    setInputs((prev) => ({ ...prev, [name]: value }));
                    setInputErrors((prev) => ({ ...prev, [name]: '' }));
                } else {
                    if (value < 0) {
                        setInputErrors((prev) => ({ ...prev, [name]: '輸入值不能為負數' }));
                        return;
                    }
                    if (value > 1000000) {
                        setInputErrors((prev) => ({ ...prev, [name]: '輸入值過大，最大為1000000' }));
                        return;
                    }
                    setInputs((prev) => ({ ...prev, [name]: value }));
                    setInputErrors((prev) => ({ ...prev, [name]: '' }));
                }
            };

            const saveCurrentResult = () => {
                setPreviousResult(calculate(inputs));
                setPreviousInputs({ ...inputs });
            };

            const toggleVisibility = (key) => {
                setVisibility((prev) => ({ ...prev, [key]: !prev[key] }));
            };

            const calculateRecommendedBreakDefense = (d_d, lambda_3 = 2860) => {
                const d_d_num = toNum(d_d);
                const lambda_3_num = toNum(lambda_3);
                if (d_d_num <= 0) return 0;

                const minBreakDefense = d_d_num - lambda_3_num;
                return Math.ceil(minBreakDefense < 0 ? 0 : minBreakDefense);
            };

            const calculateRecommendedAccuracy = (b_b) => {
                const b_b_num = toNum(b_b);
                if (b_b_num <= 0) return 0;

                // 使用新官方公式計算達到 97% 命中率所需的命中值
                // 0.97 = 0.95 + 1.419 * (d / (3640 + d))
                // 0.02 = 1.419 * (d / (3640 + d))
                // 0.02 * (3640 + d) = 1.419 * d
                // 72.8 + 0.02 * d = 1.419 * d
                // 72.8 = 1.399 * d
                // d = 72.8 / 1.399 ≈ 52.04

                const target_hit_rate = 0.97;
                const base_rate = 0.95;
                const multiplier = 1.419;
                const divisor = 3640;

                const diff_rate = target_hit_rate - base_rate;
                const d_required = (diff_rate * divisor) / (multiplier - diff_rate);

                if (d_required < 0) return '無法達到97%命中';

                const h_required = Math.ceil(d_required + b_b_num);
                return h_required > 0 && h_required < 1000000 ? h_required : 'ERROR';
            };

            const calculate = (inputs) => {
                const {
                    skill_multiplier, D, E, b_c, d_c, R, h, b_d, b_s, b_e, flow_percent, damage_increase,
                    skill_damage_increase, d_s, d_f, d_d, d_e, b_b, hp, b_c_defense, d_c_defense,
                    flow_resist_percent, damage_reduction, skill_damage_reduction, lambda_1, lambda_2,
                    lambda_3, lambda_4, W, gold_i,
                } = inputs;

                const c = toNum(b_c) - toNum(b_c_defense);
                const p_c = Math.min(1, Math.max(0, (115 * c + 90) / (c + 940) / 100 + toNum(gold_i)));
                // ===== 新的官方預測公式（僅用於UI顯示）=====
                const p_h_official = calculateOfficialHitRate(toNum(h), toNum(b_b));

                // ===== 實戰預測公式（用於實際戰鬥計算）=====
                const practical_result = calculatePracticalHitRate(toNum(h), toNum(b_b));
                const p_h = practical_result.hitRate;
                const hit_mode = practical_result.mode;
                const p_h_1 = p_h;
                const m_c = 1 + p_c * Math.max(0, toNum(d_c) - 1 - toNum(d_c_defense));
                const d_mul = m_c * p_h + 0.5 * (1 - p_h);

                const G = toNum(b_s) >= toNum(d_s)
                    ? 0
                    : toNum(d_s) / 3 <= toNum(b_s)
                        ? 0.5 * (toNum(d_s) - toNum(b_s))
                        : toNum(d_s) - 2 * toNum(b_s);

                const A = toNum(D) + (toNum(R) - toNum(d_f)) - G;

                const gamma = toNum(d_d) - toNum(b_d) > 0
                    ? (toNum(d_d) - toNum(b_d)) / (toNum(d_d) - toNum(b_d) + toNum(lambda_3))
                    : 0;
                const gamma_1 = 1 - gamma;

                const e = toNum(d_e) - toNum(b_e);
                const beta = e > 0 ? e / (e + toNum(lambda_4)) : 0;

                const gamma_2 = gamma > 0 ? 1 - gamma : 1;
                const beta_2 = beta > 0 ? 1 - beta : 1;

                const c_original = toNum(b_c);
                const p_c_original = Math.min(1, Math.max(0, (115 * c_original + 90) / (c_original + 940) / 100 + toNum(gold_i)));
                const p_h_original = calculateOfficialHitRate(0, toNum(b_b));
                const p_h_1_original = p_h_original;
                const m_c_original = 1 + p_c_original * (toNum(d_c) - 1);
                const d_mul_original = m_c_original * p_h_original + 0.5 * (1 - p_h_original);
                const G_original = 0
                const A_original = toNum(D) + toNum(R) - G_original;
                const gamma_original = 0;
                const beta_original = 0;
                const gamma_original_2 = 1 - gamma_original;
                const beta_original_2 = 1 - beta_original;

                const baseDamage = (
                    (toNum(skill_multiplier) / 100) * (
                        ((toNum(lambda_1) + toNum(lambda_2) * A_original) * (1 - gamma_original)) +
                        toNum(W) * toNum(lambda_2) * toNum(E) * (1 - beta_original)
                    )
                ) * d_mul_original * (1 + toNum(flow_percent)) * (1 + toNum(damage_increase)) * (1 + toNum(skill_damage_increase));

                const finalDamage = (
                    (toNum(skill_multiplier) / 100) * (
                        ((toNum(lambda_1) + toNum(lambda_2) * A) * (1 - gamma)) +
                        toNum(W) * toNum(lambda_2) * toNum(E) * (1 - beta)
                    )
                ) * d_mul * (1 + toNum(flow_percent) - toNum(flow_resist_percent)) * (1 + toNum(damage_increase) - toNum(damage_reduction)) * (1 + toNum(skill_damage_increase) / 100 - toNum(skill_damage_reduction) / 100);

                const totalReduction = finalDamage / baseDamage || 0;
                const ehp = toNum(hp) / (1 - totalReduction) || toNum(hp);

                const base_elementalDamage = (
                    (toNum(skill_multiplier) / 100) * (toNum(W) * toNum(lambda_2) * toNum(E) * (1 - beta_original))
                ) * d_mul_original * (1 + toNum(flow_percent) - toNum(flow_resist_percent)) * (1 + toNum(damage_increase) - toNum(damage_reduction)) * (1 + toNum(skill_damage_increase) / 100 - toNum(skill_damage_reduction) / 100);

                const elementalDamage = (
                    (toNum(skill_multiplier) / 100) * (toNum(W) * toNum(lambda_2) * toNum(E) * (1 - beta))
                ) * d_mul * (1 + toNum(flow_percent) - toNum(flow_resist_percent)) * (1 + toNum(damage_increase) - toNum(damage_reduction)) * (1 + toNum(skill_damage_increase) / 100 - toNum(skill_damage_reduction) / 100);

                const base_elementalDamagePrecentage = base_elementalDamage / baseDamage || 0;
                const elementalDamagePrecentage = elementalDamage / finalDamage || 0;

                const calculateRequiredH = (b_b) => {
                    const b_b_num = toNum(b_b);
                    if (b_b_num === 0) return 0;
                    const r_b_val = 143 * b_b_num / (b_b_num + 713) / 100;
                    const r_h_target = 0.05 + r_b_val;
                    if (r_h_target >= 1.43) return '無法滿命中';
                    const numerator = r_h_target * 100 * 713;
                    const denominator = 143 - r_h_target * 100;
                    if (denominator <= 0) return '無法滿命中';
                    const h_required = Math.ceil(numerator / denominator);
                    return h_required > 0 && h_required < 10000 ? h_required : 'ERROR';
                };

                const full_ph = calculateRequiredH(inputs.b_b);

                // ===== 新增：計算理論最大傷害（無防守屬性）=====

                // 攻擊方在無防守干擾下的理論最大傷害
                const c_theoretical = toNum(b_c);  // 攻擊方會心（無抗會心）
                const p_c_theoretical = Math.max(0, (115 * c_theoretical + 90) / (c_theoretical + 940) / 100 + toNum(gold_i));
                const p_h_theoretical = calculateOfficialHitRate(toNum(h), 0);
                const m_c_theoretical = 1 + p_c_theoretical * (toNum(d_c) - 1);  // 無會心防禦
                const d_mul_theoretical = m_c_theoretical * p_h_theoretical + 0.5 * (1 - p_h_theoretical);

                // 理論最大攻擊力（無氣盾、無防禦、無元素抗性）
                const A_theoretical = toNum(D) + toNum(R);  // 無氣盾減免

                // 理論最大傷害
                const theoreticalMaxDamage = (toNum(skill_multiplier) / 100) *
                    (toNum(lambda_1) + toNum(lambda_2) * A_theoretical + toNum(W) * toNum(lambda_2) * toNum(E)) *
                    d_mul_theoretical *
                    (1 + toNum(flow_percent)) *
                    (1 + toNum(damage_increase)) *
                    (1 + toNum(skill_damage_increase) / 100);

                // ===== 計算生效率 =====
                const effectivenessRate = theoreticalMaxDamage > 0
                    ? finalDamage / theoreticalMaxDamage
                    : 0;

                // ===== 計算增傷倍率（原有邏輯）=====
                const damageMultiplier = finalDamage / baseDamage || 0;


                return {
                    c: c.toFixed(2),
                    p_c: (p_c * 100).toFixed(2) + '%',
                    p_h_official: (p_h_official * 100).toFixed(2) + '%',
                    p_h_practical: (p_h * 100).toFixed(2) + '%',
                    hit_mode: hit_mode,
                    block_rate_official: ((1 - p_h_official) * 100).toFixed(2) + '%',
                    block_rate_practical: ((1 - p_h) * 100).toFixed(2) + '%',
                    p_h_1: (p_h_1 * 100).toFixed(2) + '%',
                    m_c: m_c.toFixed(4),
                    d_mul: d_mul.toFixed(4),
                    G: G.toFixed(2),
                    A: A.toFixed(2),
                    gamma: (gamma * 100).toFixed(2) + '%',
                    gamma_1: (gamma_1 * 100).toFixed(2) + '%',
                    beta: (beta * 100).toFixed(2) + '%',
                    gamma_2: (gamma_2 * 100).toFixed(2) + '%',
                    beta_2: (beta_2 * 100).toFixed(2) + '%',
                    c_original: c_original.toFixed(2),
                    p_c_original: (p_c_original * 100).toFixed(2) + '%',
                    p_h_original: (p_h_original * 100).toFixed(2) + '%',
                    p_h_1_original: (p_h_1_original * 100).toFixed(2) + '%',
                    m_c_original: m_c_original.toFixed(4),
                    d_mul_original: d_mul_original.toFixed(4),
                    G_original: G_original.toFixed(2),
                    A_original: A_original.toFixed(2),
                    gamma_original: (gamma_original * 100).toFixed(2) + '%',
                    beta_original: (beta_original * 100).toFixed(2) + '%',
                    gamma_original_2: (gamma_original_2 * 100).toFixed(2) + '%',
                    beta_original_2: (beta_original_2 * 100).toFixed(2) + '%',
                    baseDamage: baseDamage.toFixed(2),
                    finalDamage: finalDamage.toFixed(2),
                    totalReduction: (totalReduction * 100).toFixed(2) + '%',
                    ehp: ehp.toFixed(2),
                    base_elementalDamage: base_elementalDamage.toFixed(2),
                    elementalDamage: elementalDamage.toFixed(2),
                    base_elementalDamagePrecentage: (base_elementalDamagePrecentage * 100).toFixed(2) + '%',
                    elementalDamagePrecentage: (elementalDamagePrecentage * 100).toFixed(2) + '%',
                    full_ph: typeof full_ph === 'number' ? full_ph.toFixed(0) : full_ph,
                    theoreticalMaxDamage: theoreticalMaxDamage.toFixed(2),
                    effectivenessRate: (effectivenessRate * 100).toFixed(2) + '%',
                    damageMultiplier: damageMultiplier.toFixed(2) + '倍',
                };
            };

            const calculateInvestmentIncrease = (attr, points) => {
                const params = { ...inputs };
                if (analysisMode === 'from_zero') {
                    if (attr === 'd_c_percent') {
                        params.d_c = (1 + points / 100).toString();
                    } else {
                        params[attr] = points;
                    }
                } else {
                    if (attr === 'd_c_percent') {
                        const currentDc = toNum(inputs.d_c);
                        params.d_c = (currentDc + points / 100).toString();
                    } else {
                        params[attr] = toNum(inputs[attr]) + points;
                    }
                }
                const newDamage = calculate(params).finalDamage;
                const baseDamage = calculate(inputs).finalDamage;
                return baseDamage ? ((toNum(newDamage) - toNum(baseDamage)) / toNum(baseDamage)) * 100 : 0;
            };

            const analyzeAttackOptions = () => {
                const attributes = [
                    { key: 'D', label: '攻擊' },
                    { key: 'E', label: '元素攻擊' },
                    { key: 'R', label: '流派克制' },
                    { key: 'b_d', label: '破防' },
                    { key: 'b_e', label: '忽視元素抗性' },
                    { key: 'b_s', label: '破盾' },
                    { key: 'b_c', label: '會心' },
                    { key: 'd_c_percent', label: '會心傷害%' },
                ];
                const newRecommendationData = attributes.map(({ key, label }) => ({
                    attribute: key,
                    label,
                    damageIncrease: key === 'd_c_percent'
                        ? calculateInvestmentIncrease(key, critDamagePercent)
                        : calculateInvestmentIncrease(key, investmentPoints[key] || 200),
                })).sort((a, b) => b.damageIncrease - a.damageIncrease);
                setRecommendationData(newRecommendationData);
            };

            const handleInvestmentChange = (attr, value) => {
                setInvestmentPoints((prev) => ({
                    ...prev,
                    [attr]: Math.min(1000, Math.max(1, parseInt(value) || 1)),
                }));
                analyzeAttackOptions();
            };

            const handleCritDamagePercentChange = (value) => {
                const newValue = Math.min(200, Math.max(1, parseInt(value) || 1));
                setCritDamagePercent(newValue);
                analyzeAttackOptions();
            };

            const handleSelectAll = () => {
                setVisibility({
                    b_d: true, b_e: true, R: true, D: true, E: true, b_s: true, b_c: true,
                });
            };

            const handleDeselectAll = () => {
                setVisibility({
                    b_d: false, b_e: false, R: false, h: false, D: false, E: false, b_s: false, b_c: false,
                });
            };

            const handleCurveToggle = (attr) => {
                setVisibility((prev) => ({ ...prev, [attr]: !prev[attr] }));
            };

            const saveCurrentPreset = () => {
                if (presets.length >= 4) {
                    alert('最多只能保存 4 組方案！');
                    return;
                }
                const name = prompt('請輸入方案名稱：');
                if (!name) return;
                const newPresets = [...presets, { name, data: inputs }];
                setPresets(newPresets);
                // localStorage会通过useEffect自动保存
            };

            const loadPreset = (i) => {
                setInputs(presets[i].data);
                analyzeAttackOptions();
            };

            const deletePreset = (i) => {
                const updated = presets.filter((_, idx) => idx !== i);
                setPresets(updated);
                // localStorage会通过useEffect自动保存
            };

            const comparePresets = () => {
                const a = presets[compareIndexes.a]?.data;
                const b = presets[compareIndexes.b]?.data;
                if (!a || !b) return;
                const diff = {};
                Object.keys(a).forEach((key) => {
                    diff[key] = toNum(b[key]) - toNum(a[key]);
                });
                const resultA = calculate(a);
                const resultB = calculate(b);
                setCompareResult({
                    diff,
                    resultDiff: {
                        baseDamage: toNum(resultB.baseDamage) - toNum(resultA.baseDamage),
                        finalDamage: toNum(resultB.finalDamage) - toNum(resultA.finalDamage),
                        totalReduction: toNum(resultB.totalReduction) - toNum(resultA.totalReduction),
                    },
                });
            };

            useEffect(() => {
                analyzeAttackOptions();
            }, [inputs, analysisMode, investmentPoints, critDamagePercent]);

            const generateChartData = (inputs) => {
                const min_b_c = toNum(inputs.b_c_defense);
                const attribute_points = Array.from({ length: 201 }, (_, i) => i * 50);
                const increases = { b_d: [], b_e: [], D: [], E: [], R: [], b_s: [], h: [], b_c: [] };
                const delta_increases = { b_d: [], b_e: [], D: [], E: [], R: [], b_s: [], h: [], b_c: [] };

                const calculateDamage = (D, E, R, b_d, b_e, b_s, h, b_c, d_c) => {
                    const params = { ...inputs, D, E, R, b_d, b_e, b_s, h, b_c, d_c };
                    return toNum(calculate(params).finalDamage);
                };

                const calculateRequiredH = (b_b) => {
                    const b_b_num = toNum(b_b);
                    if (b_b_num === 0) return 0;
                    const r_b_val = 143 * b_b_num / (b_b_num + 713) / 100;
                    const r_h_target = 0.05 + r_b_val;
                    if (r_h_target >= 1.43) return 10000;
                    const numerator = r_h_target * 100 * 713;
                    const denominator = 143 - r_h_target * 100;
                    if (denominator <= 0) return 10000;
                    return Math.ceil(numerator / denominator);
                };

                const fullHitRequired = calculateRequiredH(toNum(inputs.b_b));
                const baselineH = Math.min(fullHitRequired, 10000);
                // 修正基礎傷害計算，根據分析模式選擇不同的基準
                const baseDamage = analysisMode === 'from_zero'
                    ? calculateDamage(
                        toNum(inputs.D), toNum(inputs.E), 0, 0, 0, 0, baselineH, 0, 1.5
                    )
                    : toNum(calculate(inputs).finalDamage);

                const calculateIncrease = (attr, value) => {
                    const params = {
                        D: analysisMode === 'from_zero' ? toNum(inputs.D) : toNum(inputs.D),
                        E: analysisMode === 'from_zero' ? toNum(inputs.E) : toNum(inputs.E),
                        R: analysisMode === 'from_zero' ? 0 : toNum(inputs.R),
                        b_d: analysisMode === 'from_zero' ? 0 : toNum(inputs.b_d),
                        b_e: analysisMode === 'from_zero' ? 0 : toNum(inputs.b_e),
                        b_s: analysisMode === 'from_zero' ? 0 : toNum(inputs.b_s),
                        h: analysisMode === 'from_zero' ? baselineH : toNum(inputs.h),
                        b_c: analysisMode === 'from_zero' ? 0 : toNum(inputs.b_c),
                        d_c: analysisMode === 'from_zero' ? 1.5 : toNum(inputs.d_c),
                    };

                    if (analysisMode === 'from_zero') {
                        // 從零開始模式：直接設置為輸入值
                        if (attr === 'b_c') {
                            params[attr] = value;
                        } else if (['R', 'b_d', 'b_e', 'b_s'].includes(attr)) {
                            params[attr] = value;
                        } else if (attr === 'h') {
                            params[attr] = baselineH + value;
                        } else {
                            params[attr] = toNum(inputs[attr]) + value;
                        }
                    } else {
                        // 增量模式：在現有基礎上增加
                        params[attr] = toNum(inputs[attr]) + value;
                    }

                    const newDamage = calculateDamage(
                        params.D, params.E, params.R, params.b_d, params.b_e, params.b_s, params.h, params.b_c, params.d_c
                    );
                    const increase = baseDamage ? (newDamage - baseDamage) / baseDamage : 0;
                    return Math.max(0, increase);
                };

                attribute_points.forEach((point) => {
                    increases.D.push(calculateIncrease('D', point));
                    increases.E.push(calculateIncrease('E', point));
                    increases.R.push(calculateIncrease('R', point));
                    increases.b_d.push(calculateIncrease('b_d', point));
                    increases.b_e.push(calculateIncrease('b_e', point));
                    increases.b_s.push(calculateIncrease('b_s', point));
                    increases.h.push(calculateIncrease('h', point));
                    increases.b_c.push(calculateIncrease('b_c', point));
                });

                for (let i = 1; i < increases.b_s.length; i++) {
                    delta_increases.D.push(Math.max(0, increases.D[i] - increases.D[i - 1]));
                    delta_increases.E.push(Math.max(0, increases.E[i] - increases.E[i - 1]));
                    delta_increases.R.push(Math.max(0, increases.R[i] - increases.R[i - 1]));
                    delta_increases.b_d.push(Math.max(0, increases.b_d[i] - increases.b_d[i - 1]));
                    delta_increases.b_e.push(Math.max(0, increases.b_e[i] - increases.b_e[i - 1]));
                    delta_increases.b_s.push(Math.max(0, increases.b_s[i] - increases.b_s[i - 1]));
                    delta_increases.h.push(Math.max(0, increases.h[i] - increases.h[i - 1]));
                    delta_increases.b_c.push(Math.max(0, increases.b_c[i] - increases.b_c[i - 1]));
                }

                const deltaData = attribute_points.slice(1).map((point, i) => ({
                    point,
                    D: delta_increases.D[i],
                    E: delta_increases.E[i],
                    R: delta_increases.R[i],
                    b_d: delta_increases.b_d[i],
                    b_e: delta_increases.b_e[i],
                    b_s: delta_increases.b_s[i],
                    h: delta_increases.h[i],
                    b_c: delta_increases.b_c[i],
                }));

                const increaseData = attribute_points.map((point, i) => ({
                    point,
                    D: increases.D[i],
                    E: increases.E[i],
                    R: increases.R[i],
                    b_d: increases.b_d[i],
                    b_e: increases.b_e[i],
                    b_s: increases.b_s[i],
                    h: increases.h[i],
                    b_c: increases.b_c[i],
                }));

                return {
                    deltaData,
                    increaseData,
                    baselineInfo: {
                        fullHitRequired,
                        baselineH,
                        baseDamage: baseDamage.toFixed(2),
                    },
                };
            };

            const CustomTooltip = ({ active, payload, label, isDelta }) => {
                if (active && payload && payload.length) {
                    return (
                        <div className="bg-white p-3 border border-gray-200 rounded-lg shadow-sm">
                            <p className="text-sm text-gray-700 font-medium">屬性點: {label}</p>
                            {payload.map((entry, index) => (
                                <p key={index} className="text-sm text-gray-600">
                                    <span style={{ color: entry.stroke }}>{entry.name}</span>: {(entry.value * 100).toFixed(isDelta ? 4 : 2)}%
                                </p>
                            ))}
                        </div>
                    );
                }
                return null;
            };

            const result = calculate(inputs);
            const { deltaData, increaseData } = generateChartData(inputs);

            return (
                <div className="p-4 container mx-auto min-h-screen bg-gray-50">
                    {/* 標題 */}
                    <div className="bg-gradient-to-r from-pink-500 to-red-500 rounded-xl p-6 mb-6 shadow-lg">
                        <h1 className="text-xl md:text-2xl font-bold text-center text-white">
                            攻擊計算器
                        </h1>
                        <p className="text-center text-white text-opacity-90 text-sm mt-1">
                            如有問題請聯繫櫻桃白蘭地@緣定今生
                        </p>
                    </div>

                    {/* 攻擊方參數 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-4">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowAttacker(!showAttacker)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    攻擊方參數
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showAttacker ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showAttacker ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <ImageUploader setInputs={setInputs} type="attacker" />
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                {[
                                    {
                                        key: "skill_multiplier",
                                        label: "技能倍率",
                                        icon: "🔥",
                                        tooltip: "如技能倍率為300%，輸入300",
                                    },
                                    { key: "D", label: "攻擊", icon: "⚔️" },
                                    { key: "E", label: "元素攻擊（平均）", icon: "✨" },
                                    { key: "b_c", label: "會心數值", icon: "🎯" },
                                    {
                                        key: "d_c",
                                        label: "會心傷害",
                                        icon: "💥",
                                        tooltip: "除以100，例如180%，輸入1.8",
                                    },
                                    { key: "R", label: "流派克制", icon: "🔄" },
                                    { key: "h", label: "命中", icon: "🎯" },
                                    { key: "b_d", label: "破防", icon: "🛡️" },
                                    { key: "b_s", label: "破盾", icon: "🔨" },
                                    { key: "b_e", label: "忽視元素抗性", icon: "🌀" },
                                    {
                                        key: "flow_percent",
                                        label: "流派克制%",
                                        icon: "📊",
                                        tooltip:
                                            "例如9.5%，輸入0.095。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "damage_increase",
                                        label: "增傷%",
                                        icon: "📈",
                                        tooltip:
                                            "除以100，例如5%，輸入0.05。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "skill_damage_increase",
                                        label: "技能增傷%",
                                        icon: "📈",
                                        tooltip:
                                            "除以100，例如5%，輸入0.05。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "gold_i",
                                        label: "金周天",
                                        icon: "🌟",
                                        type: "select",
                                        options: goldOptions,
                                    },
                                    {
                                        key: "W",
                                        label: "元素弱點",
                                        icon: "🖕🏻",
                                        type: "select",
                                        options: elementWeaknessOptions,
                                    },
                                ].map(({ key, label, icon, type, options, tooltip }) => (
                                    <div key={key} className="flex flex-col group relative">
                                        <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                            <span className="mr-1 md:mr-2">{icon}</span>
                                            {label}
                                            {tooltip && (
                                                <>
                                                    <span className="ml-1 flex items-center justify-center w-4 h-4 rounded-full bg-gray-400 text-white text-xs cursor-help">
                                                        ?
                                                    </span>
                                                    <div className="absolute left-0 top-8 bg-gray-800 text-white text-xs p-2 rounded-lg shadow-md z-10 max-w-xs opacity-0 group-hover:opacity-100 transition-opacity">
                                                        {tooltip}
                                                    </div>
                                                </>
                                            )}
                                        </label>
                                        {type === "select" ? (
                                            <select
                                                name={key}
                                                value={inputs[key]}
                                                onChange={handleChange}
                                                className="border border-gray-200 rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors"
                                                aria-label={label}
                                            >
                                                {options.map((opt) => (
                                                    <option key={opt.value} value={opt.value}>
                                                        {opt.label}
                                                    </option>
                                                ))}
                                            </select>
                                        ) : (
                                            <input
                                                type="number"
                                                name={key}
                                                value={inputs[key]}
                                                onChange={handleChange}
                                                min="0"
                                                max="1000000"
                                                className={`border ${inputErrors[key] ? "border-red-500" : "border-gray-200"} rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors`}
                                                aria-label={label}
                                            />
                                        )}
                                        {inputErrors[key] && (
                                            <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                                        )}
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* 防守方參數 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-4">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowDefender(!showDefender)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    防守方參數
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showDefender ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showDefender ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <ImageUploader setInputs={setInputs} type="defender" />
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                {[
                                    { key: "d_s", label: "氣盾", icon: "🛡️" },
                                    { key: "d_f", label: "流派抵禦", icon: "🔄" },
                                    { key: "d_d", label: "防禦", icon: "🏰" },
                                    { key: "d_e", label: "元素抗性", icon: "🌀" },
                                    { key: "b_b", label: "格擋", icon: "✋" },
                                    { key: "hp", label: "氣血", icon: "❤️" },
                                    { key: "b_c_defense", label: "抗會心數值", icon: "🎯" },
                                    {
                                        key: "d_c_defense",
                                        label: "會心防禦%",
                                        icon: "📊",
                                        tooltip:
                                            "除以100，例如25%，輸入0.25。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "flow_resist_percent",
                                        label: "流派抵禦%",
                                        icon: "📊",
                                        tooltip:
                                            "除以100，例如5%，輸入0.05。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "damage_reduction",
                                        label: "傷害減免%",
                                        icon: "📉",
                                        tooltip:
                                            "除以100，例如15%，輸入0.15。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                    {
                                        key: "skill_damage_reduction",
                                        label: "技能減免%",
                                        icon: "📉",
                                        tooltip:
                                            "除以100，例如5%，輸入0.05。所有%皆為相加，例如10%+5%=15%=輸入0.15",
                                    },
                                ].map(({ key, label, icon, tooltip }) => (
                                    <div key={key} className="flex flex-col group relative">
                                        <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                                            <span className="mr-1 md:mr-2">{icon}</span>
                                            {label}
                                            {tooltip && (
                                                <>
                                                    <span className="ml-1 flex items-center justify-center w-4 h-4 rounded-full bg-gray-400 text-white text-xs cursor-help">
                                                        ?
                                                    </span>
                                                    <div className="absolute left-0 top-8 bg-gray-800 text-white text-xs p-2 rounded-lg shadow-md z-10 max-w-xs opacity-0 group-hover:opacity-100 transition-opacity">
                                                        {tooltip}
                                                    </div>
                                                </>
                                            )}
                                        </label>
                                        <input
                                            type="number"
                                            name={key}
                                            value={inputs[key]}
                                            onChange={handleChange}
                                            min="0"
                                            max="1000000"
                                            className={`border ${inputErrors[key] ? "border-red-500" : "border-gray-200"} rounded-lg p-2 text-sm w-full focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors`}
                                            aria-label={label}
                                        />
                                        {inputErrors[key] && (
                                            <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                                        )}
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* 原數值屬性 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowOriginal(!showOriginal)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    原數值屬性
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showOriginal ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showOriginal ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="grid grid-cols-2 gap-3 mb-4">
                                <div className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-gray-600">真實會心</p>
                                    <p className="text-sm font-bold text-gray-800">{result.c_original}</p>
                                </div>
                                <div className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-gray-600">會心率</p>
                                    <p className="text-sm font-bold text-gray-800">{result.p_c_original}</p>
                                </div>

                                {/* 官方預測命中率 - 原数值 */}
                                <div className="bg-blue-50 p-2 md:p-3 rounded-lg border border-blue-200">
                                    <p className="text-xs text-blue-600">官方預測命中率</p>
                                    <p className="text-sm font-bold text-blue-800">{result.p_h_original}</p>
                                </div>

                                <div className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-gray-600">會心傷害倍率</p>
                                    <p className="text-sm font-bold text-gray-800">{result.m_c_original}</p>
                                </div>
                                <div className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-gray-600">傷害倍率</p>
                                    <p className="text-sm font-bold text-gray-800">{result.d_mul_original}</p>
                                </div>
                                <div className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-gray-600">剩餘氣盾</p>
                                    <p className="text-sm font-bold text-gray-800">{result.G_original}</p>
                                </div>
                                <div className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-gray-600">防禦穿透率</p>
                                    <p className="text-sm font-bold text-gray-800">{result.gamma_original_2}</p>
                                </div>
                                <div className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-gray-600">元素穿透率</p>
                                    <p className="text-sm font-bold text-gray-800">{result.beta_original_2}</p>
                                </div>
                                <div className="bg-gray-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-gray-600">元素傷害佔比</p>
                                    <p className="text-sm font-bold text-gray-800">{result.base_elementalDamagePrecentage}</p>
                                </div>
                            </div>
                        </div>

                        {/* 修正後屬性 */}
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowCorrected(!showCorrected)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    修正後屬性
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showCorrected ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showCorrected ? "max-h-[1500px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="grid grid-cols-2 gap-3">
                                <div className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-pink-600">修正會心</p>
                                    <p className="text-sm font-bold text-pink-800">{result.c}</p>
                                </div>
                                <div className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-pink-600">會心率</p>
                                    <p className="text-sm font-bold text-pink-800">{result.p_c}</p>
                                </div>

                                {/* 官方預測命中率/格擋率 */}
                                <div className="bg-blue-50 p-2 md:p-3 rounded-lg border border-blue-200">
                                    <p className="text-xs text-blue-600">官方預測命中率</p>
                                    <p className="text-sm font-bold text-blue-800">{result.p_h_official}</p>
                                </div>
                                <div className="bg-blue-50 p-2 md:p-3 rounded-lg border border-blue-200">
                                    <p className="text-xs text-blue-600">官方預測格擋率</p>
                                    <p className="text-sm font-bold text-blue-800">{result.block_rate_official}</p>
                                </div>

                                {/* 實戰預測命中率/格擋率 */}
                                <div className="bg-green-50 p-2 md:p-3 rounded-lg border border-green-200 group relative">
                                    <p className="text-xs text-green-600 flex items-center">
                                        實戰預測命中率
                                        <span className="ml-1 flex items-center justify-center w-3 h-3 rounded-full bg-gray-400 text-white text-xs cursor-help">
                                            ?
                                        </span>
                                        <div className="absolute left-0 bottom-full mb-2 bg-gray-800 text-white text-xs p-2 rounded-lg shadow-md z-10 max-w-xs opacity-0 group-hover:opacity-100 transition-opacity whitespace-normal">
                                            必中傷害如火周天、神特、眾妙的灼燒傷害會影響命中率顯示，實際技能命中率不變
                                        </div>
                                    </p>
                                    <div className="flex items-center gap-2">
                                        <p className="text-sm font-bold text-green-800">{result.p_h_practical}</p>
                                        {result.hit_mode === "FLOOR_ACTIVE" && (
                                            <span className="text-xs bg-orange-500 text-white px-2 py-0.5 rounded-full">
                                                保底
                                            </span>
                                        )}
                                    </div>
                                </div>
                                <div className="bg-green-50 p-2 md:p-3 rounded-lg border border-green-200">
                                    <p className="text-xs text-green-600">實戰預測格擋率</p>
                                    <p className="text-sm font-bold text-green-800">{result.block_rate_practical}</p>
                                </div>

                                <div className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-pink-600">會心傷害倍率</p>
                                    <p className="text-sm font-bold text-pink-800">{result.m_c}</p>
                                </div>
                                <div className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-pink-600">傷害倍率</p>
                                    <p className="text-sm font-bold text-pink-800">{result.d_mul}</p>
                                </div>
                                <div className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-pink-600">剩餘氣盾</p>
                                    <p className="text-sm font-bold text-pink-800">{result.G}</p>
                                </div>
                                <div className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-pink-600">防禦穿透率</p>
                                    <p className="text-sm font-bold text-pink-800">{result.gamma_2}</p>
                                </div>
                                <div className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-pink-600">元素穿透率</p>
                                    <p className="text-sm font-bold text-pink-800">{result.beta_2}</p>
                                </div>
                                <div className="bg-pink-50 p-2 md:p-3 rounded-lg">
                                    <p className="text-xs text-pink-600">元素傷害佔比</p>
                                    <p className="text-sm font-bold text-pink-800">{result.elementalDamagePrecentage}</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* 傷害計算結果 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div
                            className="flex justify-between items-center cursor-pointer mb-2"
                            onClick={() => setShowDamageResult(!showDamageResult)}
                        >
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">
                                    傷害計算結果
                                </h2>
                            </div>
                            <span className="text-pink-700 text-lg">
                                {showDamageResult ? "▲" : "▼"}
                            </span>
                        </div>
                        <div
                            className={`transition-all duration-500 overflow-hidden ${showDamageResult ? "max-h-[3000px] opacity-100" : "max-h-0 opacity-0"}`}
                        >
                            <div className="flex justify-end items-center mb-4">
                                <button
                                    className="bg-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-pink-700 transition-colors"
                                    onClick={saveCurrentPreset}
                                >
                                    保存當前方案
                                </button>
                            </div>
                            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-3 mt-6">
                                {[
                                    { label: "理論最大傷害", value: result.theoreticalMaxDamage, color: "pink-100" },
                                    { label: "實際傷害", value: result.finalDamage, color: "pink-100" },
                                    {
                                        label: "傷害生效率",
                                        value: result.effectivenessRate,
                                        color: "pink-500",
                                        text: "white",
                                        tooltip: "實際傷害相對於理論最大傷害的比率"
                                    },
                                    {
                                        label: "攻擊增傷倍率",
                                        value: result.damageMultiplier,
                                        color: "blue-500",
                                        text: "white",
                                        tooltip: "當前攻擊配置相對於最低攻擊配置的倍率"
                                    },
                                ].map(({ label, value, color, text, tooltip }) => (
                                    <div key={label} className={`bg-${color} p-3 rounded-lg group relative`}>
                                        <p className={`text-xs ${text ? `text-${text}` : "text-pink-700"} flex items-center`}>
                                            {label}
                                            {tooltip && (
                                                <>
                                                    <span className="ml-1 flex items-center justify-center w-3 h-3 rounded-full bg-gray-400 text-white text-xs cursor-help">?</span>
                                                    <div className="absolute left-0 bottom-full mb-2 bg-gray-800 text-white text-xs p-2 rounded-lg shadow-md z-10 max-w-xs opacity-0 group-hover:opacity-100 transition-opacity whitespace-normal">
                                                        {tooltip}
                                                    </div>
                                                </>
                                            )}
                                        </p>
                                        <p className={`text-lg font-bold ${text ? `text-${text}` : "text-pink-800"}`}>
                                            {value}
                                        </p>
                                    </div>
                                ))}
                            </div>

                            <div className="mt-6">
                                <div className="flex justify-between items-center mb-2">
                                    <div className="flex items-center">
                                        <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                        <h4 className="font-bold text-base text-gray-800">
                                            攻擊投資優先級（！下方先選增量模式！）
                                        </h4>
                                    </div>
                                </div>
                                <div>
                                    <p className="text-sm text-gray-600 mb-4">
                                        針對當前面板配置，通過拖動拉桿或輸入數值調整投資點數，實時查看從現有面板基礎上的增傷效果
                                    </p>
                                    {recommendationData.length > 0 ? (
                                        <div className="space-y-4">
                                            {[
                                                { key: "D", label: "攻擊" },
                                                { key: "E", label: "元素攻擊" },
                                                { key: "R", label: "流派克制" },
                                                { key: "b_d", label: "破防" },
                                                { key: "b_e", label: "忽視元素抗性" },
                                                { key: "b_s", label: "破盾" },
                                                { key: "h", label: "命中" },
                                                { key: "b_c", label: "會心" },
                                            ].map(({ key, label }) => {
                                                const increase = calculateInvestmentIncrease(key, investmentPoints[key]);
                                                const maxIncrease = Math.max(
                                                    ...Object.keys(investmentPoints).map((attr) =>
                                                        calculateInvestmentIncrease(attr, investmentPoints[attr])
                                                    ),
                                                    calculateInvestmentIncrease('d_c_percent', critDamagePercent),
                                                    0.0001
                                                );
                                                const barWidth = `${(increase / maxIncrease) * 100}%`;
                                                return (
                                                    <div key={key} className="flex items-center gap-4">
                                                        <span className="w-24 text-sm font-semibold text-gray-700">{label}</span>
                                                        <input
                                                            type="range"
                                                            min="1"
                                                            max="1000"
                                                            value={investmentPoints[key]}
                                                            onChange={(e) => handleInvestmentChange(key, e.target.value)}
                                                            className="w-1/3 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                        />
                                                        <input
                                                            type="number"
                                                            min="1"
                                                            max="1000"
                                                            value={investmentPoints[key]}
                                                            onChange={(e) => {
                                                                const value = Math.min(1000, Math.max(1, parseInt(e.target.value) || 1));
                                                                handleInvestmentChange(key, value);
                                                            }}
                                                            className="w-20 p-2 border border-gray-200 rounded-lg text-sm focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors"
                                                        />
                                                        <div className="w-1/3 bg-gray-200 rounded-full h-2.5">
                                                            <div
                                                                className="bg-pink-500 h-2.5 rounded-full"
                                                                style={{ width: barWidth }}
                                                            ></div>
                                                        </div>
                                                        <span className="text-sm text-gray-700">{increase.toFixed(2)}% 增傷</span>
                                                    </div>
                                                );
                                            })}
                                            <div className="flex items-center gap-4">
                                                <span className="w-24 text-sm font-semibold text-gray-700">會心傷害%</span>
                                                <input
                                                    type="range"
                                                    min="1"
                                                    max="200"
                                                    value={critDamagePercent}
                                                    onChange={(e) => handleCritDamagePercentChange(e.target.value)}
                                                    className="w-1/3 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                />
                                                <div className="relative w-20">
                                                    <input
                                                        type="number"
                                                        min="1"
                                                        max="200"
                                                        value={critDamagePercent}
                                                        onChange={(e) => {
                                                            const value = Math.min(200, Math.max(1, parseInt(e.target.value) || 1));
                                                            handleCritDamagePercentChange(value);
                                                        }}
                                                        className="w-full p-2 pr-6 border border-gray-200 rounded-lg text-sm focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors"
                                                    />
                                                    <span className="absolute right-2 top-1/2 transform -translate-y-1/2 text-sm text-gray-500">%</span>
                                                </div>
                                                <div className="w-1/3 bg-gray-200 rounded-full h-2.5">
                                                    <div
                                                        className="bg-pink-500 h-2.5 rounded-full"
                                                        style={{
                                                            width: `${(calculateInvestmentIncrease('d_c_percent', critDamagePercent) / Math.max(
                                                                ...Object.keys(investmentPoints).map((attr) =>
                                                                    calculateInvestmentIncrease(attr, investmentPoints[attr])
                                                                ),
                                                                calculateInvestmentIncrease('d_c_percent', critDamagePercent),
                                                                0.0001
                                                            )) * 100}%`
                                                        }}
                                                    ></div>
                                                </div>
                                                <span className="text-sm text-gray-700">{calculateInvestmentIncrease('d_c_percent', critDamagePercent).toFixed(2)}% 增傷</span>
                                            </div>
                                        </div>
                                    ) : (
                                        <p className="text-sm text-red-600">無法生成投資優先級數據，請檢查輸入值。</p>
                                    )}
                                </div>
                            </div>

                            {/* 針對性配裝建議 */}
                            <div className="mt-6 bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4 text-gray-700 flex items-center">
                                    <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                    針對性配裝建議
                                </h2>
                                <h4 className="font-bold text-pink-700 mb-2">
                                    <div className="flex items-center mb-2">
                                        <svg className="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                            <path
                                                fillRule="evenodd"
                                                d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9z"
                                                clipRule="evenodd"
                                            />
                                        </svg>
                                        <span>建議屬性</span>
                                    </div>
                                    <div className="grid grid-cols-2 gap-2">
                                        <div className="bg-pink-50 border border-pink-300 rounded-lg px-3 py-2 text-sm text-pink-800">
                                            建議破防：{calculateRecommendedBreakDefense(inputs.d_d, inputs.lambda_3)} 以上（50%穿透率）
                                        </div>
                                        <div className="bg-pink-50 border border-pink-300 rounded-lg px-3 py-2 text-sm text-pink-800">
                                            建議命中：{calculateRecommendedAccuracy(inputs.b_b)} 以上（97%命中）
                                        </div>
                                    </div>
                                </h4>

                                <div className="space-y-3">
                                    {recommendationData.length > 0 ? (
                                        <>
                                            <div className="flex items-center justify-between p-4 bg-green-50 rounded-lg border-l-4 border-green-500">
                                                <div>
                                                    <span className="font-semibold text-green-800">
                                                        最優投資: {recommendationData[0]?.label}
                                                    </span>
                                                    <p className="text-sm text-green-600 mt-1">
                                                        投資可增傷 {recommendationData[0]?.damageIncrease.toFixed(3)}%
                                                    </p>
                                                </div>
                                            </div>
                                            {recommendationData.length > 1 && (
                                                <div className="flex items-center justify-between p-4 bg-yellow-50 rounded-lg border-l-4 border-yellow-500">
                                                    <div>
                                                        <span className="font-semibold text-yellow-800">
                                                            次優選擇: {recommendationData[1]?.label}
                                                        </span>
                                                        <p className="text-sm text-yellow-600 mt-1">
                                                            投資可增傷 {recommendationData[1]?.damageIncrease.toFixed(3)}%
                                                        </p>
                                                    </div>
                                                </div>
                                            )}
                                            <div className="p-4 bg-blue-50 rounded-lg border-l-4 border-blue-500">
                                                <span className="font-semibold text-blue-800">配裝策略建議:</span>
                                                <p className="text-sm text-blue-600 mt-1">
                                                    面對「當前防守方配置」時，優先堆疊 {recommendationData[0]?.label}{" "}
                                                    {recommendationData[1] ? `和 ${recommendationData[1]?.label}` : ""}，
                                                    可以獲得最佳的攻擊效果。
                                                    <>
                                                        <br />
                                                        請注意，各裝備投放屬性數值不一致，推薦只限200點内收益，使用「從零分析」模式可以看到從頭開始配裝的最優方向。
                                                    </>
                                                </p>
                                            </div>
                                        </>
                                    ) : (
                                        <p className="text-sm text-gray-500">正在生成建議，請稍候...</p>
                                    )}
                                </div>
                            </div>

                            {/* 方案列表 */}
                            <div className="mt-6">
                                <h4 className="font-semibold text-base text-gray-800 mb-3 flex items-center">
                                    <span className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></span>
                                    保存的方案
                                </h4>
                                {presets.length === 0 ? (
                                    <p className="text-sm text-gray-500">尚未保存任何方案</p>
                                ) : (
                                    <div className="grid gap-2">
                                        {presets.map((preset, index) => (
                                            <div
                                                key={index}
                                                className="flex items-center justify-between p-3 bg-pink-50 rounded-lg hover:bg-pink-100 transition-colors duration-200"
                                            >
                                                <span className="font-medium text-gray-700">{preset.name}</span>
                                                <div className="flex gap-2">
                                                    <button
                                                        className="text-sm text-green-600 hover:text-green-800 font-medium transition-colors duration-200 flex items-center gap-1"
                                                        onClick={() => loadPreset(index)}
                                                    >
                                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                                                        </svg>
                                                        載入
                                                    </button>
                                                    <button
                                                        className="text-sm text-red-600 hover:text-red-800 font-medium transition-colors duration-200 flex items-center gap-1"
                                                        onClick={() => deletePreset(index)}
                                                    >
                                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                                        </svg>
                                                        刪除
                                                    </button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>

                            {/* 方案對比 */}
                            {presets.length >= 2 && (
                                <div className="mt-6">
                                    <h4 className="font-semibold text-base text-gray-800 mb-3 flex items-center">
                                        <span className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></span>
                                        對比兩個方案
                                    </h4>
                                    <div className="flex flex-col sm:flex-row gap-3 items-start sm:items-center">
                                        <select
                                            className="w-full sm:w-40 border border-gray-300 rounded-lg p-2 text-sm text-gray-700 focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors duration-200"
                                            onChange={(e) => setCompareIndexes((prev) => ({ ...prev, a: e.target.value }))}
                                        >
                                            <option value="">選擇方案</option>
                                            {presets.map((p, i) => (
                                                <option value={i} key={"a" + i}>
                                                    {p.name}
                                                </option>
                                            ))}
                                        </select>
                                        <select
                                            className="w-full sm:w-40 border border-gray-300 rounded-lg p-2 text-sm text-gray-700 focus:ring-2 focus:ring-pink-500 focus:border-pink-500 transition-colors duration-200"
                                            onChange={(e) => setCompareIndexes((prev) => ({ ...prev, b: e.target.value }))}
                                        >
                                            <option value="">選擇方案</option>
                                            {presets.map((p, i) => (
                                                <option value={i} key={"b" + i}>
                                                    {p.name}
                                                </option>
                                            ))}
                                        </select>
                                        <button
                                            className="w-full sm:w-auto bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-lg font-medium text-sm transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                                            onClick={comparePresets}
                                            disabled={compareIndexes.a === null || compareIndexes.b === null}
                                        >
                                            開始對比
                                        </button>
                                    </div>
                                    {compareResult && (
                                        <div className="mt-4">
                                            <div className="flex justify-between items-center mb-2">
                                                <h4 className="font-semibold text-base text-gray-800">
                                                    方案對比（B - A）
                                                </h4>
                                                <button
                                                    className="text-sm text-pink-600 hover:text-pink-800 font-medium flex items-center gap-1"
                                                    onClick={() => setIsTableExpanded(!isTableExpanded)}
                                                >
                                                    {isTableExpanded ? (
                                                        <>
                                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 15l7-7 7 7" />
                                                            </svg>
                                                            收起
                                                        </>
                                                    ) : (
                                                        <>
                                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                                                            </svg>
                                                            展開
                                                        </>
                                                    )}
                                                </button>
                                            </div>
                                            {isTableExpanded && (
                                                <div className="overflow-x-auto transition-all duration-300">
                                                    <table className="w-full text-sm border-collapse">
                                                        <thead>
                                                            <tr className="bg-pink-50">
                                                                <th className="border p-2 text-left text-pink-700">
                                                                    項目
                                                                </th>
                                                                <th className="border p-2 text-left text-pink-700">
                                                                    {presets[compareIndexes.a]?.name || "方案 A"}
                                                                </th>
                                                                <th className="border p-2 text-left text-pink-700">
                                                                    {presets[compareIndexes.b]?.name || "方案 B"}
                                                                </th>
                                                                <th className="border p-2 text-left text-pink-700">
                                                                    差異
                                                                </th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            {[
                                                                { key: "D", label: "攻擊" },
                                                                { key: "E", label: "元素攻擊（平均）" },
                                                                { key: "b_d", label: "破防" },
                                                                { key: "R", label: "流派克制" },
                                                                { key: "b_e", label: "忽視元素抗性" },
                                                                { key: "h", label: "命中" },
                                                                { key: "b_s", label: "破盾" },
                                                                { key: "b_c", label: "會心" },
                                                                { key: "d_c", label: "會心傷害" },
                                                                { key: "gamma_2", label: "防禦穿透率" },
                                                                { key: "beta_2", label: "元素穿透率" },
                                                                { key: "elementalDamagePrecentage", label: "元素傷害佔比" },
                                                                { key: "baseDamage", label: "原傷害" },
                                                                { key: "finalDamage", label: "修正後傷害" },
                                                                { key: "totalReduction", label: "增傷百分比" },
                                                            ].map(({ key, label }) => {
                                                                const aValue =
                                                                    key in presets[compareIndexes.a].data
                                                                        ? presets[compareIndexes.a].data[key]
                                                                        : calculate(presets[compareIndexes.a].data)[key];
                                                                const bValue =
                                                                    key in presets[compareIndexes.b].data
                                                                        ? presets[compareIndexes.b].data[key]
                                                                        : calculate(presets[compareIndexes.b].data)[key];
                                                                const aNum = parseFloat(aValue.replace("%", "")) || 0;
                                                                const bNum = parseFloat(bValue.replace("%", "")) || 0;
                                                                const diff = bNum - aNum;
                                                                const isPositive = diff >= 0;
                                                                return (
                                                                    <tr key={key} className="hover:bg-pink-50">
                                                                        <td className="border p-2 text-gray-700">
                                                                            {label}
                                                                        </td>
                                                                        <td className="border p-2 font-medium">{aValue}</td>
                                                                        <td className="border p-2 font-medium">{bValue}</td>
                                                                        <td
                                                                            className={`border p-2 font-medium ${isPositive ? "text-green-600" : "text-red-600"}`}
                                                                        >
                                                                            {diff >= 0 ? "+" : ""}
                                                                            {diff.toFixed(2)}
                                                                            {key === "totalReduction" ? "%" : ""}
                                                                        </td>
                                                                    </tr>
                                                                );
                                                            })}
                                                        </tbody>
                                                    </table>
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>
                    </div>

                    {/* 投資收益曲線分析 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div className="flex justify-between items-center cursor-pointer mb-2" onClick={() => setShowIncrementalAnalysis(!showIncrementalAnalysis)}>
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">投資收益曲線分析</h2>
                            </div>
                            <span className="text-pink-700 text-lg">{showIncrementalAnalysis ? '▲' : '▼'}</span>
                        </div>
                        <div className={`transition-all duration-500 overflow-hidden ${showIncrementalAnalysis ? 'max-h-[1500px] opacity-100' : 'max-h-0 opacity-0'}`}>
                            <div className="mb-4 p-4 bg-gray-50 rounded-lg">
                                <h3 className="text-sm font-semibold text-gray-700 mb-3">分析模式：</h3>
                                <div className="flex gap-4">
                                    <label className="flex items-center space-x-2 cursor-pointer">
                                        <input
                                            type="radio"
                                            name="analysisMode"
                                            value="incremental"
                                            checked={analysisMode === 'incremental'}
                                            onChange={(e) => setAnalysisMode(e.target.value)}
                                            className="w-4 h-4 text-pink-600"
                                        />
                                        <span className="text-sm">增量分析 (從當前面板繼續投資)</span>
                                    </label>
                                    <label className="flex items-center space-x-2 cursor-pointer">
                                        <input
                                            type="radio"
                                            name="analysisMode"
                                            value="from_zero"
                                            checked={analysisMode === 'from_zero'}
                                            onChange={(e) => setAnalysisMode(e.target.value)}
                                            className="w-4 h-4 text-pink-600"
                                        />
                                        <span className="text-sm">從零分析 (各屬性從0開始堆疊)</span>
                                    </label>
                                </div>
                            </div>
                            <p className="text-sm text-gray-600 mb-4">
                                {analysisMode === 'incremental'
                                    ? '顯示從當前攻擊數值基礎上投入不同點數的增傷效果'
                                    : '顯示各攻擊屬性從0開始投入不同點數的增傷效果（用於新角色配裝規劃）'}
                            </p>
                            <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                                <div className="flex items-center justify-between mb-3">
                                    <h3 className="text-sm font-semibold text-gray-700">選擇要顯示的曲線：</h3>
                                    <div className="flex gap-2">
                                        <button
                                            onClick={handleSelectAll}
                                            className="px-3 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600"
                                        >
                                            全選
                                        </button>
                                        <button
                                            onClick={handleDeselectAll}
                                            className="px-3 py-1 text-xs bg-gray-500 text-white rounded hover:bg-gray-600"
                                        >
                                            全不選
                                        </button>
                                    </div>
                                </div>
                                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                                    {recommendationData
                                        .filter((attr) => attr.attribute !== "d_c_percent")
                                        .map((attr, index) => (
                                            <label key={attr.attribute} className="flex items-center space-x-2 cursor-pointer">
                                                <input
                                                    type="checkbox"
                                                    checked={visibility[attr.attribute] || false}
                                                    onChange={() => handleCurveToggle(attr.attribute)}
                                                    className="w-4 h-4 text-pink-600 rounded focus:ring-pink-500"
                                                />
                                                <div className="flex items-center space-x-2">
                                                    <div className="w-3 h-3 rounded-full" style={{ backgroundColor: colors[index % colors.length] }}></div>
                                                    <span className="text-sm text-gray-700">{attr.label}</span>
                                                </div>
                                            </label>
                                        ))}
                                </div>
                            </div>
                            {increaseData.length > 0 ? (
                                <ResponsiveContainer width="100%" height={400}>
                                    <LineChart data={increaseData}>
                                        <CartesianGrid strokeDasharray="3 3" />
                                        <XAxis
                                            dataKey="point"
                                            label={{ value: '投入點數', position: 'insideBottom', offset: -5 }}
                                        />
                                        <YAxis
                                            label={{ value: '增傷%', angle: -90, position: 'insideLeft' }}
                                            tickFormatter={(value) => (value * 100).toFixed(2)}
                                        />
                                        <Tooltip
                                            formatter={(value, name) => [
                                                `${(value * 100).toFixed(2)}%`,
                                                recommendationData.find((d) => d.attribute === name)?.label || name,
                                            ]}
                                            labelFormatter={(points) => `投入點數: ${points}`}
                                        />
                                        <Legend />
                                        {recommendationData
                                            .filter((attr) => attr.attribute !== "d_c_percent")
                                            .map((attr, index) => visibility[attr.attribute] && (
                                                <Line
                                                    key={attr.attribute}
                                                    type="monotone"
                                                    dataKey={attr.attribute}
                                                    stroke={colors[index % colors.length]}
                                                    strokeWidth={2}
                                                    dot={false}
                                                    name={attr.label}
                                                />
                                            ))}
                                    </LineChart>
                                </ResponsiveContainer>
                            ) : (
                                <p className="text-sm text-gray-500">正在生成圖表，請稍候...</p>
                            )}
                        </div>
                    </div>

                    {/* 每200點屬性增傷收益 */}
                    <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
                        <div className="flex justify-between items-center cursor-pointer mb-2" onClick={() => setShowIncrementalAnalysis(!showIncrementalAnalysis)}>
                            <div className="flex items-center">
                                <div className="w-1.5 h-5 rounded-full bg-pink-500 mr-2"></div>
                                <h2 className="font-bold text-base md:text-lg text-gray-800">每200點屬性增傷收益</h2>
                            </div>
                            <span className="text-pink-700 text-lg">{showIncrementalAnalysis ? '▲' : '▼'}</span>
                        </div>
                        <div className={`transition-all duration-500 overflow-hidden ${showIncrementalAnalysis ? 'max-h-[1500px] opacity-100' : 'max-h-0 opacity-0'}`}>
                            <div className="flex flex-wrap gap-4 mb-4">
                                {[
                                    { key: 'D', label: '攻擊', color: '#db2537' },
                                    { key: 'E', label: '元素攻擊', color: '#ff6b6b' },
                                    { key: 'R', label: '克制', color: '#14b8a6' },
                                    { key: 'b_d', label: '破防', color: '#3b82f6' },
                                    { key: 'b_e', label: '忽視元素抗性', color: '#10b981' },
                                    { key: 'b_s', label: '破盾', color: '#8b5cf6' },
                                    { key: 'b_c', label: '會心', color: '#f59e0b' },
                                ].map(({ key, label, color }) => (
                                    <label key={key} className="flex items-center">
                                        <input
                                            type="checkbox"
                                            checked={visibility[key]}
                                            onChange={() => toggleVisibility(key)}
                                            className="mr-2"
                                        />
                                        <span style={{ color }}>{label}</span>
                                    </label>
                                ))}
                            </div>
                            <div className="w-full h-[250px] sm:h-[300px] md:h-[350px]">
                                {deltaData.length > 0 ? (
                                    <ResponsiveContainer width="100%" height="100%">
                                        <LineChart data={deltaData}>
                                            <CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
                                            <XAxis
                                                dataKey="point"
                                                label={{ value: '屬性點', position: 'insideBottom', offset: -5, fontSize: 12, fill: '#6b7280' }}
                                                tick={{ fill: '#6b7280', fontSize: 12 }}
                                            />
                                            <YAxis
                                                label={{ value: '每200點收益 (%)', angle: -90, position: 'insideLeft', fontSize: 12, fill: '#6b7280' }}
                                                tickFormatter={(value) => (value * 100).toFixed(4)}
                                                tick={{ fill: '#6b7280', fontSize: 12 }}
                                            />
                                            <Tooltip content={<CustomTooltip isDelta={true} />} />
                                            <Legend wrapperStyle={{ fontSize: 12 }} />
                                            {visibility.D && (
                                                <Line type="monotone" dataKey="D" name="攻擊" stroke="#db2537" strokeWidth={2} dot={false} />
                                            )}
                                            {visibility.E && (
                                                <Line type="monotone" dataKey="E" name="元素攻擊" stroke="#ff6b6b" strokeWidth={2} dot={false} />
                                            )}
                                            {visibility.R && (
                                                <Line type="monotone" dataKey="R" name="克制" stroke="#14b8a6" strokeWidth={2} dot={false} />
                                            )}
                                            {visibility.b_d && (
                                                <Line type="monotone" dataKey="b_d" name="破防" stroke="#3b82f6" strokeWidth={2} dot={false} />
                                            )}
                                            {visibility.b_e && (
                                                <Line type="monotone" dataKey="b_e" name="忽視元素抗性" stroke="#10b981" strokeWidth={2} dot={false} />
                                            )}
                                            {visibility.b_s && (
                                                <Line type="monotone" dataKey="b_s" name="破盾" stroke="#8b5cf6" strokeWidth={2} dot={false} />
                                            )}
                                            {visibility.b_c && (
                                                <Line type="monotone" dataKey="b_c" name="會心" stroke="#f59e0b" strokeWidth={2} dot={false} />
                                            )}

                                        </LineChart>
                                    </ResponsiveContainer>
                                ) : (
                                    <p className="text-sm text-gray-500">正在生成圖表，請稍候...</p>
                                )}
                            </div>
                        </div>
                    </div>

                    <div className="text-center text-xs text-gray-500 mb-4">
                        <p>攻擊計算器 © {new Date().getFullYear()} | 數據僅供參考</p>

                    </div>
                </div>
            );
        };


        // Footer Component
        const Footer = () => {
            return (
                <footer className="bg-transparent text-gray-700 p-4 text-center mt-6">
                    <div className="max-w-3xl mx-auto text-sm text-center">
                        <p className="font-semibold mb-1">櫻桃碎碎念</p>
                        <p>
                            公式參考了
                            <a
                                href="https://m.bilibili.com/opus/979579497904865287"
                                target="_blank"
                                rel="noopener noreferrer"
                                className="text-cherry-600 hover:underline"
                            >
                                折字愿为安
                            </a>
                            和
                            <a
                                href="https://b23.tv/C4Iq2IZ"
                                target="_blank"
                                rel="noopener noreferrer"
                                className="text-cherry-600 hover:underline"
                            >
                                进团先发秒伤
                            </a>
                            兩位老師的專欄。經過驗證適用於台服目前版本。考慮到很多人不太喜歡數學，所以才整合成計算器。本來還想加上對塔傷害部分，但因為我一個人難以驗證，結果還是放棄了。後續可能大概還會更新內功和周天，可能吧我也不知道。
                        </p>
                    </div>
                </footer>
            );
        };

        // App Component
        const App = () => {
            const [activeCalculator, setActiveCalculator] = useState(null);

            return (
                <div className="flex min-h-screen flex-col">
                    <div className="flex flex-1">
                        <Sidebar setActiveCalculator={setActiveCalculator} />
                        <div className="flex-1 md:ml-64">
                            {!activeCalculator ? (
                                <HomeMenu setActiveCalculator={setActiveCalculator} />
                            ) : activeCalculator === 'damage' ? (
                                <DamageCalculator />
                            ) : activeCalculator === 'healing' ? (
                                <HealingCalculator />
                            ) : (
                                <DamageCalculator2 />
                            )}
                        </div>
                    </div>
                    <Footer />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById("root"));
        root.render(<App />);

    </script>


</body>

</html>