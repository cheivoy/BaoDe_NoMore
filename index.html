<html lang="zh-TW"><head>
  <script type="text/javascript">
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
      return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
      if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
        try {
          var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
          var firstSheetName = workbook.SheetNames[0];
          var worksheet = workbook.Sheets[firstSheetName];

          // Convert sheet to JSON to filter blank rows
          var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
          // Filter out blank rows (rows where all cells are empty, null, or undefined)
          var filteredData = jsonData.filter(row => row.some(filledCell));

          // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
          var headerRowIndex = filteredData.findIndex((row, index) =>
            row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
          );
          // Fallback
          if (headerRowIndex === -1 || headerRowIndex > 25) {
            headerRowIndex = 0;
          }

          // Convert filtered JSON back to CSV
          var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
          csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
          return csv;
        } catch (e) {
          console.error(e);
          return "";
        }
      }
      return gk_fileData[filename] || "";
    }
  </script>




  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>éŠæˆ²è¨ˆç®—å™¨</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/core-js/3.38.1/minified.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
  <script src="https://cdn.sheetjs.com/xlsx-latest/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/recharts@2.12.7/umd/Recharts.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            cherry: {
              50: '#fff0f6',
              100: '#ffd6e7',
              200: '#ffadd2',
              300: '#ff85b8',
              400: '#f75998',
              500: '#eb2f7a',
              600: '#c41d5d',
              700: '#9e1045',
              800: '#78062f',
              900: '#52001d',
            },
            chart: {
              blue: '#3b82f6',
              green: '#10b981',
              purple: '#8b5cf6',
              teal: '#14b8a6',
              orange: '#f97316',
            }
          }
        }
      }
    }
  </script>
  <script type="text/javascript">
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
      return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
      if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
        try {
          var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
          var firstSheetName = workbook.SheetNames[0];
          var worksheet = workbook.Sheets[firstSheetName];
          var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
          var filteredData = jsonData.filter(row => row.some(filledCell));
          var headerRowIndex = filteredData.findIndex((row, index) =>
            row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
          );
          if (headerRowIndex === -1 || headerRowIndex > 25) {
            headerRowIndex = 0;
          }
          var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
          csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
          return csv;
        } catch (e) {
          console.error(e);
          return "";
        }
      }
      return gk_fileData[filename] || "";
    }
  </script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');

    body {
      font-family: 'Noto Sans TC', sans-serif;
      background-color: #fff0f6;
      margin: 0;
      padding: 0;
    }

    .input-focus:focus {
      border-color: #eb2f7a;
      box-shadow: 0 0 0 3px rgba(235, 47, 122, 0.2);
      outline: none;
    }

    .cherry-gradient {
      background: linear-gradient(135deg, #ffd6e7 0%, #eb2f7a 100%);
    }

    .result-card {
      transition: all 0.3s ease;
    }

    .result-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(235, 47, 122, 0.1);
    }

    .scrollbar-cherry::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    .scrollbar-cherry::-webkit-scrollbar-track {
      background: #ffd6e7;
    }

    .scrollbar-cherry::-webkit-scrollbar-thumb {
      background-color: #eb2f7a;
      border-radius: 20px;
    }

    .tooltip-hidden {
      display: none;
    }

    .group:hover .tooltip-hidden,
    .group:active .tooltip-hidden {
      display: block;
    }

    @media (max-width: 640px) {
      .container {
        padding: 1rem;
      }

      h1 {
        font-size: 1.5rem;
      }

      h2 {
        font-size: 1.125rem;
      }

      input,
      button,
      select {
        font-size: 0.875rem;
        padding: 0.5rem;
      }
    }
  </style>
</head>

<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect } = React;

    // Sidebar Component
    const Sidebar = ({ setActiveCalculator }) => {
      const [isOpen, setIsOpen] = useState(false);

      return (
        <>
          <button
            className="md:hidden fixed top-4 left-4 z-50 text-cherry-800 p-2 rounded-full bg-cherry-100 hover:bg-cherry-200"
            onClick={() => setIsOpen(!isOpen)}
            aria-label="å±•é–‹å´é‚Šæ¬„"
          >
            <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16m-7 6h7" />
            </svg>
          </button>
          <div
            className={`fixed top-0 left-0 h-full bg-cherry-50 w-64 transform ${isOpen ? 'translate-x-0' : '-translate-x-full'
              } md:translate-x-0 transition-transform duration-300 ease-in-out z-40 shadow-lg`}
          >
            <div className="p-4">
              <h2 className="text-lg font-bold text-cherry-800">è¨ˆç®—å™¨</h2>
              <nav className="mt-4 space-y-2">
                <button
                  onClick={() => { setActiveCalculator('damage'); setIsOpen(false); }}
                  className="block w-full text-left py-2 px-4 text-cherry-700 hover:bg-cherry-100 rounded-lg transition-colors"
                >
                  é˜²å®ˆè¨ˆç®—å™¨
                </button>
                <button
                  onClick={() => { setActiveCalculator('healing'); setIsOpen(false); }}
                  className="block w-full text-left py-2 px-4 text-cherry-700 hover:bg-cherry-100 rounded-lg transition-colors"
                >
                  æ²»ç™‚å¼·åº¦è¨ˆç®—
                </button>
                <button
                  onClick={() => { setActiveCalculator('damage_2'); setIsOpen(false); }}
                  className="block w-full text-left py-2 px-4 text-cherry-700 hover:bg-cherry-100 rounded-lg transition-colors"
                >
                  æ”»æ“Šè¨ˆç®—å™¨
                </button>
              </nav>
            </div>
          </div>
          {isOpen && (
            <div
              className="fixed inset-0 bg-black bg-opacity-50 md:hidden z-30"
              onClick={() => setIsOpen(false)}
            ></div>
          )}
        </>
      );
    };

    const HomeMenu = () => {
      const [activeCalculator, setActiveCalculator] = useState(null);

      useEffect(() => {
        // åˆæ¬¡è¼‰å…¥è·³å‡ºæé†’
        alert(
          'âš ï¸ 1 è¨ˆç®—å™¨éæœ€çµ‚å‚·å®³ï¼Œåƒ…ä½œé¢æ¿å±¬æ€§æ”¶ç›Šè¨ˆç®—ä¹‹ç”¨\n' +
          'âš ï¸ 2 åƒ… PVP é©ç”¨ï¼ŒPVE è«‹è‡ªå·±æ‰“æœ¨æ¨æ¸¬è©¦\n' +
          'âš ï¸ 3 åœ–ç‰‡è­˜åˆ¥ä½¿ç”¨å…è²»è³‡æºï¼Œæº–ç¢ºåº¦å ªæ†‚ï¼Œå»ºè­°æ‰‹å‹•è¼¸å…¥\n' +
          'âš ï¸ 4 æœ‰å•é¡Œå¯è¯çµ¡ ID æ«»æ¡ƒç™¾è˜­åœ°ï¼Œæœƒæ“ºçˆ›å¼ä¿®æ­£'
        );
      }, []);

      // é¦–é é¸å–®
      if (!activeCalculator) {
        return (
          <div className="min-h-screen flex flex-col items-center justify-center px-4">
            <h1 className="text-3xl font-bold text-cherry-800 mb-8">å±¬æ€§æ”¶ç›Šåˆ†æè¨ˆç®—å™¨</h1>
            <div className="grid grid-cols-1 sm:grid-cols-3 gap-6 w-full max-w-4xl">
              <button
                onClick={() => setActiveCalculator('damage')}
                className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition result-card"
              >
                é˜²å®ˆè¨ˆç®—å™¨
              </button>
              <button
                onClick={() => setActiveCalculator('healing')}
                className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition result-card"
              >
                æ²»ç™‚å¼·åº¦è¨ˆç®—
              </button>
              <button
                onClick={() => setActiveCalculator('damage_2')}
                className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition result-card"
              >
                æ”»æ“Šè¨ˆç®—å™¨
              </button>
            </div>
          </div>
        );
      }

      // æ ¹æ“šé¸æ“‡æ¸²æŸ“å°æ‡‰çš„è¨ˆç®—å™¨ï¼ˆä½ å·²æœ‰ç¾æˆçš„å…§å®¹æ‡‰è©²æœƒç”¨é€™äº›å€¼ä¾†åˆ‡æ›ï¼‰
      return (
        <>
          <Sidebar setActiveCalculator={setActiveCalculator} />
          {activeCalculator === 'damage' && <div><DamageCalculator /></div>}
          {activeCalculator === 'healing' && <div><HealingCalculator /></div>}
          {activeCalculator === 'damage_2' && <div><DamageCalculator2 /></div>}
        </>
      );
    };


    // ImageUploader Component
    const ImageUploader = ({ setInputs, type }) => {
      const [uploadedImages, setUploadedImages] = useState([]);
      const [isProcessing, setIsProcessing] = useState(false);
      const [progress, setProgress] = useState(0);
      const [error, setError] = useState(null);

      const handleImageUpload = (event) => {
        const files = Array.from(event.target.files).slice(0, 5); // é™åˆ¶æœ€å¤š5å¼µåœ–ç‰‡
        if (files.length > 0) {
          setUploadedImages(files);
          setError(null);
        }
      };

      const preprocessImage = (file) => {
        return new Promise((resolve) => {
          const img = new Image();
          img.src = URL.createObjectURL(file);
          img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const MAX_SIZE = 1280;
            let { width, height } = img;
            if (width > MAX_SIZE || height > MAX_SIZE) {
              const ratio = Math.min(MAX_SIZE / width, MAX_SIZE / height);
              width *= ratio;
              height *= ratio;
            }
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);

            // Grayscale and binarization
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
              const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
              const binary = avg > 128 ? 255 : 0;
              data[i] = data[i + 1] = data[i + 2] = binary;
            }
            ctx.putImageData(imageData, 0, 0);

            canvas.toBlob((blob) => {
              resolve(blob);
            }, 'image/png');
          };
          img.onerror = () => {
            setError('åœ–åƒåŠ è¼‰å¤±æ•—ï¼Œè«‹æª¢æŸ¥æ–‡ä»¶æ ¼å¼');
            resolve(file);
          };
        });
      };

      const startRecognition = async () => {
        if (uploadedImages.length === 0) return;

        setIsProcessing(true);
        setProgress(0);
        setError(null);

        let combinedValues = {};

        for (let i = 0; i < uploadedImages.length; i++) {
          const file = uploadedImages[i];
          try {
            const processedImage = await preprocessImage(file);

            const { data: { text } } = await Tesseract.recognize(
              processedImage,
              'chi_tra+eng',
              {
                logger: m => {
                  if (m.status === 'recognizing text') {
                    setProgress(Math.round((i / uploadedImages.length + m.progress / uploadedImages.length) * 100));
                  }
                }
              }
            );

            const values = parseText(text, type);
            if (Object.keys(values).length === 0) {
              setError(`åœ–ç‰‡ ${file.name} æœªèƒ½è­˜åˆ¥åˆ°æœ‰æ•ˆæ•¸æ“šï¼Œè«‹ç¢ºä¿åœ–ç‰‡æ¸…æ™°ä¸”åŒ…å«å±¬æ€§æ–‡å­—`);
            }
            combinedValues = { ...combinedValues, ...values };

          } catch (error) {
            console.error(`è™•ç†åœ–ç‰‡ ${file.name} æ™‚å‡ºéŒ¯ï¼š`, error);
            setError(`è™•ç†åœ–ç‰‡ ${file.name} æ™‚å‡ºéŒ¯ï¼š${error.message}`);
          }
        }

        if (Object.keys(combinedValues).length > 0) {
          setInputs(prev => ({ ...prev, ...combinedValues }));
        }
        setIsProcessing(false);
        setProgress(0);
      };

      const parseText = (text, type) => {
        const values = {};
        const regex = /([\u4e00-\u9fa5]+[\u4e00-\u9fa5\sï¼š:]*)\s*[ï¼š:]*\s*([\d.,\/%-]+(?:\s*-\s*\d+)?)/g;
        let match;

        while ((match = regex.exec(text)) !== null) {
          const label = match[1].trim().replace(/\s+/g, '');
          let value = match[2].replace(/[,]/g, '').replace('%', '');

          if (type === 'attacker') {
            if (label.includes('æŠ€èƒ½å€ç‡')) values.skill_multiplier = value;
            if (label.includes('æ”»æ“Š') && !label.includes('å…ƒç´ æ”»æ“Š') && !label.includes('æ”»æ“Š%')) {
              const [low] = value.split('-').map(Number);
              values.D = low.toString();
            }
            if (label.includes('å…ƒç´ æ”»æ“Š')) values.E = value;
            if (label.includes('æœƒå¿ƒæ•¸å€¼') || (label.includes('æœƒå¿ƒ') && !label.includes('æœƒå¿ƒå‚·å®³') && !label.includes('æœƒå¿ƒé˜²ç¦¦'))) {
              values.b_c = value;
            }
            if (label.includes('æœƒå¿ƒå‚·å®³')) {
              values.d_c = (parseFloat(value) / 100).toString();
            }
            if (label.includes('æµæ´¾å…‹åˆ¶') && !label.includes('æµæ´¾å…‹åˆ¶%')) {
              const [baseValue] = value.split('/').map(v => v.trim());
              values.R = baseValue;
            }
            if (label.includes('æµæ´¾å…‹åˆ¶%')) {
              const [, percentValue] = value.split('/').map(v => parseFloat(v));
              values.flow_percent = (percentValue / 100).toString();
            }
            if (label.includes('å‘½ä¸­')) values.h = value;
            if (label.includes('ç ´é˜²')) values.b_d = value;
            if (label.includes('ç ´ç›¾')) values.b_s = value;
            if (label.includes('å¿½è¦–å…ƒç´ æŠ—æ€§')) values.b_e = value;
            if (label.includes('å¢å‚·')) {
              values.damage_increase = (parseFloat(value) / 100).toString();
            }
            if (label.includes('æŠ€èƒ½å¢å‚·')) {
              values.skill_damage_increase = (parseFloat(value) / 100).toString();
            }
            if (label.includes('é‡‘å‘¨å¤©')) {
              if (value.includes('1ç´š') || value.includes('1')) values.gold_i = '0.03';
              else if (value.includes('2ç´š') || value.includes('2')) values.gold_i = '0.04';
              else if (value.includes('3ç´š') || value.includes('3')) values.gold_i = '0.05';
              else values.gold_i = '0';
            }
          } else if (type === 'defender') {
            if (label.includes('æ°£è¡€')) values.hp = value.split('/')[0];
            if (label.includes('é˜²ç¦¦')) values.d_d = value;
            if (label.includes('æŠ—æœƒå¿ƒæ•¸å€¼') || (label.includes('æœƒå¿ƒ') && !label.includes('æœƒå¿ƒå‚·å®³') && !label.includes('æœƒå¿ƒé˜²ç¦¦'))) {
              values.b_c_defense = value;
            }
            if (label.includes('æœƒå¿ƒé˜²ç¦¦')) {
              values.d_c_defense = (parseFloat(value) / 100).toString();
            }
            if (label.includes('æ ¼æ“‹')) values.b_b = value;
            if (label.includes('å…ƒç´ æŠ—æ€§')) values.d_e = value;
            if (label.includes('å‚·å®³æ¸›å…')) {
              values.damage_reduction = (parseFloat(value) / 100).toString();
            }
            if (label.includes('æµæ´¾æŠµç¦¦') && !label.includes('æµæ´¾æŠµç¦¦%')) {
              const [baseValue] = value.split('/').map(v => v.trim());
              values.d_f = baseValue;
            }
            if (label.includes('æµæ´¾æŠµç¦¦%')) {
              const [, percentValue] = value.split('/').map(v => parseFloat(v));
              values.flow_resist_percent = (percentValue / 100).toString();
            }
            if (label.includes('æ€ªç‰©å…‹åˆ¶')) {
              const [, second] = value.split('/').map(v => parseFloat(v));
              values.flow_resist_percent = (second / 100).toString();
            }
            if (label.includes('æ°£ç›¾')) values.d_s = value;
            if (label.includes('æŠ€èƒ½æ¸›å…')) values.skill_damage_reduction = (parseFloat(value) / 100).toString();
          }

          if (label.includes('ç ´é˜²')) values.armor_break = value;
          if (label.includes('å‘½ä¸­')) values.hit = value;
          if (label.includes('å…ƒç´ æ”»æ“Š')) values.elemental_attack = value;
          if (label.includes('é¦–é ˜å…‹åˆ¶')) {
            const [first] = value.split('/').map(v => parseFloat(v));
            values.boss_restraint = first.toString();
          }
          if (label.includes('æµæ´¾å…‹åˆ¶')) {
            const [first, second] = value.split('/').map(v => parseFloat(v));
            values.faction_restraint = Math.max(first, second).toString();
          }
          if (label.includes('æŠ—æ€§å¿½è¦–')) values.resistance_ignore = value;
          if (label.includes('æ²»ç™‚å¼·åº¦')) values.healing_power_equip = value;
        }
        return values;
      };

      return (
        <div className="mb-4">
          <label className="block mb-2 text-sm font-medium text-gray-700">
            {type === 'attacker' ? 'ä¸Šå‚³æ”»æ“Šæ–¹æˆªåœ–' : type === 'defender' ? 'ä¸Šå‚³é˜²å®ˆæ–¹æˆªåœ–' : 'ä¸Šå‚³æˆªåœ–'}
          </label>
          <input
            type="file"
            accept="image/*"
            onChange={handleImageUpload}
            multiple
            className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-cherry-500 file:text-white hover:file:bg-cherry-600"
          />
          {error && (
            <p className="mt-2 text-sm text-red-600">{error}</p>
          )}
          {uploadedImages.length > 0 && (
            <div className="mt-2 flex items-center space-x-2">
              <p className="text-xs text-gray-500">å·²é¸ {uploadedImages.length} å¼µåœ–ç‰‡</p>
              <button
                onClick={startRecognition}
                disabled={isProcessing}
                className="bg-cherry-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-cherry-700 disabled:bg-cherry-300 transition-colors"
              >
                {isProcessing ? `è­˜åˆ¥ä¸­... ${progress}%` : 'é–‹å§‹è­˜åˆ¥'}
              </button>
            </div>
          )}
          {isProcessing && (
            <div className="mt-2 w-full bg-gray-200 rounded-full h-2.5">
              <div
                className="bg-cherry-600 h-2.5 rounded-full transition-all duration-300"
                style={{ width: `${progress}%` }}
              ></div>
            </div>
          )}
        </div>
      );
    };

    // HealingCalculator Component
    const HealingCalculator = () => {
      const [inputs, setInputs] = useState({
        armor_break: "0",
        hit: "0",
        elemental_attack: "0",
        boss_restraint: "0",
        faction_restraint: "0",
        resistance_ignore: "0",
        healing_power_equip: "0"
      });
      const [inputErrors, setInputErrors] = useState({});

      const handleChange = (e) => {
        const { name, value } = e.target;
        if (value < 0) {
          setInputErrors((prev) => ({ ...prev, [name]: 'è¼¸å…¥å€¼ä¸èƒ½ç‚ºè² æ•¸' }));
          return;
        }
        if (value > 1000000) {
          setInputErrors((prev) => ({ ...prev, [name]: 'è¼¸å…¥å€¼éå¤§ï¼Œæœ€å¤§ç‚º100000' }));
          return;
        }
        setInputs((prev) => ({ ...prev, [name]: value }));
        setInputErrors((prev) => ({ ...prev, [name]: '' }));
      };

      const calculateHealing = () => {
        const {
          armor_break, hit, elemental_attack, boss_restraint, faction_restraint, resistance_ignore, healing_power_equip
        } = inputs;

        const toNum = (val) => parseFloat(val) || 0;

        const attributeConversion = (
          (toNum(armor_break) * 3 / 1000) +
          (toNum(hit) * 9 / 1000) +
          (toNum(elemental_attack) * 7 / 1000) +
          (toNum(boss_restraint) * 3 / 1000) +
          (toNum(faction_restraint) * 3 / 1000) +
          (toNum(resistance_ignore) * 9 / 1000)
        );

        const healingPower = Math.floor(attributeConversion) * 100 + toNum(healing_power_equip) + 503;

        return {
          attributeConversion: attributeConversion.toFixed(2),
          healingPower: healingPower.toFixed(0)
        };
      };

      const result = calculateHealing();

      return (
        <div className="p-4 container mx-auto min-h-screen">
          <div className="cherry-gradient rounded-xl p-6 mb-6 shadow-lg">
            <h1 className="text-xl md:text-2xl font-bold text-center text-white">æ²»ç™‚å¼·åº¦è¨ˆç®—å™¨</h1>
            <p className="text-center text-white text-opacity-90 text-sm mt-1">å¦‚æœ‰å•é¡Œè«‹è¯ç¹«æ«»æ¡ƒç™½è˜­åœ°@ç·£å®šä»Šç”Ÿ</p>
          </div>

          <ImageUploader setInputs={setInputs} type="healing" />

          <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
            <div className="flex items-center mb-4">
              <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
              <h2 className="font-bold text-base md:text-lg text-gray-800">æ²»ç™‚åƒæ•¸</h2>
            </div>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
              {[
                { key: "armor_break", label: "ç ´é˜²", icon: "ğŸ›¡ï¸" },
                { key: "hit", label: "å‘½ä¸­", icon: "ğŸ¯" },
                { key: "elemental_attack", label: "å…ƒç´ æ”»æ“Š", icon: "âœ¨" },
                { key: "boss_restraint", label: "é¦–é ˜å…‹åˆ¶", icon: "ğŸ‘‘" },
                { key: "faction_restraint", label: "æµæ´¾å…‹åˆ¶", icon: "ğŸ”„" },
                { key: "resistance_ignore", label: "æŠ—æ€§å¿½è¦–", icon: "ğŸŒ€" },
                { key: "healing_power_equip", label: "æ²»ç™‚å¼·åº¦ï¼ˆè£å‚™ï¼‰", icon: "ğŸ’‰" }
              ].map(({ key, label, icon }) => (
                <div key={key} className="flex flex-col">
                  <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                    <span className="mr-1 md:mr-2">{icon}</span>{label}
                  </label>
                  <input
                    type="number"
                    name={key}
                    value={inputs[key]}
                    onChange={handleChange}
                    min="0"
                    max="1000000"
                    className={`input-focus border ${inputErrors[key] ? 'border-red-500' : 'border-gray-200'} rounded-lg p-2 text-sm w-full`}
                    aria-label={label}
                  />
                  {inputErrors[key] && (
                    <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                  )}
                </div>
              ))}
            </div>
          </div>

          <div className="result-card bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100">
            <div className="flex items-center mb-4">
              <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
              <h2 className="font-bold text-base md:text-lg text-gray-800">è¨ˆç®—çµæœ</h2>
            </div>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
              <div className="bg-cherry-50 p-3 rounded-lg">
                <p className="text-xs text-cherry-700">å±¬æ€§è½‰æ›å€¼</p>
                <p className="text-lg md:text-xl font-bold text-cherry-800">{result.attributeConversion}</p>
              </div>
              <div className="bg-cherry-500 p-3 rounded-lg">
                <p className="text-xs text-white">ç¸½æ²»ç™‚å¼·åº¦</p>
                <p className="text-lg md:text-xl font-bold text-white">{result.healingPower}</p>
              </div>
            </div>
          </div>
        </div>
      );
    };

    // DamageCalculator Component
    const DamageCalculator = () => {
      const [inputs, setInputs] = useState({
        skill_multiplier: "1518",
        D: "5000", E: "800", b_c: "900", d_c: "1.8", R: "500", h: "700",
        b_d: "2000", b_s: "700", b_e: "0", flow_percent: "0", damage_increase: "0",
        skill_damage_increase: "0",
        d_s: "2000", d_f: "2000", d_d: "5000", d_e: "0", b_b: "600", hp: "80000",
        b_c_defense: "550", d_c_defense: "0", flow_resist_percent: "0", damage_reduction: "0",
        skill_damage_reduction: "0",
        lambda_1: "358", lambda_2: "0.359", lambda_3: "2860", lambda_4: "531", W: "1",
        gold_i: "0"
      });
      const [inputErrors, setInputErrors] = useState({});
      const [previousResult, setPreviousResult] = useState(null);
      const [previousInputs, setPreviousInputs] = useState(null);
      // æ–°å¢å¯è¦‹æ€§ç‹€æ…‹ï¼Œæ§åˆ¶æ›²ç·šé¡¯ç¤º
      const [visibility, setVisibility] = useState({
        ds: true, // æ°£ç›¾
        dd: true, // é˜²ç¦¦
        df: true, // æµæ´¾æŠµç¦¦
        de: true, // å…ƒç´ æŠ—æ€§
        bb: true  // æ ¼æ“‹
      });

      const [showAttacker, setShowAttacker] = useState(false);
      const [showDefender, setShowDefender] = useState(false);
      const [showOriginal, setShowOriginal] = useState(true);
      const [showReduced, setShowReduced] = useState(true);

      const goldOptions = [
        { value: "0", label: "ç„¡é‡‘å‘¨å¤©" },
        { value: "0.03", label: "é‡‘å‘¨å¤©1ç´š" },
        { value: "0.04", label: "é‡‘å‘¨å¤©2ç´š" },
        { value: "0.05", label: "é‡‘å‘¨å¤©3ç´š" },
      ];

      const elementWeaknessOptions = [
        { value: "1", label: "ç„¡å…ƒç´ å¼±é»" },
        { value: "1.1", label: "ç¢å¤¢å¤§ç‰¹" },
      ];

      const handleChange = (e) => {
        const { name, value } = e.target;
        if (name === 'gold_i' || name === 'W') {
          setInputs((prev) => ({ ...prev, [name]: value }));
          setInputErrors((prev) => ({ ...prev, [name]: '' }));
        } else {
          if (value < 0) {
            setInputErrors((prev) => ({ ...prev, [name]: 'è¼¸å…¥å€¼ä¸èƒ½ç‚ºè² æ•¸' }));
            return;
          }
          if (value > 1000000) {
            setInputErrors((prev) => ({ ...prev, [name]: 'è¼¸å…¥å€¼éå¤§ï¼Œæœ€å¤§ç‚º1000000' }));
            return;
          }
          setInputs((prev) => ({ ...prev, [name]: value }));
          setInputErrors((prev) => ({ ...prev, [name]: '' }));
        }
      };

      const saveCurrentResult = () => {
        setPreviousResult(calculate(inputs));
        setPreviousInputs({ ...inputs });
      };

      // åˆ‡æ›æ›²ç·šå¯è¦‹æ€§
      const toggleVisibility = (key) => {
        setVisibility((prev) => ({ ...prev, [key]: !prev[key] }));
      };

      const toNum = (val) => {
        const num = parseFloat(val);
        return isNaN(num) ? 0 : num;
      };

      const calculate = (inputs) => {
        const {
          skill_multiplier, D, E, b_c, d_c, R, h, b_d, b_s, b_e, flow_percent, damage_increase,
          skill_damage_increase, d_s, d_f, d_d, d_e, b_b, hp, b_c_defense, d_c_defense,
          flow_resist_percent, damage_reduction, skill_damage_reduction, lambda_1, lambda_2,
          lambda_3, lambda_4, W, gold_i
        } = inputs;

        const c = toNum(b_c) - toNum(b_c_defense);
        const p_c = (115 * c + 90) / (c + 940) / 100 + toNum(gold_i);
        const r_h = 143 * toNum(h) / (toNum(h) + 3678) / 100;
        const r_b = 143 * toNum(b_b) / (toNum(b_b) + 3678) / 100;
        const p_h = Math.min(1, 0.95 + r_h - r_b);
        const m_c = 1 + p_c * (toNum(d_c) - 1 - toNum(d_c_defense));
        const d_mul = m_c * p_h + 0.5 * (1 - p_h);
        const G = toNum(b_s) >= toNum(d_s)
          ? 0
          : toNum(d_s) / 3 <= toNum(b_s)
            ? 0.5 * (toNum(d_s) - toNum(b_s))
            : toNum(d_s) - 2 * toNum(b_s);
        const A = toNum(D) + (toNum(R) - toNum(d_f)) - G;
        const gamma = toNum(d_d) - toNum(b_d) > 0
          ? (toNum(d_d) - toNum(b_d)) / (toNum(d_d) - toNum(b_d) + toNum(lambda_3))
          : 0;
        const e = toNum(d_e) - toNum(b_e);
        const beta = e > 0 ? e / (e + toNum(lambda_4)) : 0;
        const c_original = toNum(b_c);
        const p_c_original = (115 * c_original + 90) / (c_original + 940) / 100 + toNum(gold_i);
        const r_h_original = r_h;
        const r_b_original = 0;
        const p_h_original = Math.min(1, 0.95 + r_h_original - r_b_original);
        const m_c_original = 1 + p_c_original * (toNum(d_c) - 1);
        const d_mul_original = m_c_original * p_h_original + 0.5 * (1 - p_h_original);
        const G_original = toNum(b_s);
        const gamma_original = 0;
        const A_original = toNum(D) + toNum(R) + G_original;
        const beta_original = 0;

        const baseDamage = (
          (toNum(skill_multiplier) / 100) * (((toNum(lambda_1) + toNum(lambda_2) * A_original) * (1 - gamma_original)) +
            toNum(W) * toNum(lambda_2) * toNum(E) * (1 - beta_original))
        ) * d_mul_original * (1 + toNum(flow_percent)) * (1 + toNum(damage_increase)) * (1 + toNum(skill_damage_increase) / 100);

        const finalDamage = (
          (toNum(skill_multiplier) / 100) * (((toNum(lambda_1) + toNum(lambda_2) * A) * (1 - gamma)) +
            toNum(W) * toNum(lambda_2) * toNum(E) * (1 - beta))
        ) * d_mul * (1 + toNum(flow_percent) - toNum(flow_resist_percent)) * (1 + toNum(damage_increase) - toNum(damage_reduction)) * (1 + toNum(skill_damage_increase) / 100 - toNum(skill_damage_reduction) / 100);

        const totalReduction = (baseDamage - finalDamage) / baseDamage || 0;
        const ehp = toNum(hp) / (1 - totalReduction) || toNum(hp);

        return {
          c: c.toFixed(2),
          p_c: (p_c * 100).toFixed(2) + "%",
          r_h: (r_h * 100).toFixed(2) + "%",
          r_b: (r_b * 100).toFixed(2) + "%",
          p_h: p_h.toFixed(4),
          m_c: m_c.toFixed(4),
          d_mul: d_mul.toFixed(4),
          G: G.toFixed(2),
          A: A.toFixed(2),
          gamma: (gamma * 100).toFixed(2) + "%",
          beta: (beta * 100).toFixed(2) + "%",
          c_original: c_original.toFixed(2),
          p_c_original: (p_c_original * 100).toFixed(2) + "%",
          r_h_original: (r_h_original * 100).toFixed(2) + "%",
          r_b_original: (r_b_original * 100).toFixed(2) + "%",
          p_h_original: p_h_original.toFixed(4),
          m_c_original: m_c_original.toFixed(4),
          d_mul_original: d_mul_original.toFixed(4),
          G_original: G_original.toFixed(2),
          A_original: A_original.toFixed(2),
          gamma_original: (gamma_original * 100).toFixed(2) + "%",
          beta_original: (beta_original * 100).toFixed(2) + "%",
          baseDamage: baseDamage.toFixed(2),
          finalDamage: finalDamage.toFixed(2),
          totalReduction: (totalReduction * 100).toFixed(2) + "%",
          ehp: ehp.toFixed(2)
        };
      };

      const generateChartData = (inputs) => {
        const attribute_points = Array.from({ length: 51 }, (_, i) => i * 200);
        const reductions = { ds: [], dd: [], df: [], de: [], bb: [] };
        const delta_reductions = { ds: [], dd: [], df: [], de: [], bb: [] };

        const calculateDamage = (D, R, b_s, d_s, d_f, b_d, d_d, E, b_e, d_e, b_c, d_c, h, b_b, b_c_defense, d_c_defense, flow_percent, damage_increase, flow_resist_percent, damage_reduction, lambda_1, lambda_2, lambda_3, lambda_4, W, gold_i) => {
          const c = toNum(b_c) - toNum(b_c_defense);
          const p_c = (115 * c + 90) / (c + 940) / 100 + toNum(gold_i);
          const r_h = 143 * toNum(h) / (toNum(h) + 3678) / 100;
          const r_b = 143 * toNum(b_b) / (toNum(b_b) + 3678) / 100;
          const p_h = Math.min(1, 0.95 + r_h - r_b);
          const m_c = 1 + p_c * (toNum(d_c) - 1 - toNum(d_c_defense));
          const d_mul = m_c * p_h + 0.5 * (1 - p_h);
          const G = toNum(b_s) >= toNum(d_s)
            ? 0
            : toNum(d_s) / 3 <= toNum(b_s)
              ? 0.5 * (toNum(d_s) - toNum(b_s))
              : toNum(d_s) - 2 * toNum(b_s);
          const A = toNum(D) + (toNum(R) - toNum(d_f)) - G;
          const gamma = toNum(d_d) - toNum(b_d) > 0
            ? (toNum(d_d) - toNum(b_d)) / (toNum(d_d) - toNum(b_d) + toNum(lambda_3))
            : 0;
          const e = toNum(d_e) - toNum(b_e);
          const beta = e > 0 ? e / (e + toNum(lambda_4)) : 0;
          return (
            (toNum(inputs.skill_multiplier) / 100) * (((toNum(lambda_1) + toNum(lambda_2) * A) * (1 - gamma)) +
              toNum(W) * toNum(lambda_2) * toNum(E) * (1 - beta))
          ) * d_mul * (1 + toNum(flow_percent) - toNum(flow_resist_percent)) * (1 + toNum(damage_increase) - toNum(damage_reduction));
        };

        const d_original = calculateDamage(
          toNum(inputs.D), toNum(inputs.R), toNum(inputs.b_s), 0, 0, toNum(inputs.b_d), 0,
          toNum(inputs.E), toNum(inputs.b_e), 0, toNum(inputs.b_c), toNum(inputs.d_c),
          toNum(inputs.h), 0, 0, 0, toNum(inputs.flow_percent), toNum(inputs.damage_increase), 0, 0,
          toNum(inputs.lambda_1), toNum(inputs.lambda_2), toNum(inputs.lambda_3), toNum(inputs.lambda_4), toNum(inputs.W), toNum(inputs.gold_i)
        );

        const calculateReduction = (attr, value) => {
          const params = { d_s: 0, d_d: 0, d_f: 0, d_e: 0, b_b: 0 };
          params[attr] = value;
          const d_reduced = calculateDamage(
            toNum(inputs.D), toNum(inputs.R), toNum(inputs.b_s), params.d_s, params.d_f,
            toNum(inputs.b_d), params.d_d, toNum(inputs.E), toNum(inputs.b_e), params.d_e,
            toNum(inputs.b_c), toNum(inputs.d_c), toNum(inputs.h), params.b_b,
            toNum(inputs.b_c_defense), toNum(inputs.d_c_defense),
            toNum(inputs.flow_percent), toNum(inputs.damage_increase),
            toNum(inputs.flow_resist_percent), toNum(inputs.damage_reduction),
            toNum(inputs.lambda_1), toNum(inputs.lambda_2), toNum(inputs.lambda_3), toNum(inputs.lambda_4), toNum(inputs.W), toNum(inputs.gold_i)
          );
          return d_original ? 1 - d_reduced / d_original : 0;
        };

        attribute_points.forEach((point) => {
          reductions.ds.push(calculateReduction('d_s', point));
          reductions.dd.push(calculateReduction('d_d', point));
          reductions.df.push(calculateReduction('d_f', point));
          reductions.de.push(calculateReduction('d_e', point));
          reductions.bb.push(calculateReduction('b_b', point));
        });

        for (let i = 1; i < reductions.ds.length; i++) {
          delta_reductions.ds.push(reductions.ds[i] - reductions.ds[i - 1]);
          delta_reductions.dd.push(reductions.dd[i] - reductions.dd[i - 1]);
          delta_reductions.df.push(reductions.df[i] - reductions.df[i - 1]);
          delta_reductions.de.push(reductions.de[i] - reductions.de[i - 1]);
          delta_reductions.bb.push(reductions.bb[i] - reductions.bb[i - 1]);
        }

        const deltaData = attribute_points.slice(1).map((point, i) => ({
          point,
          ds: delta_reductions.ds[i],
          dd: delta_reductions.dd[i],
          df: delta_reductions.df[i],
          de: delta_reductions.de[i],
          bb: delta_reductions.bb[i]
        }));

        const reductionData = attribute_points.map((point, i) => ({
          point,
          ds: reductions.ds[i],
          dd: reductions.dd[i],
          df: reductions.df[i],
          de: reductions.de[i],
          bb: reductions.bb[i]
        }));

        return { deltaData, reductionData };
      };

      const CustomTooltip = ({ active, payload, label, isDelta }) => {
        if (active && payload && payload.length) {
          return (
            <div className="bg-white p-3 border border-gray-200 rounded-lg shadow-sm">
              <p className="text-sm text-gray-700 font-medium">å±¬æ€§é»: {label}</p>
              {payload.map((entry, index) => (
                <p key={index} className="text-sm text-gray-600">
                  <span style={{ color: entry.stroke }}>{entry.name}</span>: {(entry.value * 100).toFixed(isDelta ? 4 : 2)}%
                </p>
              ))}
            </div>
          );
        }
        return null;
      };

      const result = calculate(inputs);
      const { deltaData, reductionData } = generateChartData(inputs);

      return (
        <div className="p-4 container mx-auto min-h-screen">
          <div className="cherry-gradient rounded-xl p-6 mb-6 shadow-lg">
            <h1 className="text-xl md:text-2xl font-bold text-center text-white">é˜²å®ˆå±¬æ€§æ”¶ç›Šè¨ˆç®—å™¨</h1>
            <p className="text-center text-white text-opacity-90 text-sm mt-1">å¦‚æœ‰å•é¡Œè«‹è¯ç¹«æ«»æ¡ƒç™½è˜­åœ°@ç·£å®šä»Šç”Ÿ</p>
          </div>

          <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-4">
            <div
              className="flex justify-between items-center cursor-pointer mb-2"
              onClick={() => setShowAttacker(!showAttacker)}
            >
              <div className="flex items-center">
                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                <h2 className="font-bold text-base md:text-lg text-gray-800">æ”»æ“Šæ–¹åƒæ•¸</h2>
              </div>
              <span className="text-cherry-700 text-lg">{showAttacker ? '^' : 'âŒ„'}</span>
            </div>
            <div
              className={`transition-all duration-500 overflow-hidden ${showAttacker ? 'max-h-[1000px] opacity-100' : 'max-h-0 opacity-0'}`}
            >
              <ImageUploader setInputs={setInputs} type="attacker" />
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {[
                  { key: "skill_multiplier", label: "æŠ€èƒ½å€ç‡", icon: "ğŸ”¥", tooltip: "å¦‚æŠ€èƒ½å€ç‡ç‚º300%ï¼Œè¼¸å…¥300" },
                  { key: "D", label: "æ”»æ“Š", icon: "âš”ï¸" },
                  { key: "E", label: "å…ƒç´ æ”»æ“Šï¼ˆå¹³å‡ï¼‰", icon: "âœ¨" },
                  { key: "b_c", label: "æœƒå¿ƒæ•¸å€¼", icon: "ğŸ¯" },
                  { key: "d_c", label: "æœƒå¿ƒå‚·å®³", icon: "ğŸ’¥", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚180%ï¼Œè¼¸å…¥1.8" },
                  { key: "R", label: "æµæ´¾å…‹åˆ¶", icon: "ğŸ”„" },
                  { key: "h", label: "å‘½ä¸­", icon: "ğŸ¯" },
                  { key: "b_d", label: "ç ´é˜²", icon: "ğŸ›¡ï¸" },
                  { key: "b_s", label: "ç ´ç›¾", icon: "ğŸ”¨" },
                  { key: "b_e", label: "å¿½è¦–å…ƒç´ æŠ—æ€§", icon: "ğŸŒ€" },
                  { key: "flow_percent", label: "æµæ´¾å…‹åˆ¶%", icon: "ğŸ“Š", tooltip: "ä¾‹å¦‚9.5%ï¼Œè¼¸å…¥0.095ã€‚æ‰€æœ‰%çš†ç‚ºç›¸åŠ ï¼Œä¾‹å¦‚10%+5%=15%=è¼¸å…¥0.15" },
                  { key: "damage_increase", label: "å¢å‚·%", icon: "ğŸ“ˆ", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05ã€‚æ‰€æœ‰%çš†ç‚ºç›¸åŠ ï¼Œä¾‹å¦‚10%+5%=15%=è¼¸å…¥0.15" },
                  { key: "skill_damage_increase", label: "æŠ€èƒ½å¢å‚·%", icon: "ğŸ“ˆ", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05ã€‚æ‰€æœ‰%çš†ç‚ºç›¸åŠ ï¼Œä¾‹å¦‚10%+5%=15%=è¼¸å…¥0.15" },
                  { key: "gold_i", label: "é‡‘å‘¨å¤©", icon: "ğŸŒŸ", type: "select", options: goldOptions },
                  { key: "W", label: "å…ƒç´ å¼±é»", icon: "ğŸ–•ğŸ»", type: "select", options: elementWeaknessOptions }
                ].map(({ key, label, icon, type, options, tooltip }) => (
                  <div key={key} className="flex flex-col group relative">
                    <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                      <span className="mr-1 md:mr-2">{icon}</span>{label}{tooltip && <span> </span>}
                      {tooltip && (
                        <>
                          <span className="flex items-center justify-center w-4 h-4 rounded-full bg-gray-500 text-white text-xs cursor-pointer">?</span>
                          <div className="tooltip-hidden absolute left-0 top-8 bg-cherry-50 text-cherry-700 text-xs p-2 rounded-lg shadow-md z-10 max-w-xs">
                            {tooltip}
                          </div>
                        </>
                      )}
                    </label>
                    {type === "select" ? (
                      <select
                        name={key}
                        value={inputs[key]}
                        onChange={handleChange}
                        className="input-focus border border-gray-200 rounded-lg p-2 text-sm w-full"
                        aria-label={label}
                      >
                        {options.map(opt => (
                          <option key={opt.value} value={opt.value}>{opt.label}</option>
                        ))}
                      </select>
                    ) : (
                      <input
                        type="number"
                        name={key}
                        value={inputs[key]}
                        onChange={handleChange}
                        min="0"
                        max="1000000"
                        className={`input-focus border ${inputErrors[key] ? 'border-red-500' : 'border-gray-200'} rounded-lg p-2 text-sm w-full`}
                        aria-label={label}
                      />
                    )}
                    {inputErrors[key] && (
                      <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                    )}
                  </div>
                ))}
              </div>
            </div>
          </div>

          <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-4">
            <div
              className="flex justify-between items-center cursor-pointer mb-2"
              onClick={() => setShowDefender(!showDefender)}
            >
              <div className="flex items-center">
                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                <h2 className="font-bold text-base md:text-lg text-gray-800">é˜²å®ˆæ–¹åƒæ•¸</h2>
              </div>
              <span className="text-cherry-700 text-lg">{showDefender ? '^' : 'âŒ„'}</span>
            </div>
            <div
              className={`transition-all duration-500 overflow-hidden ${showDefender ? 'max-h-[1000px] opacity-100' : 'max-h-0 opacity-0'}`}
            >
              <ImageUploader setInputs={setInputs} type="defender" />
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {[
                  { key: "d_s", label: "æ°£ç›¾", icon: "ğŸ›¡ï¸" },
                  { key: "d_f", label: "æµæ´¾æŠµç¦¦", icon: "ğŸ”„" },
                  { key: "d_d", label: "é˜²ç¦¦", icon: "ğŸ°" },
                  { key: "d_e", label: "å…ƒç´ æŠ—æ€§", icon: "ğŸŒ€" },
                  { key: "b_b", label: "æ ¼æ“‹", icon: "âœ‹" },
                  { key: "hp", label: "æ°£è¡€", icon: "â¤ï¸" },
                  { key: "b_c_defense", label: "æŠ—æœƒå¿ƒæ•¸å€¼", icon: "ğŸ¯" },
                  { key: "d_c_defense", label: "æœƒå¿ƒé˜²ç¦¦%", icon: "ğŸ“Š", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚25%ï¼Œè¼¸å…¥0.25ã€‚æ‰€æœ‰%çš†ç‚ºç›¸åŠ ï¼Œä¾‹å¦‚10%+5%=15%=è¼¸å…¥0.15" },
                  { key: "flow_resist_percent", label: "æµæ´¾æŠµç¦¦%", icon: "ğŸ“Š", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05ã€‚æ‰€æœ‰%çš†ç‚ºç›¸åŠ ï¼Œä¾‹å¦‚10%+5%=15%=è¼¸å…¥0.15" },
                  { key: "damage_reduction", label: "å‚·å®³æ¸›å…%", icon: "ğŸ“‰", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚15%ï¼Œè¼¸å…¥0.15ã€‚æ‰€æœ‰%çš†ç‚ºç›¸åŠ ï¼Œä¾‹å¦‚10%+5%=15%=è¼¸å…¥0.15" },
                  { key: "skill_damage_reduction", label: "æŠ€èƒ½æ¸›å…%", icon: "ğŸ“‰", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05ã€‚æ‰€æœ‰%çš†ç‚ºç›¸åŠ ï¼Œä¾‹å¦‚10%+5%=15%=è¼¸å…¥0.15" }
                ].map(({ key, label, icon, tooltip }) => (
                  <div key={key} className="flex flex-col group relative">
                    <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                      <span className="mr-1 md:mr-2">{icon}</span>{label}{tooltip && <span> </span>}
                      {tooltip && (
                        <>
                          <span className="flex items-center justify-center w-4 h-4 rounded-full bg-gray-500 text-white text-xs cursor-pointer">?</span>
                          <div className="tooltip-hidden absolute left-0 top-8 bg-cherry-50 text-cherry-700 text-xs p-2 rounded-lg shadow-md z-10 max-w-xs">
                            {tooltip}
                          </div>
                        </>
                      )}
                    </label>
                    <input
                      type="number"
                      name={key}
                      value={inputs[key]}
                      onChange={handleChange}
                      min="0"
                      max="1000000"
                      className={`input-focus border ${inputErrors[key] ? 'border-red-500' : 'border-gray-200'} rounded-lg p-2 text-sm w-full`}
                      aria-label={label}
                    />
                    {inputErrors[key] && (
                      <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                    )}
                  </div>
                ))}
              </div>
            </div>
          </div>

          <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
            {/* åŸæ•¸å€¼å±¬æ€§å€å¡Š */}
            <div
              className="flex justify-between items-center cursor-pointer mb-2"
              onClick={() => setShowOriginal(!showOriginal)}
            >
              <div className="flex items-center">
                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                <h2 className="font-bold text-base md:text-lg text-gray-800">åŸæ•¸å€¼å±¬æ€§</h2>
              </div>
              <span className="text-cherry-700 text-lg">{showOriginal ? '^' : 'âŒ„'}</span>
            </div>
            <div className={`transition-all duration-500 overflow-hidden ${showOriginal ? 'max-h-[1000px] opacity-100' : 'max-h-0 opacity-0'}`}>
              <div className="grid grid-cols-2 gap-3 mb-4">
                {[{ label: "çœŸå¯¦æœƒå¿ƒ", value: result.c_original },
                { label: "æœƒå¿ƒç‡", value: result.p_c_original },
                { label: "å‘½ä¸­ä¿®æ­£", value: result.r_h_original },
                { label: "æ ¼æ“‹ç‡", value: result.r_b_original },
                { label: "å‘½ä¸­å¢å¹…å€ç‡", value: result.p_h_original },
                { label: "æœƒå¿ƒå‚·å®³å€ç‡", value: result.m_c_original },
                { label: "å‚·å®³å€ç‡", value: result.d_mul_original },
                { label: "å‰©é¤˜æ°£ç›¾", value: result.G_original },
                { label: "é˜²ç¦¦å‚·å®³æ¸›å…", value: result.gamma_original },
                { label: "å…ƒç´ å‚·å®³æ¸›å…", value: result.beta_original }]
                  .map(({ label, value }) => (
                    <div key={label} className="bg-gray-50 p-2 md:p-3 rounded-lg">
                      <p className="text-xs text-gray-600">{label}</p>
                      <p className="text-sm font-bold text-gray-800">{value}</p>
                    </div>
                  ))}
              </div>
            </div>

            {/* æ¸›å‚·å¾Œå±¬æ€§å€å¡Š */}
            <div
              className="flex justify-between items-center cursor-pointer mb-2"
              onClick={() => setShowReduced(!showReduced)}
            >
              <div className="flex items-center">
                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                <h2 className="font-bold text-base md:text-lg text-gray-800">æ¸›å‚·å¾Œå±¬æ€§</h2>
              </div>
              <span className="text-cherry-700 text-lg">{showReduced ? '^' : 'âŒ„'}</span>
            </div>
            <div className={`transition-all duration-500 overflow-hidden ${showReduced ? 'max-h-[1000px] opacity-100' : 'max-h-0 opacity-0'}`}>
              <div className="grid grid-cols-2 gap-3">
                {[{ label: "ä¿®æ­£æœƒå¿ƒ", value: result.c },
                { label: "æœƒå¿ƒç‡", value: result.p_c },
                { label: "å‘½ä¸­ä¿®æ­£", value: result.r_h },
                { label: "æ ¼æ“‹ç‡", value: result.r_b },
                { label: "å‘½ä¸­å¢å¹…å€ç‡", value: result.p_h },
                { label: "æœƒå¿ƒå‚·å®³å€ç‡", value: result.m_c },
                { label: "å‚·å®³å€ç‡", value: result.d_mul },
                { label: "å‰©é¤˜æ°£ç›¾", value: result.G },
                { label: "é˜²ç¦¦å‚·å®³æ¸›å…", value: result.gamma },
                { label: "å…ƒç´ å‚·å®³æ¸›å…", value: result.beta }]
                  .map(({ label, value }) => (
                    <div key={label} className="bg-cherry-50 p-2 md:p-3 rounded-lg">
                      <p className="text-xs text-cherry-600">{label}</p>
                      <p className="text-sm font-bold text-cherry-800">{value}</p>
                    </div>
                  ))}
              </div>
            </div>
          </div>

          <div className="result-card bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
            <div className="flex justify-between items-center mb-4">
              <div className="flex items-center">
                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                <h2 className="font-bold text-base md:text-lg text-gray-800">å‚·å®³è¨ˆç®—çµæœ</h2>
              </div>
              <button
                onClick={saveCurrentResult}
                className="bg-cherry-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-cherry-700 transition-colors"
              >
                ä¿å­˜çµæœ
              </button>
            </div>
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-3">
              {[
                { label: "åŸå‚·å®³", value: result.baseDamage, color: "cherry-100" },
                { label: "æ¸›å‚·å¾Œå‚·å®³", value: result.finalDamage, color: "cherry-100" },
                { label: "æœ‰æ•ˆæ°£è¡€ (EHP)", value: result.ehp, color: "cherry-100" },
                { label: "ç¸½æ¸›å‚·ç‡", value: result.totalReduction, color: "cherry-500", text: "white" },
              ].map(({ label, value, color, text }) => (
                <div key={label} className={`bg-${color} p-3 rounded-lg`}>
                  <p className={`text-xs ${text ? `text-${text}` : 'text-cherry-700'}`}>{label}</p>
                  <p className={`text-lg font-bold ${text ? `text-${text}` : 'text-cherry-800'}`}>{value}</p>
                </div>
              ))}
            </div>
            {previousResult && previousInputs && (
              <div className="mt-6">
                <div className="flex items-center mb-4">
                  <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                  <h3 className="font-bold text-base md:text-lg text-gray-800">èˆ‡ä¸Šæ¬¡çµæœå°æ¯”</h3>
                </div>
                <div className="overflow-x-auto scrollbar-cherry">
                  <table className="w-full text-sm border-collapse">
                    <thead>
                      <tr className="bg-cherry-50">
                        <th className="border p-2 text-left text-cherry-700">é …ç›®</th>
                        <th className="border p-2 text-left text-cherry-700">ç•¶å‰</th>
                        <th className="border p-2 text-left text-cherry-700">ä¸Šæ¬¡</th>
                        <th className="border p-2 text-left text-cherry-700">å·®ç•°</th>
                      </tr>
                    </thead>
                    <tbody>
                      {[
                        { key: 'hp', label: 'æ°£è¡€ (hp)' },
                        { key: 'd_s', label: 'æ°£ç›¾ (d_s)' },
                        { key: 'd_d', label: 'é˜²ç¦¦ (d_d)' },
                        { key: 'd_f', label: 'æµæ´¾æŠµç¦¦ (d_f)' },
                        { key: 'd_e', label: 'å…ƒç´ æŠ—æ€§ (d_e)' },
                        { key: 'b_b', label: 'æ ¼æ“‹ (b_b)' },
                        { key: 'baseDamage', label: 'åŸå‚·å®³' },
                        { key: 'finalDamage', label: 'æ¸›å‚·å¾Œå‚·å®³' },
                        { key: 'ehp', label: 'æœ‰æ•ˆæ°£è¡€ (EHP)' },
                        { key: 'totalReduction', label: 'ç¸½æ¸›å‚·ç‡' }
                      ].map(({ key, label }) => {
                        const currentValue = key in inputs ? inputs[key] : result[key];
                        const previousValue = key in previousInputs ? previousInputs[key] : previousResult[key];
                        const current = parseFloat(currentValue.replace('%', '')) || 0;
                        const previous = parseFloat(previousValue.replace('%', '')) || 0;
                        const diff = current - previous;
                        const isPositive = diff > 0;
                        return (
                          <tr key={key} className="hover:bg-cherry-50">
                            <td className="border p-2 text-gray-700">{label}</td>
                            <td className="border p-2 font-medium">{currentValue}</td>
                            <td className="border p-2">{previousValue}</td>
                            <td className={`border p-2 font-medium ${isPositive ? 'text-green-600' : 'text-red-600'}`}>
                              {isPositive ? 'â†‘' : 'â†“'} {Math.abs(diff).toFixed(2)}{key === 'totalReduction' ? '%' : ''}
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </div>
                <div className="mt-4 p-3 bg-cherry-50 rounded-lg">
                  <h4 className="font-bold text-cherry-700 mb-2 flex items-center">
                    <svg className="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                      <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9z" clipRule="evenodd" />
                    </svg>
                    é…ç½®å»ºè­°
                  </h4>
                  <p className="text-xs text-gray-700">
                    é˜²ç¦¦å’Œæµæ´¾æŠµç¦¦æå‡æ¸›å‚·ç‡ï¼Œé©åˆé«˜å‚·å®³å ´æ™¯ï¼›é«˜æ°£è¡€æå‡EHPï¼Œé©åˆå¤šæ¬¡æ”»æ“Šå ´æ™¯ã€‚è‹¥EHPå·®è·ä¸å¤§ï¼Œé¸æ“‡æ”»æ“Šé«˜çš„é…ç½®ã€‚
                  </p>
                </div>
              </div>
            )}
          </div>

          <div className="grid grid-cols-1 gap-4 mb-6">
            <div className="result-card bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100">
              <div className="flex items-center mb-4">
                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                <h2 className="font-bold text-base md:text-lg text-gray-800">æ¯200é»å±¬æ€§æ¸›å‚·æ”¶ç›Š</h2>
              </div>
              {/* æ–°å¢å‹¾é¸æ¡† */}
              <div className="flex flex-wrap gap-4 mb-4">
                {[
                  { key: 'ds', label: 'æ°£ç›¾', color: '#3b82f6' },
                  { key: 'dd', label: 'é˜²ç¦¦', color: '#10b981' },
                  { key: 'df', label: 'æµæ´¾æŠµç¦¦', color: '#8b5cf6' },
                  { key: 'de', label: 'å…ƒç´ æŠ—æ€§', color: '#14b8a6' },
                  { key: 'bb', label: 'æ ¼æ“‹', color: '#f97316' }
                ].map(({ key, label, color }) => (
                  <label key={key} className="flex items-center">
                    <input
                      type="checkbox"
                      checked={visibility[key]}
                      onChange={() => toggleVisibility(key)}
                      className="mr-2"
                    />
                    <span style={{ color }}>{label}</span>
                  </label>
                ))}
              </div>
              <div className="w-full h-[250px] sm:h-[300px] md:h-[350px]">
                <Recharts.ResponsiveContainer width="100%" height="100%">
                  <Recharts.LineChart data={deltaData}>
                    <Recharts.CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
                    <Recharts.XAxis
                      dataKey="point"
                      label={{ value: "å±¬æ€§é»", position: "insideBottom", offset: -5, fontSize: 12, fill: "#6b7280" }}
                      tick={{ fill: "#6b7280", fontSize: 12 }}
                    />
                    <Recharts.YAxis
                      label={{ value: "æ¯200é»æ”¶ç›Š (%)", angle: -90, position: "insideLeft", fontSize: 12, fill: "#6b7280" }}
                      tickFormatter={(value) => (value * 100).toFixed(4)}
                      tick={{ fill: "#6b7280", fontSize: 12 }}
                    />
                    <Recharts.Tooltip content={<CustomTooltip isDelta={true} />} />
                    <Recharts.Legend wrapperStyle={{ fontSize: 12 }} />
                    {/* æ ¹æ“šå¯è¦‹æ€§å‹•æ…‹æ¸²æŸ“æ›²ç·š */}
                    {visibility.ds && <Recharts.Line type="monotone" dataKey="ds" name="æ°£ç›¾" stroke="#3b82f6" strokeWidth={2} dot={false} />}
                    {visibility.dd && <Recharts.Line type="monotone" dataKey="dd" name="é˜²ç¦¦" stroke="#10b981" strokeWidth={2} dot={false} />}
                    {visibility.df && <Recharts.Line type="monotone" dataKey="df" name="æµæ´¾æŠµç¦¦" stroke="#8b5cf6" strokeWidth={2} dot={false} />}
                    {visibility.de && <Recharts.Line type="monotone" dataKey="de" name="å…ƒç´ æŠ—æ€§" stroke="#14b8a6" strokeWidth={2} dot={false} />}
                    {visibility.bb && <Recharts.Line type="monotone" dataKey="bb" name="æ ¼æ“‹" stroke="#f97316" strokeWidth={2} dot={false} />}
                  </Recharts.LineChart>
                </Recharts.ResponsiveContainer>
              </div>
            </div>

            <div className="result-card bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100">
              <div className="flex items-center mb-4">
                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                <h2 className="font-bold text-base md:text-lg text-gray-800">æ¸›å‚·ç‡éš¨å±¬æ€§é»å¢å¹…</h2>
              </div>
              {/* æ–°å¢å‹¾é¸æ¡† */}
              <div className="flex flex-wrap gap-4 mb-4">
                {[
                  { key: 'ds', label: 'æ°£ç›¾', color: '#3b82f6' },
                  { key: 'dd', label: 'é˜²ç¦¦', color: '#10b981' },
                  { key: 'df', label: 'æµæ´¾æŠµç¦¦', color: '#8b5cf6' },
                  { key: 'de', label: 'å…ƒç´ æŠ—æ€§', color: '#14b8a6' },
                  { key: 'bb', label: 'æ ¼æ“‹', color: '#f97316' }
                ].map(({ key, label, color }) => (
                  <label key={key} className="flex items-center">
                    <input
                      type="checkbox"
                      checked={visibility[key]}
                      onChange={() => toggleVisibility(key)}
                      className="mr-2"
                    />
                    <span style={{ color }}>{label}</span>
                  </label>
                ))}
              </div>
              <div className="w-full h-[250px] sm:h-[300px] md:h-[350px]">
                <Recharts.ResponsiveContainer width="100%" height="100%">
                  <Recharts.LineChart data={reductionData}>
                    <Recharts.CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
                    <Recharts.XAxis
                      dataKey="point"
                      label={{ value: "å±¬æ€§é»", position: "insideBottom", offset: -5, fontSize: 12, fill: "#6b7280" }}
                      tick={{ fill: "#6b7280", fontSize: 12 }}
                    />
                    <Recharts.YAxis
                      label={{ value: "ç¸½æ¸›å‚·ç‡ (%)", angle: -90, position: "insideLeft", fontSize: 12, fill: "#6b7280" }}
                      tickFormatter={(value) => (value * 100).toFixed(2)}
                      tick={{ fill: "#6b7280", fontSize: 12 }}
                    />
                    <Recharts.Tooltip content={<CustomTooltip isDelta={false} />} />
                    <Recharts.Legend wrapperStyle={{ fontSize: 12 }} />
                    {/* æ ¹æ“šå¯è¦‹æ€§å‹•æ…‹æ¸²æŸ“æ›²ç·š */}
                    {visibility.ds && <Recharts.Line type="monotone" dataKey="ds" name="æ°£ç›¾" stroke="#3b82f6" strokeWidth={2} dot={false} />}
                    {visibility.dd && <Recharts.Line type="monotone" dataKey="dd" name="é˜²ç¦¦" stroke="#10b981" strokeWidth={2} dot={false} />}
                    {visibility.df && <Recharts.Line type="monotone" dataKey="df" name="æµæ´¾æŠµç¦¦" stroke="#8b5cf6" strokeWidth={2} dot={false} />}
                    {visibility.de && <Recharts.Line type="monotone" dataKey="de" name="å…ƒç´ æŠ—æ€§" stroke="#14b8a6" strokeWidth={2} dot={false} />}
                    {visibility.bb && <Recharts.Line type="monotone" dataKey="bb" name="æ ¼æ“‹" stroke="#f97316" strokeWidth={2} dot={false} />}
                  </Recharts.LineChart>
                </Recharts.ResponsiveContainer>
              </div>
            </div>
          </div>

          <div className="text-center text-xs text-gray-500 mb-4">
            <p>é˜²å®ˆå±¬æ€§æ”¶ç›Šè¨ˆç®—å™¨ Â© {new Date().getFullYear()} | æ•¸æ“šåƒ…ä¾›åƒè€ƒ</p>
          </div>
        </div>
      );
    };

    const DamageCalculator2 = () => {
      const [inputs, setInputs] = useState({
        skill_multiplier: "1518",
        D: "5000", E: "800", b_c: "900", d_c: "1.8", R: "500", h: "700",
        b_d: "2000", b_s: "700", b_e: "0", flow_percent: "0", damage_increase: "0",
        skill_damage_increase: "0",
        d_s: "2000", d_f: "2000", d_d: "5000", d_e: "0", b_b: "600", hp: "80000",
        b_c_defense: "550", d_c_defense: "0", flow_resist_percent: "0", damage_reduction: "0",
        skill_damage_reduction: "0",
        lambda_1: "358", lambda_2: "0.359", lambda_3: "2860", lambda_4: "531", W: "1",
        gold_i: "0"
      });
      const [inputErrors, setInputErrors] = useState({});
      const [previousResult, setPreviousResult] = useState(null);
      const [previousInputs, setPreviousInputs] = useState(null);
      // æ–°å¢å¯è¦‹æ€§ç‹€æ…‹ï¼Œæ§åˆ¶æ›²ç·šé¡¯ç¤º
      const [visibility, setVisibility] = useState({
        b_d: true, // ç ´é˜²
        b_e: true, // å¿½è¦–å…ƒç´ æŠ—æ€§
        R: true, // å…‹åˆ¶
        h: true, // å‘½ä¸­
        D: true, // æ”»æ“Š
        E: true, // å…ƒç´ æ”»æ“Š
      });

      const [showAttacker, setShowAttacker] = useState(false);
      const [showDefender, setShowDefender] = useState(false);
      const [showOriginal, setShowOriginal] = useState(true);
      const [showCorrected, setShowCorrected] = useState(true);

      const goldOptions = [
        { value: "0", label: "ç„¡é‡‘å‘¨å¤©" },
        { value: "0.03", label: "é‡‘å‘¨å¤©1ç´š" },
        { value: "0.04", label: "é‡‘å‘¨å¤©2ç´š" },
        { value: "0.05", label: "é‡‘å‘¨å¤©3ç´š" },
      ];

      const elementWeaknessOptions = [
        { value: "1", label: "ç„¡å…ƒç´ å¼±é»" },
        { value: "1.1", label: "ç¢å¤¢å¤§ç‰¹" },
      ];

      const handleChange = (e) => {
        const { name, value } = e.target;
        if (name === 'gold_i' || name === 'W') {
          setInputs((prev) => ({ ...prev, [name]: value }));
          setInputErrors((prev) => ({ ...prev, [name]: '' }));
        } else {
          if (value < 0) {
            setInputErrors((prev) => ({ ...prev, [name]: 'è¼¸å…¥å€¼ä¸èƒ½ç‚ºè² æ•¸' }));
            return;
          }
          if (value > 1000000) {
            setInputErrors((prev) => ({ ...prev, [name]: 'è¼¸å…¥å€¼éå¤§ï¼Œæœ€å¤§ç‚º1000000' }));
            return;
          }
          setInputs((prev) => ({ ...prev, [name]: value }));
          setInputErrors((prev) => ({ ...prev, [name]: '' }));
        }
      };

      const saveCurrentResult = () => {
        setPreviousResult(calculate(inputs));
        setPreviousInputs({ ...inputs });
      };

      const toggleVisibility = (key) => {
        setVisibility((prev) => ({ ...prev, [key]: !prev[key] }));
      };

      const toNum = (val) => {
        const num = parseFloat(val);
        return isNaN(num) ? 0 : num;
      };

      const calculate = (inputs) => {
        const {
          skill_multiplier, D, E, b_c, d_c, R, h, b_d, b_s, b_e, flow_percent, damage_increase,
          skill_damage_increase, d_s, d_f, d_d, d_e, b_b, hp, b_c_defense, d_c_defense,
          flow_resist_percent, damage_reduction, skill_damage_reduction, lambda_1, lambda_2,
          lambda_3, lambda_4, W, gold_i, d_b
        } = inputs;

        const toNumVal = (val) => Number(val) || 0;

        const c = toNumVal(b_c) - toNumVal(b_c_defense);
        const p_c = (115 * c + 90) / (c + 940) / 100 + toNumVal(gold_i);
        const r_h = 143 * toNumVal(h) / (toNumVal(h) + 3678) / 100;
        const r_b = 143 * toNumVal(b_b) / (toNumVal(b_b) + 3678) / 100;
        const p_h = Math.min(1, 0.95 + r_h - r_b);
        const m_c = 1 + p_c * (toNumVal(d_c) - 1 - toNumVal(d_c_defense));
        const d_mul = m_c * p_h + 0.5 * (1 - p_h);

        const G = toNumVal(b_s) >= toNumVal(d_s)
          ? 0
          : toNumVal(d_s) / 3 <= toNumVal(b_s)
            ? 0.5 * (toNumVal(d_s) - toNumVal(b_s))
            : toNumVal(d_s) - 2 * toNumVal(b_s);

        const A = toNumVal(D) + (toNumVal(R) - toNumVal(d_f)) - G;

        const gamma = toNumVal(d_d) - toNumVal(b_d) > 0
          ? (toNumVal(d_d) - toNumVal(b_d)) / (toNumVal(d_d) - toNumVal(b_d) + toNumVal(lambda_3))
          : 0;
        const gamma_1 = 1 - gamma;

        const e = toNumVal(d_e) - toNumVal(b_e);
        const beta = e > 0 ? e / (e + toNumVal(lambda_4)) : 0;

        const gamma_2 = gamma > 0 ? 1 - gamma : 1;
        const beta_2 = beta > 0 ? 1 - beta : 1;

        const c_original = toNumVal(b_c);
        const p_c_original = (115 * c_original + 90) / (c_original + 940) / 100 + toNumVal(gold_i);
        const r_h_original = r_h;
        const r_b_original = 0;
        const p_h_original = Math.min(1, 0.95 + r_h_original - r_b_original);
        const m_c_original = 1 + p_c_original * (toNumVal(d_c) - 1);
        const d_mul_original = m_c_original * p_h_original + 0.5 * (1 - p_h_original);
        const G_original = toNumVal(b_s);
        const A_original = toNumVal(D) + toNumVal(R) + G_original;
        const gamma_original = 0;
        const beta_original = 0;
        const gamma_original_2 = 1 - gamma_original;
        const beta_original_2 = 1 - beta_original;

        const baseDamage = (
          (toNumVal(skill_multiplier) / 100) * (((toNumVal(lambda_1) + toNumVal(lambda_2) * A_original) * (1 - gamma_original)) +
            toNumVal(W) * toNumVal(lambda_2) * toNumVal(E) * (1 - beta_original))
        ) * d_mul_original * (1 + toNumVal(flow_percent)) * (1 + toNumVal(damage_increase)) * (1 + toNumVal(skill_damage_increase) / 100);

        const finalDamage = (
          (toNumVal(skill_multiplier) / 100) * (((toNumVal(lambda_1) + toNumVal(lambda_2) * A) * (1 - gamma)) +
            toNumVal(W) * toNumVal(lambda_2) * toNumVal(E) * (1 - beta))
        ) * d_mul * (1 + toNumVal(flow_percent) - toNumVal(flow_resist_percent)) * (1 + toNumVal(damage_increase) - toNumVal(damage_reduction)) * (1 + toNumVal(skill_damage_increase) / 100 - toNumVal(skill_damage_reduction) / 100);

        const totalReduction = (baseDamage - finalDamage) / baseDamage || 0;
        const ehp = toNumVal(hp) / (1 - totalReduction) || toNumVal(hp);

        const base_elementalDamage = (
          (toNumVal(skill_multiplier) / 100) * (toNumVal(W) * toNumVal(lambda_2) * toNumVal(E) * (1 - beta_original))
        ) * d_mul_original * (1 + toNumVal(flow_percent) - toNumVal(flow_resist_percent)) * (1 + toNumVal(damage_increase) - toNumVal(damage_reduction)) * (1 + toNumVal(skill_damage_increase) / 100 - toNumVal(skill_damage_reduction) / 100);

        const elementalDamage = (
          (toNumVal(skill_multiplier) / 100) * (toNumVal(W) * toNumVal(lambda_2) * toNumVal(E) * (1 - beta))
        ) * d_mul * (1 + toNumVal(flow_percent) - toNumVal(flow_resist_percent)) * (1 + toNumVal(damage_increase) - toNumVal(damage_reduction)) * (1 + toNumVal(skill_damage_increase) / 100 - toNumVal(skill_damage_reduction) / 100);

        const base_elementalDamagePrecentage = base_elementalDamage / baseDamage || 0;
        const elementalDamagePrecentage = elementalDamage / finalDamage || 0;

        const calculateRequiredH = (b_b) => {
          const b_b_num = toNumVal(b_b);
          if (b_b_num === 0) {
            return 0;
          }
          const r_b_val = 143 * b_b_num / (b_b_num + 3678) / 100;
          const r_h_target = 0.05 + r_b_val;
          if (r_h_target >= 1.43) { // 143/100 = 1.43æ˜¯ç†è®ºæœ€å¤§å€¼
            return 'ç„¡æ³•æ»¿å‘½ä¸­';
          }
          const numerator = r_h_target * 100 * 3678;
          const denominator = 143 - r_h_target * 100;

          if (denominator <= 0) {
            return 'ç„¡æ³•æ»¿å‘½ä¸­';
          }

          const h_required = Math.ceil(numerator / denominator);

          return h_required > 0 && h_required < 10000 ? h_required : 'ERROR';
        };

        const full_ph = calculateRequiredH(inputs.b_b);

        return {
          c: c.toFixed(2),
          p_c: (p_c * 100).toFixed(2) + "%",
          r_h: (r_h * 100).toFixed(2) + "%",
          r_b: (r_b * 100).toFixed(2) + "%",
          p_h: p_h.toFixed(4),
          m_c: m_c.toFixed(4),
          d_mul: d_mul.toFixed(4),
          G: G.toFixed(2),
          A: A.toFixed(2),
          gamma: (gamma * 100).toFixed(2) + "%",
          gamma_1: (gamma_1 * 100).toFixed(2) + "%",
          beta: (beta * 100).toFixed(2) + "%",
          gamma_2: (gamma_2 * 100).toFixed(2) + "%",
          beta_2: (beta_2 * 100).toFixed(2) + "%",
          c_original: c_original.toFixed(2),
          p_c_original: (p_c_original * 100).toFixed(2) + "%",
          r_h_original: (r_h_original * 100).toFixed(2) + "%",
          r_b_original: (r_b_original * 100).toFixed(2) + "%",
          p_h_original: p_h_original.toFixed(4),
          m_c_original: m_c_original.toFixed(4),
          d_mul_original: d_mul_original.toFixed(4),
          G_original: G_original.toFixed(2),
          A_original: A_original.toFixed(2),
          gamma_original: (gamma_original * 100).toFixed(2) + "%",
          beta_original: (beta_original * 100).toFixed(2) + "%",
          gamma_original_2: (gamma_original_2 * 100).toFixed(2) + "%",
          beta_original_2: (beta_original_2 * 100).toFixed(2) + "%",
          baseDamage: baseDamage.toFixed(2),
          finalDamage: finalDamage.toFixed(2),
          totalReduction: (totalReduction * 100).toFixed(2) + "%",
          ehp: ehp.toFixed(2),
          base_elementalDamage: base_elementalDamage.toFixed(2),
          elementalDamage: elementalDamage.toFixed(2),
          base_elementalDamagePrecentage: (base_elementalDamagePrecentage * 100).toFixed(2) + "%",
          elementalDamagePrecentage: (elementalDamagePrecentage * 100).toFixed(2) + "%",
          full_ph: typeof full_ph === 'number' ? full_ph.toFixed(0) : full_ph,
        };
      };


      const generateChartData = (inputs) => {
        const attribute_points = Array.from({ length: 51 }, (_, i) => i * 200); // [0, 200, ..., 10000]
        const increases = { b_d: [], b_e: [], D: [], E: [], R: [], b_s: [], h: [] };
        const delta_increases = { b_d: [], b_e: [], D: [], E: [], R: [], b_s: [], h: [] };

        const toNum = (val) => {
          const num = parseFloat(val);
          return isNaN(num) ? 0 : num;
        };

        const calculateDamage = (D, E, R, b_d, b_e, b_s, h) => {
          const c = toNum(inputs.b_c) - toNum(inputs.b_c_defense);
          const p_c = (115 * c + 90) / (c + 940) / 100 + toNum(inputs.gold_i);
          const r_h = 143 * toNum(h) / (toNum(h) + 3678) / 100;
          const r_b = 143 * toNum(inputs.b_b) / (toNum(inputs.b_b) + 3678) / 100;
          const p_h = Math.min(1, 0.95 + r_h - r_b);
          const m_c = 1 + p_c * (toNum(inputs.d_c) - 1 - toNum(inputs.b_c_defense));
          const d_mul = m_c * p_h + 0.5 * (1 - p_h);
          const G = toNum(b_s) >= toNum(inputs.d_s)
            ? 0
            : toNum(inputs.d_s) / 3 <= toNum(b_s)
              ? 0.5 * (toNum(inputs.d_s) - toNum(b_s))
              : toNum(inputs.d_s) - 2 * toNum(b_s);
          const A = toNum(D) + (toNum(R) - toNum(inputs.d_f)) - G;
          const gamma = toNum(inputs.d_d) - toNum(b_d) > 0
            ? (toNum(inputs.d_d) - toNum(b_d)) / (toNum(inputs.d_d) - toNum(b_d) + toNum(inputs.lambda_3))
            : 0;
          const e = toNum(inputs.d_e) - toNum(b_e);
          const beta = e > 0 ? e / (e + toNum(inputs.lambda_4)) : 0;
          return (
            (toNum(inputs.skill_multiplier) / 100) *
            (((toNum(inputs.lambda_1) + toNum(inputs.lambda_2) * A) * (1 - gamma)) +
              toNum(inputs.W) * toNum(inputs.lambda_2) * toNum(E) * (1 - beta))
          ) * d_mul *
            (1 + toNum(inputs.flow_percent) - toNum(inputs.flow_resist_percent)) *
            (1 + toNum(inputs.damage_increase) - toNum(inputs.damage_reduction)) *
            (1 + toNum(inputs.skill_damage_increase) / 100 - toNum(inputs.skill_damage_reduction) / 100);
        };

        // âœ… ä¿®æ­£ï¼šè¨ˆç®—æ»¿å‘½ä¸­æ‰€éœ€çš„å‘½ä¸­å€¼
        const calculateRequiredH = (b_b) => {
          const b_b_num = toNum(b_b);
          if (b_b_num === 0) return 0;

          const r_b_val = 143 * b_b_num / (b_b_num + 3678) / 100;
          const r_h_target = 0.05 + r_b_val;

          if (r_h_target >= 1.43) return 10000; // è¨­å®šä¸€å€‹é«˜å€¼è¡¨ç¤ºç„¡æ³•é”æˆ

          const numerator = r_h_target * 100 * 3678;
          const denominator = 143 - r_h_target * 100;

          if (denominator <= 0) return 10000;

          return Math.ceil(numerator / denominator);
        };

        // âœ… ä¿®æ­£ï¼šä½¿ç”¨æ»¿å‘½ä¸­ä½œç‚ºåŸºæº–ï¼Œè€Œä¸æ˜¯å…¨éƒ¨å±¬æ€§ç‚º0
        const fullHitRequired = calculateRequiredH(toNum(inputs.b_b));
        const baselineH = Math.min(fullHitRequired, 10000); // ç¢ºä¿ä¸æœƒéé«˜

        // åŸºæº–å‚·å®³ï¼šä½¿ç”¨æ»¿å‘½ä¸­ + å…¶ä»–å±¬æ€§ç‚º0çš„æƒ…æ³
        const baseDamage = calculateDamage(
          toNum(inputs.D),
          toNum(inputs.E),
          0, // R = 0
          0, // b_d = 0
          0, // b_e = 0
          0, // b_s = 0
          baselineH // h = æ»¿å‘½ä¸­æ‰€éœ€å€¼
        );

        const calculateIncrease = (attr, value) => {
          const params = {
            D: toNum(inputs.D),
            E: toNum(inputs.E),
            R: 0,
            b_d: 0,
            b_e: 0,
            b_s: 0,
            h: baselineH // âœ… åŸºæº–å‘½ä¸­å€¼
          };

          // è¨­å®šå±¬æ€§å€¼
          if (['R', 'b_d', 'b_e', 'b_s'].includes(attr)) {
            // R, b_d, b_e, b_s ä½¿ç”¨çµ•å°å€¼
            params[attr] = value;
          } else if (attr === 'h') {
            // âœ… å‘½ä¸­ä½¿ç”¨åŸºæº–å€¼ + å¢é‡
            params[attr] = baselineH + value;
          } else {
            // D, E ä½¿ç”¨ç•¶å‰å€¼ + å¢é‡
            params[attr] = toNum(inputs[attr]) + value;
          }

          const newDamage = calculateDamage(
            params.D, params.E, params.R, params.b_d, params.b_e, params.b_s, params.h
          );
          const increase = baseDamage ? (newDamage - baseDamage) / baseDamage : 0;

          // âœ… è² æ”¶ç›Šé¡¯ç¤ºç‚º0
          return Math.max(0, increase);
        };

        attribute_points.forEach((point) => {
          increases.D.push(calculateIncrease('D', point));
          increases.E.push(calculateIncrease('E', point));
          increases.R.push(calculateIncrease('R', point));
          increases.b_d.push(calculateIncrease('b_d', point));
          increases.b_e.push(calculateIncrease('b_e', point));
          increases.b_s.push(calculateIncrease('b_s', point));
          increases.h.push(calculateIncrease('h', point));
        });

        for (let i = 1; i < increases.b_s.length; i++) {
          // âœ… é‚Šéš›æ”¶ç›Šä¹Ÿç¢ºä¿ä¸ç‚ºè² æ•¸
          delta_increases.D.push(Math.max(0, increases.D[i] - increases.D[i - 1]));
          delta_increases.E.push(Math.max(0, increases.E[i] - increases.E[i - 1]));
          delta_increases.R.push(Math.max(0, increases.R[i] - increases.R[i - 1]));
          delta_increases.b_d.push(Math.max(0, increases.b_d[i] - increases.b_d[i - 1]));
          delta_increases.b_e.push(Math.max(0, increases.b_e[i] - increases.b_e[i - 1]));
          delta_increases.b_s.push(Math.max(0, increases.b_s[i] - increases.b_s[i - 1]));
          delta_increases.h.push(Math.max(0, increases.h[i] - increases.h[i - 1]));
        }

        const deltaData = attribute_points.slice(1).map((point, i) => ({
          point,
          D: delta_increases.D[i],
          E: delta_increases.E[i],
          R: delta_increases.R[i],
          b_d: delta_increases.b_d[i],
          b_e: delta_increases.b_e[i],
          b_s: delta_increases.b_s[i],
          h: delta_increases.h[i],
        }));

        const increaseData = attribute_points.map((point, i) => ({
          point,
          D: increases.D[i],
          E: increases.E[i],
          R: increases.R[i],
          b_d: increases.b_d[i],
          b_e: increases.b_e[i],
          b_s: increases.b_s[i],
          h: increases.h[i]
        }));

        return {
          deltaData,
          increaseData,
          baselineInfo: {
            fullHitRequired,
            baselineH,
            baseDamage: baseDamage.toFixed(2)
          }
        };
      };

      const CustomTooltip = ({ active, payload, label, isDelta }) => {
        if (active && payload && payload.length) {
          return (
            <div className="bg-white p-3 border border-gray-200 rounded-lg shadow-sm">
              <p className="text-sm text-gray-700 font-medium">å±¬æ€§é»: {label}</p>
              {payload.map((entry, index) => (
                <p key={index} className="text-sm text-gray-600">
                  <span style={{ color: entry.stroke }}>{entry.name}</span>: {(entry.value * 100).toFixed(isDelta ? 4 : 2)}%
                </p>
              ))}
            </div>
          );
        }
        return null;
      };

      const result = calculate(inputs);
      const { deltaData, increaseData } = generateChartData(inputs);


      return (
        <div className="p-4 container mx-auto min-h-screen">
          <div className="cherry-gradient rounded-xl p-6 mb-6 shadow-lg">
            <h1 className="text-xl md:text-2xl font-bold text-center text-white">æ”»æ“Šè¨ˆç®—å™¨</h1>
            <p className="text-center text-white text-opacity-90 text-sm mt-1">å¦‚æœ‰å•é¡Œè«‹è¯ç¹«æ«»æ¡ƒç™½è˜­åœ°@ç·£å®šä»Šç”Ÿ</p>
          </div>

          <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-4">
            <div
              className="flex justify-between items-center cursor-pointer mb-2"
              onClick={() => setShowAttacker(!showAttacker)}
            >
              <div className="flex items-center">
                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                <h2 className="font-bold text-base md:text-lg text-gray-800">æ”»æ“Šæ–¹åƒæ•¸</h2>
              </div>
              <span className="text-cherry-700 text-lg">{showAttacker ? '^' : 'âŒ„'}</span>
            </div>
            <div
              className={`transition-all duration-500 overflow-hidden ${showAttacker ? 'max-h-[1000px] opacity-100' : 'max-h-0 opacity-0'}`}
            >
              <ImageUploader setInputs={setInputs} type="attacker" />
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {[
                  { key: "skill_multiplier", label: "æŠ€èƒ½å€ç‡", icon: "ğŸ”¥", tooltip: "å¦‚æŠ€èƒ½å€ç‡ç‚º300%ï¼Œè¼¸å…¥300" },
                  { key: "D", label: "æ”»æ“Š", icon: "âš”ï¸" },
                  { key: "E", label: "å…ƒç´ æ”»æ“Šï¼ˆå¹³å‡ï¼‰", icon: "âœ¨" },
                  { key: "b_c", label: "æœƒå¿ƒæ•¸å€¼", icon: "ğŸ¯" },
                  { key: "d_c", label: "æœƒå¿ƒå‚·å®³", icon: "ğŸ’¥", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚180%ï¼Œè¼¸å…¥1.8" },
                  { key: "R", label: "æµæ´¾å…‹åˆ¶", icon: "ğŸ”„" },
                  { key: "h", label: "å‘½ä¸­", icon: "ğŸ¯" },
                  { key: "b_d", label: "ç ´é˜²", icon: "ğŸ›¡ï¸" },
                  { key: "b_s", label: "ç ´ç›¾", icon: "ğŸ”¨" },
                  { key: "b_e", label: "å¿½è¦–å…ƒç´ æŠ—æ€§", icon: "ğŸŒ€" },
                  { key: "flow_percent", label: "æµæ´¾å…‹åˆ¶%", icon: "ğŸ“Š", tooltip: "ä¾‹å¦‚9.5%ï¼Œè¼¸å…¥0.095ã€‚æ‰€æœ‰%çš†ç‚ºç›¸åŠ ï¼Œä¾‹å¦‚10%+5%=15%=è¼¸å…¥0.15" },
                  { key: "damage_increase", label: "å¢å‚·%", icon: "ğŸ“ˆ", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05ã€‚æ‰€æœ‰%çš†ç‚ºç›¸åŠ ï¼Œä¾‹å¦‚10%+5%=15%=è¼¸å…¥0.15" },
                  { key: "skill_damage_increase", label: "æŠ€èƒ½å¢å‚·%", icon: "ğŸ“ˆ", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05ã€‚æ‰€æœ‰%çš†ç‚ºç›¸åŠ ï¼Œä¾‹å¦‚10%+5%=15%=è¼¸å…¥0.15" },
                  { key: "gold_i", label: "é‡‘å‘¨å¤©", icon: "ğŸŒŸ", type: "select", options: goldOptions },
                  { key: "W", label: "å…ƒç´ å¼±é»", icon: "ğŸ–•ğŸ»", type: "select", options: elementWeaknessOptions }
                ].map(({ key, label, icon, type, options, tooltip }) => (
                  <div key={key} className="flex flex-col group relative">
                    <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                      <span className="mr-1 md:mr-2">{icon}</span>{label}{tooltip && <span> </span>}
                      {tooltip && (
                        <>
                          <span className="flex items-center justify-center w-4 h-4 rounded-full bg-gray-500 text-white text-xs cursor-pointer">?</span>
                          <div className="tooltip-hidden absolute left-0 top-8 bg-cherry-50 text-cherry-700 text-xs p-2 rounded-lg shadow-md z-10 max-w-xs">
                            {tooltip}
                          </div>
                        </>
                      )}
                    </label>
                    {type === "select" ? (
                      <select
                        name={key}
                        value={inputs[key]}
                        onChange={handleChange}
                        className="input-focus border border-gray-200 rounded-lg p-2 text-sm w-full"
                        aria-label={label}
                      >
                        {options.map(opt => (
                          <option key={opt.value} value={opt.value}>{opt.label}</option>
                        ))}
                      </select>
                    ) : (
                      <input
                        type="number"
                        name={key}
                        value={inputs[key]}
                        onChange={handleChange}
                        min="0"
                        max="1000000"
                        className={`input-focus border ${inputErrors[key] ? 'border-red-500' : 'border-gray-200'} rounded-lg p-2 text-sm w-full`}
                        aria-label={label}
                      />
                    )}
                    {inputErrors[key] && (
                      <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                    )}
                  </div>
                ))}
              </div>
            </div>
          </div>

          <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-4">
            <div
              className="flex justify-between items-center cursor-pointer mb-2"
              onClick={() => setShowDefender(!showDefender)}
            >
              <div className="flex items-center">
                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                <h2 className="font-bold text-base md:text-lg text-gray-800">é˜²å®ˆæ–¹åƒæ•¸</h2>
              </div>
              <span className="text-cherry-700 text-lg">{showDefender ? '^' : 'âŒ„'}</span>
            </div>
            <div
              className={`transition-all duration-500 overflow-hidden ${showDefender ? 'max-h-[1000px] opacity-100' : 'max-h-0 opacity-0'}`}
            >
              <ImageUploader setInputs={setInputs} type="defender" />
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {[
                  { key: "d_s", label: "æ°£ç›¾", icon: "ğŸ›¡ï¸" },
                  { key: "d_f", label: "æµæ´¾æŠµç¦¦", icon: "ğŸ”„" },
                  { key: "d_d", label: "é˜²ç¦¦", icon: "ğŸ°" },
                  { key: "d_e", label: "å…ƒç´ æŠ—æ€§", icon: "ğŸŒ€" },
                  { key: "b_b", label: "æ ¼æ“‹", icon: "âœ‹" },
                  { key: "hp", label: "æ°£è¡€", icon: "â¤ï¸" },
                  { key: "b_c_defense", label: "æŠ—æœƒå¿ƒæ•¸å€¼", icon: "ğŸ¯" },
                  { key: "d_c_defense", label: "æœƒå¿ƒé˜²ç¦¦%", icon: "ğŸ“Š", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚25%ï¼Œè¼¸å…¥0.25ã€‚æ‰€æœ‰%çš†ç‚ºç›¸åŠ ï¼Œä¾‹å¦‚10%+5%=15%=è¼¸å…¥0.15" },
                  { key: "flow_resist_percent", label: "æµæ´¾æŠµç¦¦%", icon: "ğŸ“Š", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05ã€‚æ‰€æœ‰%çš†ç‚ºç›¸åŠ ï¼Œä¾‹å¦‚10%+5%=15%=è¼¸å…¥0.15" },
                  { key: "damage_reduction", label: "å‚·å®³æ¸›å…%", icon: "ğŸ“‰", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚15%ï¼Œè¼¸å…¥0.15ã€‚æ‰€æœ‰%çš†ç‚ºç›¸åŠ ï¼Œä¾‹å¦‚10%+5%=15%=è¼¸å…¥0.15" },
                  { key: "skill_damage_reduction", label: "æŠ€èƒ½æ¸›å…%", icon: "ğŸ“‰", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05ã€‚æ‰€æœ‰%çš†ç‚ºç›¸åŠ ï¼Œä¾‹å¦‚10%+5%=15%=è¼¸å…¥0.15" }
                ].map(({ key, label, icon, tooltip }) => (
                  <div key={key} className="flex flex-col group relative">
                    <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                      <span className="mr-1 md:mr-2">{icon}</span>{label}{tooltip && <span> </span>}
                      {tooltip && (
                        <>
                          <span className="flex items-center justify-center w-4 h-4 rounded-full bg-gray-500 text-white text-xs cursor-pointer">?</span>
                          <div className="tooltip-hidden absolute left-0 top-8 bg-cherry-50 text-cherry-700 text-xs p-2 rounded-lg shadow-md z-10 max-w-xs">
                            {tooltip}
                          </div>
                        </>
                      )}
                    </label>
                    <input
                      type="number"
                      name={key}
                      value={inputs[key]}
                      onChange={handleChange}
                      min="0"
                      max="1000000"
                      className={`input-focus border ${inputErrors[key] ? 'border-red-500' : 'border-gray-200'} rounded-lg p-2 text-sm w-full`}
                      aria-label={label}
                    />
                    {inputErrors[key] && (
                      <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                    )}
                  </div>
                ))}
              </div>
            </div>
          </div>

          <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
            {/* åŸæ•¸å€¼å±¬æ€§å€å¡Š */}
            <div
              className="flex justify-between items-center cursor-pointer mb-2"
              onClick={() => setShowOriginal(!showOriginal)}
            >
              <div className="flex items-center">
                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                <h2 className="font-bold text-base md:text-lg text-gray-800">åŸæ•¸å€¼å±¬æ€§</h2>
              </div>
              <span className="text-cherry-700 text-lg">{showOriginal ? '^' : 'âŒ„'}</span>
            </div>
            <div className={`transition-all duration-500 overflow-hidden ${showOriginal ? 'max-h-[1000px] opacity-100' : 'max-h-0 opacity-0'}`}>
              <div className="grid grid-cols-2 gap-3 mb-4">
                {[{ label: "çœŸå¯¦æœƒå¿ƒ", value: result.c_original },
                { label: "æœƒå¿ƒç‡", value: result.p_c_original },
                { label: "å‘½ä¸­å¢å¹…å€ç‡", value: result.p_h_original },
                { label: "æœƒå¿ƒå‚·å®³å€ç‡", value: result.m_c_original },
                { label: "å‚·å®³å€ç‡", value: result.d_mul_original },
                { label: "å‰©é¤˜æ°£ç›¾", value: result.G_original },
                { label: "é˜²ç¦¦ç©¿é€ç‡", value: result.gamma_original_2 },
                { label: "å…ƒç´ ç©¿é€ç‡", value: result.beta_original_2 },
                { label: "å…ƒç´ å‚·å®³ä½”æ¯”", value: result.base_elementalDamagePrecentage }]
                  .map(({ label, value }) => (
                    <div key={label} className="bg-gray-50 p-2 md:p-3 rounded-lg">
                      <p className="text-xs text-gray-600">{label}</p>
                      <p className="text-sm font-bold text-gray-800">{value}</p>
                    </div>
                  ))}
              </div>
            </div>

            {/* ä¿®æ­£å¾Œå±¬æ€§å€å¡Š */}
            <div
              className="flex justify-between items-center cursor-pointer mb-2"
              onClick={() => setShowCorrected(!showCorrected)}
            >
              <div className="flex items-center">
                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                <h2 className="font-bold text-base md:text-lg text-gray-800">ä¿®æ­£å¾Œå±¬æ€§</h2>
              </div>
              <span className="text-cherry-700 text-lg">{showCorrected ? '^' : 'âŒ„'}</span>
            </div>
            <div className={`transition-all duration-500 overflow-hidden ${showCorrected ? 'max-h-[1000px] opacity-100' : 'max-h-0 opacity-0'}`}>
              <div className="grid grid-cols-2 gap-3">
                {[{ label: "ä¿®æ­£æœƒå¿ƒ", value: result.c },
                { label: "æœƒå¿ƒç‡", value: result.p_c },
                { label: "å‘½ä¸­å¢å¹…å€ç‡", value: result.p_h },
                { label: "æœƒå¿ƒå‚·å®³å€ç‡", value: result.m_c },
                { label: "å‚·å®³å€ç‡", value: result.d_mul },
                { label: "å‰©é¤˜æ°£ç›¾", value: result.G },
                { label: "é˜²ç¦¦ç©¿é€ç‡", value: result.gamma_2 },
                { label: "å…ƒç´ ç©¿é€ç‡", value: result.beta_2 },
                { label: "å…ƒç´ å‚·å®³ä½”æ¯”", value: result.elementalDamagePrecentage }]
                  .map(({ label, value }) => (
                    <div key={label} className="bg-cherry-50 p-2 md:p-3 rounded-lg">
                      <p className="text-xs text-cherry-600">{label}</p>
                      <p className="text-sm font-bold text-cherry-800">{value}</p>
                    </div>
                  ))}
              </div>
            </div>
          </div>
          <div className="result-card bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
            <div className="flex justify-between items-center mb-4">
              <div className="flex items-center">
                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                <h2 className="font-bold text-base md:text-lg text-gray-800">å‚·å®³è¨ˆç®—çµæœ</h2>
              </div>
              <button
                onClick={saveCurrentResult}
                className="bg-cherry-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-cherry-700 transition-colors"
              >
                ä¿å­˜çµæœ
              </button>
            </div>
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-3">
              {[
                { label: "åŸå‚·å®³", value: result.baseDamage, color: "cherry-100" },
                { label: "ä¿®æ­£å¾Œå‚·å®³", value: result.finalDamage, color: "cherry-100" },
                { label: "æ»¿å‘½ä¸­", value: result.full_ph, color: "cherry-100" },
                { label: "å‚·å®³æŠµæ¶ˆç‡", value: result.totalReduction, color: "cherry-500", text: "white" },
              ].map(({ label, value, color, text }) => (
                <div key={label} className={`bg-${color} p-3 rounded-lg`}>
                  <p className={`text-xs ${text ? `text-${text}` : 'text-cherry-700'}`}>{label}</p>
                  <p className={`text-lg font-bold ${text ? `text-${text}` : 'text-cherry-800'}`}>{value}</p>
                </div>
              ))}
            </div>
            {previousResult && previousInputs && (
              <div className="mt-6">
                <div className="flex items-center mb-4">
                  <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                  <h3 className="font-bold text-base md:text-lg text-gray-800">èˆ‡ä¸Šæ¬¡çµæœå°æ¯”</h3>
                </div>
                <div className="overflow-x-auto scrollbar-cherry">
                  <table className="w-full text-sm border-collapse">
                    <thead>
                      <tr className="bg-cherry-50">
                        <th className="border p-2 text-left text-cherry-700">é …ç›®</th>
                        <th className="border p-2 text-left text-cherry-700">ç•¶å‰</th>
                        <th className="border p-2 text-left text-cherry-700">ä¸Šæ¬¡</th>
                        <th className="border p-2 text-left text-cherry-700">å·®ç•°</th>
                      </tr>
                    </thead>
                    <tbody>
                      {[
                        { key: 'D', label: 'æ”»æ“Š' },
                        { key: 'E', label: 'å…ƒç´ æ”»æ“Šï¼ˆå¹³å‡ï¼‰' },
                        { key: 'b_d', label: 'ç ´é˜²' },
                        { key: 'R', label: 'æµæ´¾å…‹åˆ¶' },
                        { key: 'b_e', label: 'å¿½è¦–å…ƒç´ æŠ—æ€§' },
                        { key: 'h', label: 'å‘½ä¸­' },
                        { key: 'b_s', label: 'ç ´ç›¾' },
                        { key: 'gamma_2', label: 'é˜²ç¦¦ç©¿é€ç‡' },
                        { key: 'beta_2', label: 'å…ƒç´ ç©¿é€ç‡' },
                        { key: 'elementalDamagePrecentage', label: 'å…ƒç´ å‚·å®³ä½”æ¯”' },
                        { key: 'baseDamage', label: 'åŸå‚·å®³' },
                        { key: 'finalDamage', label: 'ä¿®æ­£å¾Œå‚·å®³' },
                        { key: 'totalReduction', label: 'å‚·å®³ä¿®æ­£ç‡' }
                      ].map(({ key, label }) => {
                        const currentValue = key in inputs ? inputs[key] : result[key];
                        const previousValue = key in previousInputs ? previousInputs[key] : previousResult[key];
                        const current = parseFloat(String(currentValue).replace('%', '')) || 0;
                        const previous = parseFloat(String(previousValue).replace('%', '')) || 0;
                        const diff = current - previous;
                        const isPositive = diff > 0;
                        return (
                          <tr key={key} className="hover:bg-cherry-50">
                            <td className="border p-2 text-gray-700">{label}</td>
                            <td className="border p-2 font-medium">{currentValue}</td>
                            <td className="border p-2">{previousValue}</td>
                            <td className={`border p-2 font-medium ${isPositive ? 'text-green-600' : 'text-red-600'}`}>
                              {isPositive ? 'â†‘' : 'â†“'} {Math.abs(diff).toFixed(2)}{key === 'totalReduction' ? '%' : ''}
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </div>
                <div className="mt-4 p-3 bg-cherry-50 rounded-lg">
                  <h4 className="font-bold text-cherry-700 mb-2 flex items-center">
                    <svg className="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                      <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9z" clipRule="evenodd" />
                    </svg>
                    é…ç½®å»ºè­°
                  </h4>
                  <p className="text-xs text-gray-700">
                    ä¸æœƒç©DPS, ä¸çŸ¥é“
                  </p>
                </div>
              </div>
            )}
          </div>

          <div className="grid grid-cols-1 gap-4 mb-6">
            <div className="result-card bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100">
              <div className="flex items-center mb-4">
                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                <h2 className="font-bold text-base md:text-lg text-gray-800">æ¯200é»å±¬æ€§å¢å‚·æ”¶ç›Š-åŸºæ–¼ç¾æœ‰æ”»æ“Šè¨ˆç®—</h2>
              </div>
              {/* æ–°å¢å‹¾é¸æ¡† */}
              <div className="flex flex-wrap gap-4 mb-4">
                {[
                  { key: 'b_d', label: 'ç ´é˜²', color: '#3b82f6' },
                  { key: 'b_e', label: 'å¿½è¦–å…ƒç´ æŠ—æ€§', color: '#10b981' },
                  { key: 'b_s', label: 'ç ´ç›¾', color: '#8b5cf6' },
                  { key: 'R', label: 'å…‹åˆ¶', color: '#14b8a6' },

                  { key: 'D', label: 'æ”»æ“Š', color: '#db2537' },

                ].map(({ key, label, color }) => (
                  <label key={key} className="flex items-center">
                    <input
                      type="checkbox"
                      checked={visibility[key]}
                      onChange={() => toggleVisibility(key)}
                      className="mr-2"
                    />
                    <span style={{ color }}>{label}</span>
                  </label>
                ))}
              </div>
              <div className="w-full h-[250px] sm:h-[300px] md:h-[350px]">
                <Recharts.ResponsiveContainer width="100%" height="100%">
                  <Recharts.LineChart data={deltaData}>
                    <Recharts.CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
                    <Recharts.XAxis
                      dataKey="point"
                      label={{ value: "å±¬æ€§é»", position: "insideBottom", offset: -5, fontSize: 12, fill: "#6b7280" }}
                      tick={{ fill: "#6b7280", fontSize: 12 }}
                    />
                    <Recharts.YAxis
                      label={{ value: "æ¯200é»æ”¶ç›Š (%)", angle: -90, position: "insideLeft", fontSize: 12, fill: "#6b7280" }}
                      tickFormatter={(value) => (value * 100).toFixed(4)}
                      tick={{ fill: "#6b7280", fontSize: 12 }}
                    />
                    <Recharts.Tooltip content={<CustomTooltip isDelta={true} />} />
                    <Recharts.Legend wrapperStyle={{ fontSize: 12 }} />
                    {/* æ ¹æ“šå¯è¦‹æ€§å‹•æ…‹æ¸²æŸ“æ›²ç·š */}
                    {visibility.b_d && <Recharts.Line type="monotone" dataKey="b_d" name="ç ´é˜²" stroke="#3b82f6" strokeWidth={2} dot={false} />}
                    {visibility.b_e && <Recharts.Line type="monotone" dataKey="b_e" name="å¿½è¦–å…ƒç´ æŠ—æ€§" stroke="#10b981" strokeWidth={2} dot={false} />}
                    {visibility.b_s && <Recharts.Line type="monotone" dataKey="b_s" name="ç ´ç›¾" stroke="#8b5cf6" strokeWidth={2} dot={false} />}
                    {visibility.R && <Recharts.Line type="monotone" dataKey="R" name="å…‹åˆ¶" stroke="#14b8a6" strokeWidth={2} dot={false} />}

                    {visibility.D && <Recharts.Line type="monotone" dataKey="D" name="æ”»æ“Š" stroke="#db2537" strokeWidth={2} dot={false} />}

                  </Recharts.LineChart>
                </Recharts.ResponsiveContainer>
              </div>
            </div>

            <div className="result-card bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100">
              <div className="flex items-center mb-4">
                <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
                <h2 className="font-bold text-base md:text-lg text-gray-800">éå¢å±¬æ€§æ”¶ç›Šèµ°å‹¢-åŸºæ–¼ç¾æœ‰æ”»æ“Šè¨ˆç®—</h2>
              </div>
              {/* æ–°å¢å‹¾é¸æ¡† */}
              <div className="flex flex-wrap gap-4 mb-4">
                {[
                  { key: 'b_d', label: 'ç ´é˜²', color: '#3b82f6' },
                  { key: 'b_e', label: 'å¿½è¦–å…ƒç´ æŠ—æ€§', color: '#10b981' },
                  { key: 'b_s', label: 'ç ´ç›¾', color: '#8b5cf6' },
                  { key: 'R', label: 'å…‹åˆ¶', color: '#14b8a6' },

                  { key: 'D', label: 'æ”»æ“Š', color: '#db2537' },

                ].map(({ key, label, color }) => (
                  <label key={key} className="flex items-center">
                    <input
                      type="checkbox"
                      checked={visibility[key]}
                      onChange={() => toggleVisibility(key)}
                      className="mr-2"
                    />
                    <span style={{ color }}>{label}</span>
                  </label>
                ))}
              </div>
              <div className="w-full h-[250px] sm:h-[300px] md:h-[350px]">
                <Recharts.ResponsiveContainer width="100%" height="100%">
                  <Recharts.LineChart data={increaseData}>
                    <Recharts.CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
                    <Recharts.XAxis
                      dataKey="point"
                      label={{ value: "å±¬æ€§é»", position: "insideBottom", offset: -5, fontSize: 12, fill: "#6b7280" }}
                      tick={{ fill: "#6b7280", fontSize: 12 }}
                    />
                    <Recharts.YAxis
                      label={{ value: "ç´¯è¨ˆæ”¶ç›Š (%)", angle: -90, position: "insideLeft", fontSize: 12, fill: "#6b7280" }}
                      tickFormatter={(value) => (value * 100).toFixed(2)}
                      tick={{ fill: "#6b7280", fontSize: 12 }}
                    />
                    <Recharts.Tooltip content={<CustomTooltip isDelta={false} />} />
                    <Recharts.Legend wrapperStyle={{ fontSize: 12 }} />
                    {/* æ ¹æ“šå¯è¦‹æ€§å‹•æ…‹æ¸²æŸ“æ›²ç·š */}
                    {visibility.b_d && <Recharts.Line type="monotone" dataKey="b_d" name="ç ´é˜²" stroke="#3b82f6" strokeWidth={2} dot={false} />}
                    {visibility.b_e && <Recharts.Line type="monotone" dataKey="b_e" name="å¿½è¦–å…ƒç´ æŠ—æ€§" stroke="#10b981" strokeWidth={2} dot={false} />}
                    {visibility.b_s && <Recharts.Line type="monotone" dataKey="b_s" name="ç ´ç›¾" stroke="#8b5cf6" strokeWidth={2} dot={false} />}
                    {visibility.R && <Recharts.Line type="monotone" dataKey="R" name="å…‹åˆ¶" stroke="#14b8a6" strokeWidth={2} dot={false} />}

                    {visibility.D && <Recharts.Line type="monotone" dataKey="D" name="æ”»æ“Š" stroke="#db2537" strokeWidth={2} dot={false} />}

                  </Recharts.LineChart>
                </Recharts.ResponsiveContainer>
              </div>
            </div>
          </div>

          <div className="text-center text-xs text-gray-500 mb-4">
            <p>æ”»æ“Šè¨ˆç®—å™¨ Â© {new Date().getFullYear()} | æ•¸æ“šåƒ…ä¾›åƒè€ƒ</p>
          </div>
        </div>

      );
    };

    // Footer Component
    const Footer = () => {
      return (
        <footer className="bg-transparent text-gray-700 p-4 text-center mt-6">
          <div className="max-w-3xl mx-auto text-sm text-center">
            <p className="font-semibold mb-1">æ«»æ¡ƒç¢ç¢å¿µ</p>
            <p>
              å…¬å¼åƒè€ƒäº†
              <a
                href="https://m.bilibili.com/opus/979579497904865287"
                target="_blank"
                rel="noopener noreferrer"
                className="text-cherry-600 hover:underline"
              >
                æŠ˜å­—æ„¿ä¸ºå®‰
              </a>
              å’Œ
              <a
                href="https://b23.tv/C4Iq2IZ"
                target="_blank"
                rel="noopener noreferrer"
                className="text-cherry-600 hover:underline"
              >
                è¿›å›¢å…ˆå‘ç§’ä¼¤
              </a>
              å…©ä½è€å¸«çš„å°ˆæ¬„ã€‚ç¶“éé©—è­‰é©ç”¨æ–¼å°æœç›®å‰ç‰ˆæœ¬ã€‚è€ƒæ…®åˆ°å¾ˆå¤šäººä¸å¤ªå–œæ­¡æ•¸å­¸ï¼Œæ‰€ä»¥æ‰æ•´åˆæˆè¨ˆç®—å™¨ã€‚æœ¬ä¾†é‚„æƒ³åŠ ä¸Šå°å¡”å‚·å®³éƒ¨åˆ†ï¼Œä½†å› ç‚ºæˆ‘ä¸€å€‹äººé›£ä»¥é©—è­‰ï¼Œçµæœé‚„æ˜¯æ”¾æ£„äº†ã€‚å¾ŒçºŒå¯èƒ½å¤§æ¦‚é‚„æœƒæ›´æ–°å…§åŠŸå’Œå‘¨å¤©ï¼Œå¯èƒ½å§æˆ‘ä¹Ÿä¸çŸ¥é“ã€‚
            </p>
          </div>
        </footer>
      );
    };

    // App Component
    const App = () => {
      const [activeCalculator, setActiveCalculator] = useState(null);

      return (
        <div className="flex min-h-screen flex-col">
          <div className="flex flex-1">
            <Sidebar setActiveCalculator={setActiveCalculator} />
            <div className="flex-1 md:ml-64">
              {!activeCalculator ? (
                <HomeMenu setActiveCalculator={setActiveCalculator} />
              ) : activeCalculator === 'damage' ? (
                <DamageCalculator />
              ) : activeCalculator === 'healing' ? (
                <HealingCalculator />
              ) : (
                <DamageCalculator2 />
              )}
            </div>
          </div>
          <Footer />
        </div>
      );
    };


    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);


  </script>






</body></html>